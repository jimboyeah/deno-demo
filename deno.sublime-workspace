{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"hard",
				"hard-light\t(svg.md)"
			],
			[
				"g",
				"知识付费时代-gitchat/"
			],
			[
				"dra",
				"draw/"
			],
			[
				"loca",
				"location\t(csharp.md)"
			],
			[
				"repos",
				"repository\t(csharp.md)"
			],
			[
				"fle",
				"flex"
			],
			[
				"json",
				"json_encode"
			],
			[
				"print",
				"printer_abort"
			],
			[
				"JSON",
				"json_encode"
			],
			[
				"FILE",
				"_FILES"
			],
			[
				"n",
				"node_modules/"
			],
			[
				"value",
				"value4\tlet"
			],
			[
				"con",
				"console\tvar"
			],
			[
				"LogL",
				"LogLevelStrings\ttype"
			],
			[
				"par",
				"parseInt\tfunction"
			],
			[
				"resu",
				"result2\tlet"
			],
			[
				"Par",
				"Partial\ttype"
			],
			[
				"ReactRou",
				"ReactRouterDOM"
			],
			[
				"ne",
				"nextPuzzle"
			],
			[
				"max",
				"max-width\tproperty"
			],
			[
				"word",
				"wordlist"
			],
			[
				"qml",
				"main.qml"
			],
			[
				"p",
				"plugins/"
			],
			[
				"img",
				"imageMat"
			],
			[
				"lena",
				"lena_thresh"
			],
			[
				"chapp",
				"ch_app.erl"
			],
			[
				"wxMen",
				"wxMenuBar"
			],
			[
				"create",
				"create_test_menu"
			],
			[
				"ge",
				"GenerateNames"
			],
			[
				"I",
				"IsStatic"
			],
			[
				"lo",
				"localhost.pfx"
			],
			[
				"Hook",
				"KeyboardHook"
			],
			[
				"Hoo",
				"HookStop"
			],
			[
				"Ho",
				"HookStart"
			],
			[
				"int",
				"Int32"
			],
			[
				"PlaySoun",
				"PlaySoundFlags"
			],
			[
				"O",
				"OpenFileDialog"
			],
			[
				"From",
				"Form1_Load"
			],
			[
				"Form1",
				"Form1_Load"
			],
			[
				"Do",
				"DoWorkStatic"
			],
			[
				"S",
				"Singletons"
			],
			[
				"Test",
				"TestClass"
			],
			[
				"_",
				"_count"
			],
			[
				"Con",
				"Contacts"
			],
			[
				"up",
				"upperCase"
			],
			[
				"cli",
				"on_button_clicked"
			],
			[
				"height",
				"max-height\tproperty"
			],
			[
				"so",
				"socket.io-client"
			],
			[
				"En",
				"EncodeToString\tfunc(src []byte) string ·ƒ"
			],
			[
				"st",
				"StdEncoding\t*base64.Encoding ·ν"
			],
			[
				"Engin",
				"EngineioMessage\tfunc(text string) ·ƒ"
			],
			[
				"EIO",
				"EIO_Message\tEngineioPacket ·Ɩ"
			],
			[
				"SIO_Bin",
				"SIO_Binary_Event\tSocketioPacket ·Ɩ"
			],
			[
				"SIO",
				"SIO_Event\tSocketioPacket ·Ɩ"
			],
			[
				"U",
				"Uint16\tfunc(b []byte) uint16 ·ƒ"
			],
			[
				"Error",
				"ErrorNil\tErrorCode ·Ɩ"
			],
			[
				"Err",
				"ErrorNil\tErrorCode ·Ɩ"
			],
			[
				"Messa",
				"MessageType\tbyte ·ʈ"
			],
			[
				"E",
				"Err\terror ·ν"
			],
			[
				"e",
				"Err\terror ·ν"
			],
			[
				"b",
				"brw\t*bufio.ReadWriter ·ν"
			],
			[
				"Mi",
				"Millisecond\ttime.Duration ·Ɩ"
			],
			[
				"Webs",
				"github.com/gorilla/websocket\t ·ʂ"
			],
			[
				"Set",
				"SetReadDeadline\tfunc(t time.Time) error ·ƒ"
			],
			[
				"B",
				"BrokenMessage\tMessageType ·Ɩ"
			],
			[
				"R",
				"RemoteAddr\tfunc() net.Addr ·ƒ"
			],
			[
				"P",
				"parsed\tbool ·ν"
			],
			[
				"utf",
				"unicode/utf8\t ·ʂ"
			],
			[
				"Mask",
				"Masking\tbool ·ν"
			],
			[
				"Mess",
				"MessageType\tbyte ·ʈ"
			],
			[
				"Ma",
				"Maskingkey\t[4]byte ·ν"
			],
			[
				"Masking",
				"Masking\tbool ·ν"
			],
			[
				"M",
				"Maskingkey\t[4]byte ·ν"
			],
			[
				"CloseMe",
				"CloseMessageCode\tuint ·ʈ"
			],
			[
				"Ti",
				"PingTimeout\ttime.Duration ·Ɩ"
			],
			[
				"Ping",
				"PingTimeout\ttime.Duration ·Ɩ"
			],
			[
				"r",
				"SetReadDeadline\tfunc(t time.Time) error ·ƒ"
			],
			[
				"Read",
				"ReadWriter\tstruct ·ʈ"
			],
			[
				"StatusIn",
				"StatusInternalServerError\tuntyped int ·Ɩ"
			],
			[
				"net",
				"netConn\tnet.Conn ·ν"
			],
			[
				"enc",
				"encoding/base64\t ·ʂ"
			],
			[
				"Re",
				"RequestURI\tstring ·ν"
			],
			[
				"Respn",
				"ResponseWriter\tinterface ·ʈ"
			],
			[
				"Ha",
				"Handler\tinterface ·ʈ"
			],
			[
				"L",
				"GetLabel\tfunc() string ·ƒ"
			],
			[
				"test",
				"test_pb.js"
			],
			[
				"react",
				"react-quill/"
			],
			[
				"el",
				"element-ui/"
			],
			[
				"rel",
				"icedesign-qrcode.rel.js"
			],
			[
				"get",
				"getCroppedCanvas\twarning"
			],
			[
				"cl",
				"className"
			],
			[
				"hex",
				"hex2decimal"
			],
			[
				"flex",
				"flex-wrap\tproperty"
			],
			[
				"in",
				"MarshalIndent\tfunc(v interface{}, prefix string, indent string) []byte, error ·ƒ"
			],
			[
				"io",
				"io/ioutil\t ·ʂ"
			],
			[
				"re",
				"ReadDir\tfunc(dirname string) []os.FileInfo, error ·ƒ"
			],
			[
				"init",
				"initQueue"
			],
			[
				"thread",
				"threadID"
			],
			[
				"exit",
				"exitFlag"
			],
			[
				"content",
				"content_length"
			],
			[
				"name",
				"nameKey"
			],
			[
				"work",
				"workQueue"
			],
			[
				"en",
				"enqueue"
			],
			[
				"none",
				"None"
			],
			[
				"Mo",
				"ModeExclusive\tos.FileMode ·Ɩ"
			],
			[
				"encod",
				"encoding/json\t ·ʂ"
			],
			[
				"Cmd",
				"Command\tfunc(name string, arg ...string) *exec.Cmd ·ƒ"
			],
			[
				"next",
				"next.min.js"
			]
		]
	},
	"buffers":
	[
		{
			"file": "tsconfig.json",
			"settings":
			{
				"buffer_size": 6184,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "demo/gpu.ts",
			"settings":
			{
				"buffer_size": 1209,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.\n\n/// <reference no-default-lib=\"true\" />\n/// <reference lib=\"esnext\" />\n\n/** Deno provides extra properties on `import.meta`.  These are included here\n * to ensure that these are still available when using the Deno namespace in\n * conjunction with other type libs, like `dom`. */\ndeclare interface ImportMeta {\n  /** A string representation of the fully qualified module URL. */\n  url: string;\n\n  /** A flag that indicates if the current module is the main module that was\n   * called when starting the program under Deno.\n   *\n   * ```ts\n   * if (import.meta.main) {\n   *   // this was loaded as the main module, maybe do some bootstrapping\n   * }\n   * ```\n   */\n  main: boolean;\n}\n\n/** Deno supports user timing Level 3 (see: https://w3c.github.io/user-timing)\n * which is not widely supported yet in other runtimes.  These types are here\n * so that these features are still available when using the Deno namespace\n * in conjunction with other type libs, like `dom`. */\ndeclare interface Performance {\n  /** Stores a timestamp with the associated name (a \"mark\"). */\n  mark(markName: string, options?: PerformanceMarkOptions): PerformanceMark;\n\n  /** Stores the `DOMHighResTimeStamp` duration between two marks along with the\n   * associated name (a \"measure\"). */\n  measure(\n    measureName: string,\n    options?: PerformanceMeasureOptions,\n  ): PerformanceMeasure;\n}\n\ndeclare interface PerformanceMarkOptions {\n  /** Metadata to be included in the mark. */\n  // deno-lint-ignore no-explicit-any\n  detail?: any;\n\n  /** Timestamp to be used as the mark time. */\n  startTime?: number;\n}\n\ndeclare interface PerformanceMeasureOptions {\n  /** Metadata to be included in the measure. */\n  // deno-lint-ignore no-explicit-any\n  detail?: any;\n\n  /** Timestamp to be used as the start time or string to be used as start\n   * mark.*/\n  start?: string | number;\n\n  /** Duration between the start and end times. */\n  duration?: number;\n\n  /** Timestamp to be used as the end time or string to be used as end mark. */\n  end?: string | number;\n}\n\ndeclare namespace Deno {\n  /** A set of error constructors that are raised by Deno APIs. */\n  export const errors: {\n    NotFound: ErrorConstructor;\n    PermissionDenied: ErrorConstructor;\n    ConnectionRefused: ErrorConstructor;\n    ConnectionReset: ErrorConstructor;\n    ConnectionAborted: ErrorConstructor;\n    NotConnected: ErrorConstructor;\n    AddrInUse: ErrorConstructor;\n    AddrNotAvailable: ErrorConstructor;\n    BrokenPipe: ErrorConstructor;\n    AlreadyExists: ErrorConstructor;\n    InvalidData: ErrorConstructor;\n    TimedOut: ErrorConstructor;\n    Interrupted: ErrorConstructor;\n    WriteZero: ErrorConstructor;\n    UnexpectedEof: ErrorConstructor;\n    BadResource: ErrorConstructor;\n    Http: ErrorConstructor;\n    Busy: ErrorConstructor;\n  };\n\n  /** The current process id of the runtime. */\n  export const pid: number;\n\n  /** Reflects the `NO_COLOR` environment variable.\n   *\n   * See: https://no-color.org/ */\n  export const noColor: boolean;\n\n  export interface TestDefinition {\n    fn: () => void | Promise<void>;\n    name: string;\n    ignore?: boolean;\n    /** If at lease one test has `only` set to true, only run tests that have\n     * `only` set to true and fail the test suite. */\n    only?: boolean;\n    /** Check that the number of async completed ops after the test is the same\n     * as number of dispatched ops. Defaults to true.*/\n    sanitizeOps?: boolean;\n    /** Ensure the test case does not \"leak\" resources - ie. the resource table\n     * after the test has exactly the same contents as before the test. Defaults\n     * to true. */\n    sanitizeResources?: boolean;\n\n    /** Ensure the test case does not prematurely cause the process to exit,\n     * for example via a call to `Deno.exit`. Defaults to true. */\n    sanitizeExit?: boolean;\n  }\n\n  /** Register a test which will be run when `deno test` is used on the command\n   * line and the containing module looks like a test module.\n   * `fn` can be async if required.\n   * ```ts\n   * import {assert, fail, assertEquals} from \"https://deno.land/std/testing/asserts.ts\";\n   *\n   * Deno.test({\n   *   name: \"example test\",\n   *   fn(): void {\n   *     assertEquals(\"world\", \"world\");\n   *   },\n   * });\n   *\n   * Deno.test({\n   *   name: \"example ignored test\",\n   *   ignore: Deno.build.os === \"windows\",\n   *   fn(): void {\n   *     // This test is ignored only on Windows machines\n   *   },\n   * });\n   *\n   * Deno.test({\n   *   name: \"example async test\",\n   *   async fn() {\n   *     const decoder = new TextDecoder(\"utf-8\");\n   *     const data = await Deno.readFile(\"hello_world.txt\");\n   *     assertEquals(decoder.decode(data), \"Hello world\");\n   *   }\n   * });\n   * ```\n   */\n  export function test(t: TestDefinition): void;\n\n  /** Register a test which will be run when `deno test` is used on the command\n   * line and the containing module looks like a test module.\n   * `fn` can be async if required.\n   *\n   * ```ts\n   * import {assert, fail, assertEquals} from \"https://deno.land/std/testing/asserts.ts\";\n   *\n   * Deno.test(\"My test description\", ():void => {\n   *   assertEquals(\"hello\", \"hello\");\n   * });\n   *\n   * Deno.test(\"My async test description\", async ():Promise<void> => {\n   *   const decoder = new TextDecoder(\"utf-8\");\n   *   const data = await Deno.readFile(\"hello_world.txt\");\n   *   assertEquals(decoder.decode(data), \"Hello world\");\n   * });\n   * ```\n   * */\n  export function test(name: string, fn: () => void | Promise<void>): void;\n\n  /** Exit the Deno process with optional exit code. If no exit code is supplied\n   * then Deno will exit with return code of 0.\n   *\n   * ```ts\n   * Deno.exit(5);\n   * ```\n   */\n  export function exit(code?: number): never;\n\n  export const env: {\n    /** Retrieve the value of an environment variable. Returns undefined if that\n     * key doesn't exist.\n     *\n     * ```ts\n     * console.log(Deno.env.get(\"HOME\"));  // e.g. outputs \"/home/alice\"\n     * console.log(Deno.env.get(\"MADE_UP_VAR\"));  // outputs \"Undefined\"\n     * ```\n     * Requires `allow-env` permission. */\n    get(key: string): string | undefined;\n\n    /** Set the value of an environment variable.\n     *\n     * ```ts\n     * Deno.env.set(\"SOME_VAR\", \"Value\"));\n     * Deno.env.get(\"SOME_VAR\");  // outputs \"Value\"\n     * ```\n     *\n     * Requires `allow-env` permission. */\n    set(key: string, value: string): void;\n\n    /** Delete the value of an environment variable.\n     *\n     * ```ts\n     * Deno.env.set(\"SOME_VAR\", \"Value\"));\n     * Deno.env.delete(\"SOME_VAR\");  // outputs \"Undefined\"\n     * ```\n     *\n     * Requires `allow-env` permission. */\n    delete(key: string): void;\n\n    /** Returns a snapshot of the environment variables at invocation.\n     *\n     * ```ts\n     * Deno.env.set(\"TEST_VAR\", \"A\");\n     * const myEnv = Deno.env.toObject();\n     * console.log(myEnv.SHELL);\n     * Deno.env.set(\"TEST_VAR\", \"B\");\n     * console.log(myEnv.TEST_VAR);  // outputs \"A\"\n     * ```\n     *\n     * Requires `allow-env` permission. */\n    toObject(): { [index: string]: string };\n  };\n\n  /**\n   * Returns the path to the current deno executable.\n   *\n   * ```ts\n   * console.log(Deno.execPath());  // e.g. \"/home/alice/.local/bin/deno\"\n   * ```\n   *\n   * Requires `allow-read` permission.\n   */\n  export function execPath(): string;\n\n  /**\n   * Change the current working directory to the specified path.\n   *\n   * ```ts\n   * Deno.chdir(\"/home/userA\");\n   * Deno.chdir(\"../userB\");\n   * Deno.chdir(\"C:\\\\Program Files (x86)\\\\Java\");\n   * ```\n   *\n   * Throws `Deno.errors.NotFound` if directory not found.\n   * Throws `Deno.errors.PermissionDenied` if the user does not have access\n   * rights\n   *\n   * Requires --allow-read.\n   */\n  export function chdir(directory: string): void;\n\n  /**\n   * Return a string representing the current working directory.\n   *\n   * If the current directory can be reached via multiple paths (due to symbolic\n   * links), `cwd()` may return any one of them.\n   *\n   * ```ts\n   * const currentWorkingDirectory = Deno.cwd();\n   * ```\n   *\n   * Throws `Deno.errors.NotFound` if directory not available.\n   *\n   * Requires --allow-read\n   */\n  export function cwd(): string;\n\n  /**\n   * Synchronously creates `newpath` as a hard link to `oldpath`.\n   *\n   * ```ts\n   * Deno.linkSync(\"old/name\", \"new/name\");\n   * ```\n   *\n   * Requires `allow-read` and `allow-write` permissions. */\n  export function linkSync(oldpath: string, newpath: string): void;\n\n  /**\n   *\n   * Creates `newpath` as a hard link to `oldpath`.\n   *\n   * ```ts\n   * await Deno.link(\"old/name\", \"new/name\");\n   * ```\n   *\n   * Requires `allow-read` and `allow-write` permissions. */\n  export function link(oldpath: string, newpath: string): Promise<void>;\n\n  export enum SeekMode {\n    Start = 0,\n    Current = 1,\n    End = 2,\n  }\n\n  export interface Reader {\n    /** Reads up to `p.byteLength` bytes into `p`. It resolves to the number of\n     * bytes read (`0` < `n` <= `p.byteLength`) and rejects if any error\n     * encountered. Even if `read()` resolves to `n` < `p.byteLength`, it may\n     * use all of `p` as scratch space during the call. If some data is\n     * available but not `p.byteLength` bytes, `read()` conventionally resolves\n     * to what is available instead of waiting for more.\n     *\n     * When `read()` encounters end-of-file condition, it resolves to EOF\n     * (`null`).\n     *\n     * When `read()` encounters an error, it rejects with an error.\n     *\n     * Callers should always process the `n` > `0` bytes returned before\n     * considering the EOF (`null`). Doing so correctly handles I/O errors that\n     * happen after reading some bytes and also both of the allowed EOF\n     * behaviors.\n     *\n     * Implementations should not retain a reference to `p`.\n     *\n     * Use Deno.iter() to turn a Reader into an AsyncIterator.\n     */\n    read(p: Uint8Array): Promise<number | null>;\n  }\n\n  export interface ReaderSync {\n    /** Reads up to `p.byteLength` bytes into `p`. It resolves to the number\n     * of bytes read (`0` < `n` <= `p.byteLength`) and rejects if any error\n     * encountered. Even if `read()` returns `n` < `p.byteLength`, it may use\n     * all of `p` as scratch space during the call. If some data is available\n     * but not `p.byteLength` bytes, `read()` conventionally returns what is\n     * available instead of waiting for more.\n     *\n     * When `readSync()` encounters end-of-file condition, it returns EOF\n     * (`null`).\n     *\n     * When `readSync()` encounters an error, it throws with an error.\n     *\n     * Callers should always process the `n` > `0` bytes returned before\n     * considering the EOF (`null`). Doing so correctly handles I/O errors that happen\n     * after reading some bytes and also both of the allowed EOF behaviors.\n     *\n     * Implementations should not retain a reference to `p`.\n     *\n     * Use Deno.iterSync() to turn a ReaderSync into an Iterator.\n     */\n    readSync(p: Uint8Array): number | null;\n  }\n\n  export interface Writer {\n    /** Writes `p.byteLength` bytes from `p` to the underlying data stream. It\n     * resolves to the number of bytes written from `p` (`0` <= `n` <=\n     * `p.byteLength`) or reject with the error encountered that caused the\n     * write to stop early. `write()` must reject with a non-null error if\n     * would resolve to `n` < `p.byteLength`. `write()` must not modify the\n     * slice data, even temporarily.\n     *\n     * Implementations should not retain a reference to `p`.\n     */\n    write(p: Uint8Array): Promise<number>;\n  }\n\n  export interface WriterSync {\n    /** Writes `p.byteLength` bytes from `p` to the underlying data\n     * stream. It returns the number of bytes written from `p` (`0` <= `n`\n     * <= `p.byteLength`) and any error encountered that caused the write to\n     * stop early. `writeSync()` must throw a non-null error if it returns `n` <\n     * `p.byteLength`. `writeSync()` must not modify the slice data, even\n     * temporarily.\n     *\n     * Implementations should not retain a reference to `p`.\n     */\n    writeSync(p: Uint8Array): number;\n  }\n\n  export interface Closer {\n    close(): void;\n  }\n\n  export interface Seeker {\n    /** Seek sets the offset for the next `read()` or `write()` to offset,\n     * interpreted according to `whence`: `Start` means relative to the\n     * start of the file, `Current` means relative to the current offset,\n     * and `End` means relative to the end. Seek resolves to the new offset\n     * relative to the start of the file.\n     *\n     * Seeking to an offset before the start of the file is an error. Seeking to\n     * any positive offset is legal, but the behavior of subsequent I/O\n     * operations on the underlying object is implementation-dependent.\n     * It returns the number of cursor position.\n     */\n    seek(offset: number, whence: SeekMode): Promise<number>;\n  }\n\n  export interface SeekerSync {\n    /** Seek sets the offset for the next `readSync()` or `writeSync()` to\n     * offset, interpreted according to `whence`: `Start` means relative\n     * to the start of the file, `Current` means relative to the current\n     * offset, and `End` means relative to the end.\n     *\n     * Seeking to an offset before the start of the file is an error. Seeking to\n     * any positive offset is legal, but the behavior of subsequent I/O\n     * operations on the underlying object is implementation-dependent.\n     */\n    seekSync(offset: number, whence: SeekMode): number;\n  }\n\n  /** Copies from `src` to `dst` until either EOF (`null`) is read from `src` or\n   * an error occurs. It resolves to the number of bytes copied or rejects with\n   * the first error encountered while copying.\n   *\n   * ```ts\n   * const source = await Deno.open(\"my_file.txt\");\n   * const buffer = new Deno.Buffer()\n   * const bytesCopied1 = await Deno.copy(source, Deno.stdout);\n   * const bytesCopied2 = await Deno.copy(source, buffer);\n   * ```\n   *\n   * @param src The source to copy from\n   * @param dst The destination to copy to\n   * @param options Can be used to tune size of the buffer. Default size is 32kB\n   */\n  export function copy(\n    src: Reader,\n    dst: Writer,\n    options?: {\n      bufSize?: number;\n    },\n  ): Promise<number>;\n\n  /** Turns a Reader, `r`, into an async iterator.\n   *\n   * ```ts\n   * let f = await Deno.open(\"/etc/passwd\");\n   * for await (const chunk of Deno.iter(f)) {\n   *   console.log(chunk);\n   * }\n   * f.close();\n   * ```\n   *\n   * Second argument can be used to tune size of a buffer.\n   * Default size of the buffer is 32kB.\n   *\n   * ```ts\n   * let f = await Deno.open(\"/etc/passwd\");\n   * const iter = Deno.iter(f, {\n   *   bufSize: 1024 * 1024\n   * });\n   * for await (const chunk of iter) {\n   *   console.log(chunk);\n   * }\n   * f.close();\n   * ```\n   *\n   * Iterator uses an internal buffer of fixed size for efficiency; it returns\n   * a view on that buffer on each iteration. It is therefore caller's\n   * responsibility to copy contents of the buffer if needed; otherwise the\n   * next iteration will overwrite contents of previously returned chunk.\n   */\n  export function iter(\n    r: Reader,\n    options?: {\n      bufSize?: number;\n    },\n  ): AsyncIterableIterator<Uint8Array>;\n\n  /** Turns a ReaderSync, `r`, into an iterator.\n   *\n   * ```ts\n   * let f = Deno.openSync(\"/etc/passwd\");\n   * for (const chunk of Deno.iterSync(f)) {\n   *   console.log(chunk);\n   * }\n   * f.close();\n   * ```\n   *\n   * Second argument can be used to tune size of a buffer.\n   * Default size of the buffer is 32kB.\n   *\n   * ```ts\n   * let f = await Deno.open(\"/etc/passwd\");\n   * const iter = Deno.iterSync(f, {\n   *   bufSize: 1024 * 1024\n   * });\n   * for (const chunk of iter) {\n   *   console.log(chunk);\n   * }\n   * f.close();\n   * ```\n   *\n   * Iterator uses an internal buffer of fixed size for efficiency; it returns\n   * a view on that buffer on each iteration. It is therefore caller's\n   * responsibility to copy contents of the buffer if needed; otherwise the\n   * next iteration will overwrite contents of previously returned chunk.\n   */\n  export function iterSync(\n    r: ReaderSync,\n    options?: {\n      bufSize?: number;\n    },\n  ): IterableIterator<Uint8Array>;\n\n  /** Synchronously open a file and return an instance of `Deno.File`.  The\n   * file does not need to previously exist if using the `create` or `createNew`\n   * open options.  It is the callers responsibility to close the file when finished\n   * with it.\n   *\n   * ```ts\n   * const file = Deno.openSync(\"/foo/bar.txt\", { read: true, write: true });\n   * // Do work with file\n   * Deno.close(file.rid);\n   * ```\n   *\n   * Requires `allow-read` and/or `allow-write` permissions depending on options.\n   */\n  export function openSync(path: string | URL, options?: OpenOptions): File;\n\n  /** Open a file and resolve to an instance of `Deno.File`.  The\n   * file does not need to previously exist if using the `create` or `createNew`\n   * open options.  It is the callers responsibility to close the file when finished\n   * with it.\n   *\n   * ```ts\n   * const file = await Deno.open(\"/foo/bar.txt\", { read: true, write: true });\n   * // Do work with file\n   * Deno.close(file.rid);\n   * ```\n   *\n   * Requires `allow-read` and/or `allow-write` permissions depending on options.\n   */\n  export function open(\n    path: string | URL,\n    options?: OpenOptions,\n  ): Promise<File>;\n\n  /** Creates a file if none exists or truncates an existing file and returns\n   *  an instance of `Deno.File`.\n   *\n   * ```ts\n   * const file = Deno.createSync(\"/foo/bar.txt\");\n   * ```\n   *\n   * Requires `allow-read` and `allow-write` permissions.\n   */\n  export function createSync(path: string | URL): File;\n\n  /** Creates a file if none exists or truncates an existing file and resolves to\n   *  an instance of `Deno.File`.\n   *\n   * ```ts\n   * const file = await Deno.create(\"/foo/bar.txt\");\n   * ```\n   *\n   * Requires `allow-read` and `allow-write` permissions.\n   */\n  export function create(path: string | URL): Promise<File>;\n\n  /** Synchronously read from a resource ID (`rid`) into an array buffer (`buffer`).\n   *\n   * Returns either the number of bytes read during the operation or EOF\n   * (`null`) if there was nothing more to read.\n   *\n   * It is possible for a read to successfully return with `0` bytes. This does\n   * not indicate EOF.\n   *\n   * This function is one of the lowest level APIs and most users should not\n   * work with this directly, but rather use Deno.readAllSync() instead.\n   *\n   * **It is not guaranteed that the full buffer will be read in a single call.**\n   *\n   * ```ts\n   * // if \"/foo/bar.txt\" contains the text \"hello world\":\n   * const file = Deno.openSync(\"/foo/bar.txt\");\n   * const buf = new Uint8Array(100);\n   * const numberOfBytesRead = Deno.readSync(file.rid, buf); // 11 bytes\n   * const text = new TextDecoder().decode(buf);  // \"hello world\"\n   * Deno.close(file.rid);\n   * ```\n   */\n  export function readSync(rid: number, buffer: Uint8Array): number | null;\n\n  /** Read from a resource ID (`rid`) into an array buffer (`buffer`).\n   *\n   * Resolves to either the number of bytes read during the operation or EOF\n   * (`null`) if there was nothing more to read.\n   *\n   * It is possible for a read to successfully return with `0` bytes. This does\n   * not indicate EOF.\n   *\n   * This function is one of the lowest level APIs and most users should not\n   * work with this directly, but rather use Deno.readAll() instead.\n   *\n   * **It is not guaranteed that the full buffer will be read in a single call.**\n   *\n   * ```ts\n   * // if \"/foo/bar.txt\" contains the text \"hello world\":\n   * const file = await Deno.open(\"/foo/bar.txt\");\n   * const buf = new Uint8Array(100);\n   * const numberOfBytesRead = await Deno.read(file.rid, buf); // 11 bytes\n   * const text = new TextDecoder().decode(buf);  // \"hello world\"\n   * Deno.close(file.rid);\n   * ```\n   */\n  export function read(rid: number, buffer: Uint8Array): Promise<number | null>;\n\n  /** Synchronously write to the resource ID (`rid`) the contents of the array\n   * buffer (`data`).\n   *\n   * Returns the number of bytes written.  This function is one of the lowest\n   * level APIs and most users should not work with this directly, but rather use\n   * Deno.writeAllSync() instead.\n   *\n   * **It is not guaranteed that the full buffer will be written in a single\n   * call.**\n   *\n   * ```ts\n   * const encoder = new TextEncoder();\n   * const data = encoder.encode(\"Hello world\");\n   * const file = Deno.openSync(\"/foo/bar.txt\", {write: true});\n   * const bytesWritten = Deno.writeSync(file.rid, data); // 11\n   * Deno.close(file.rid);\n   * ```\n   */\n  export function writeSync(rid: number, data: Uint8Array): number;\n\n  /** Write to the resource ID (`rid`) the contents of the array buffer (`data`).\n   *\n   * Resolves to the number of bytes written.  This function is one of the lowest\n   * level APIs and most users should not work with this directly, but rather use\n   * Deno.writeAll() instead.\n   *\n   * **It is not guaranteed that the full buffer will be written in a single\n   * call.**\n   *\n   * ```ts\n   * const encoder = new TextEncoder();\n   * const data = encoder.encode(\"Hello world\");\n   * const file = await Deno.open(\"/foo/bar.txt\", { write: true });\n   * const bytesWritten = await Deno.write(file.rid, data); // 11\n   * Deno.close(file.rid);\n   * ```\n   */\n  export function write(rid: number, data: Uint8Array): Promise<number>;\n\n  /** Synchronously seek a resource ID (`rid`) to the given `offset` under mode\n   * given by `whence`.  The new position within the resource (bytes from the\n   * start) is returned.\n   *\n   * ```ts\n   * const file = Deno.openSync('hello.txt', {read: true, write: true, truncate: true, create: true});\n   * Deno.writeSync(file.rid, new TextEncoder().encode(\"Hello world\"));\n   * // advance cursor 6 bytes\n   * const cursorPosition = Deno.seekSync(file.rid, 6, Deno.SeekMode.Start);\n   * console.log(cursorPosition);  // 6\n   * const buf = new Uint8Array(100);\n   * file.readSync(buf);\n   * console.log(new TextDecoder().decode(buf)); // \"world\"\n   * ```\n   *\n   * The seek modes work as follows:\n   *\n   * ```ts\n   * // Given file.rid pointing to file with \"Hello world\", which is 11 bytes long:\n   * // Seek 6 bytes from the start of the file\n   * console.log(Deno.seekSync(file.rid, 6, Deno.SeekMode.Start)); // \"6\"\n   * // Seek 2 more bytes from the current position\n   * console.log(Deno.seekSync(file.rid, 2, Deno.SeekMode.Current)); // \"8\"\n   * // Seek backwards 2 bytes from the end of the file\n   * console.log(Deno.seekSync(file.rid, -2, Deno.SeekMode.End)); // \"9\" (e.g. 11-2)\n   * ```\n   */\n  export function seekSync(\n    rid: number,\n    offset: number,\n    whence: SeekMode,\n  ): number;\n\n  /** Seek a resource ID (`rid`) to the given `offset` under mode given by `whence`.\n   * The call resolves to the new position within the resource (bytes from the start).\n   *\n   * ```ts\n   * const file = await Deno.open('hello.txt', {read: true, write: true, truncate: true, create: true});\n   * await Deno.write(file.rid, new TextEncoder().encode(\"Hello world\"));\n   * // advance cursor 6 bytes\n   * const cursorPosition = await Deno.seek(file.rid, 6, Deno.SeekMode.Start);\n   * console.log(cursorPosition);  // 6\n   * const buf = new Uint8Array(100);\n   * await file.read(buf);\n   * console.log(new TextDecoder().decode(buf)); // \"world\"\n   * ```\n   *\n   * The seek modes work as follows:\n   *\n   * ```ts\n   * // Given file.rid pointing to file with \"Hello world\", which is 11 bytes long:\n   * // Seek 6 bytes from the start of the file\n   * console.log(await Deno.seek(file.rid, 6, Deno.SeekMode.Start)); // \"6\"\n   * // Seek 2 more bytes from the current position\n   * console.log(await Deno.seek(file.rid, 2, Deno.SeekMode.Current)); // \"8\"\n   * // Seek backwards 2 bytes from the end of the file\n   * console.log(await Deno.seek(file.rid, -2, Deno.SeekMode.End)); // \"9\" (e.g. 11-2)\n   * ```\n   */\n  export function seek(\n    rid: number,\n    offset: number,\n    whence: SeekMode,\n  ): Promise<number>;\n\n  /**\n   * Synchronously flushes any pending data and metadata operations of the given file stream to disk.\n   *  ```ts\n   * const file = Deno.openSync(\"my_file.txt\", { read: true, write: true, create: true });\n   * Deno.writeSync(file.rid, new TextEncoder().encode(\"Hello World\"));\n   * Deno.ftruncateSync(file.rid, 1);\n   * Deno.fsyncSync(file.rid);\n   * console.log(new TextDecoder().decode(Deno.readFileSync(\"my_file.txt\"))); // H\n   * ```\n   */\n  export function fsyncSync(rid: number): void;\n\n  /**\n   * Flushes any pending data and metadata operations of the given file stream to disk.\n   *  ```ts\n   * const file = await Deno.open(\"my_file.txt\", { read: true, write: true, create: true });\n   * await Deno.write(file.rid, new TextEncoder().encode(\"Hello World\"));\n   * await Deno.ftruncate(file.rid, 1);\n   * await Deno.fsync(file.rid);\n   * console.log(new TextDecoder().decode(await Deno.readFile(\"my_file.txt\"))); // H\n   * ```\n   */\n  export function fsync(rid: number): Promise<void>;\n\n  /*\n   * Synchronously flushes any pending data operations of the given file stream to disk.\n   *  ```ts\n   * const file = Deno.openSync(\"my_file.txt\", { read: true, write: true, create: true });\n   * Deno.writeSync(file.rid, new TextEncoder().encode(\"Hello World\"));\n   * Deno.fdatasyncSync(file.rid);\n   * console.log(new TextDecoder().decode(Deno.readFileSync(\"my_file.txt\"))); // Hello World\n   * ```\n   */\n  export function fdatasyncSync(rid: number): void;\n\n  /**\n   * Flushes any pending data operations of the given file stream to disk.\n   *  ```ts\n   * const file = await Deno.open(\"my_file.txt\", { read: true, write: true, create: true });\n   * await Deno.write(file.rid, new TextEncoder().encode(\"Hello World\"));\n   * await Deno.fdatasync(file.rid);\n   * console.log(new TextDecoder().decode(await Deno.readFile(\"my_file.txt\"))); // Hello World\n   * ```\n   */\n  export function fdatasync(rid: number): Promise<void>;\n\n  /** Close the given resource ID (rid) which has been previously opened, such\n   * as via opening or creating a file.  Closing a file when you are finished\n   * with it is important to avoid leaking resources.\n   *\n   * ```ts\n   * const file = await Deno.open(\"my_file.txt\");\n   * // do work with \"file\" object\n   * Deno.close(file.rid);\n   * ````\n   */\n  export function close(rid: number): void;\n\n  /** The Deno abstraction for reading and writing files. */\n  export class File\n    implements\n      Reader,\n      ReaderSync,\n      Writer,\n      WriterSync,\n      Seeker,\n      SeekerSync,\n      Closer {\n    readonly rid: number;\n    constructor(rid: number);\n    write(p: Uint8Array): Promise<number>;\n    writeSync(p: Uint8Array): number;\n    read(p: Uint8Array): Promise<number | null>;\n    readSync(p: Uint8Array): number | null;\n    seek(offset: number, whence: SeekMode): Promise<number>;\n    seekSync(offset: number, whence: SeekMode): number;\n    close(): void;\n  }\n\n  /** A handle for `stdin`. */\n  export const stdin: Reader & ReaderSync & Closer & { readonly rid: number };\n  /** A handle for `stdout`. */\n  export const stdout: Writer & WriterSync & Closer & { readonly rid: number };\n  /** A handle for `stderr`. */\n  export const stderr: Writer & WriterSync & Closer & { readonly rid: number };\n\n  export interface OpenOptions {\n    /** Sets the option for read access. This option, when `true`, means that the\n     * file should be read-able if opened. */\n    read?: boolean;\n    /** Sets the option for write access. This option, when `true`, means that\n     * the file should be write-able if opened. If the file already exists,\n     * any write calls on it will overwrite its contents, by default without\n     * truncating it. */\n    write?: boolean;\n    /**Sets the option for the append mode. This option, when `true`, means that\n     * writes will append to a file instead of overwriting previous contents.\n     * Note that setting `{ write: true, append: true }` has the same effect as\n     * setting only `{ append: true }`. */\n    append?: boolean;\n    /** Sets the option for truncating a previous file. If a file is\n     * successfully opened with this option set it will truncate the file to `0`\n     * size if it already exists. The file must be opened with write access\n     * for truncate to work. */\n    truncate?: boolean;\n    /** Sets the option to allow creating a new file, if one doesn't already\n     * exist at the specified path. Requires write or append access to be\n     * used. */\n    create?: boolean;\n    /** Defaults to `false`. If set to `true`, no file, directory, or symlink is\n     * allowed to exist at the target location. Requires write or append\n     * access to be used. When createNew is set to `true`, create and truncate\n     * are ignored. */\n    createNew?: boolean;\n    /** Permissions to use if creating the file (defaults to `0o666`, before\n     * the process's umask).\n     * Ignored on Windows. */\n    mode?: number;\n  }\n\n  /**\n   *\n   *  Check if a given resource id (`rid`) is a TTY.\n   *\n   * ```ts\n   * // This example is system and context specific\n   * const nonTTYRid = Deno.openSync(\"my_file.txt\").rid;\n   * const ttyRid = Deno.openSync(\"/dev/tty6\").rid;\n   * console.log(Deno.isatty(nonTTYRid)); // false\n   * console.log(Deno.isatty(ttyRid)); // true\n   * Deno.close(nonTTYRid);\n   * Deno.close(ttyRid);\n   * ```\n   */\n  export function isatty(rid: number): boolean;\n\n  /** A variable-sized buffer of bytes with `read()` and `write()` methods.\n   *\n   * Deno.Buffer is almost always used with some I/O like files and sockets. It\n   * allows one to buffer up a download from a socket. Buffer grows and shrinks\n   * as necessary.\n   *\n   * Deno.Buffer is NOT the same thing as Node's Buffer. Node's Buffer was\n   * created in 2009 before JavaScript had the concept of ArrayBuffers. It's\n   * simply a non-standard ArrayBuffer.\n   *\n   * ArrayBuffer is a fixed memory allocation. Deno.Buffer is implemented on top\n   * of ArrayBuffer.\n   *\n   * Based on [Go Buffer](https://golang.org/pkg/bytes/#Buffer). */\n  export class Buffer implements Reader, ReaderSync, Writer, WriterSync {\n    constructor(ab?: ArrayBuffer);\n    /** Returns a slice holding the unread portion of the buffer.\n     *\n     * The slice is valid for use only until the next buffer modification (that\n     * is, only until the next call to a method like `read()`, `write()`,\n     * `reset()`, or `truncate()`). If `options.copy` is false the slice aliases the buffer content at\n     * least until the next buffer modification, so immediate changes to the\n     * slice will affect the result of future reads.\n     * @param options Defaults to `{ copy: true }`\n     */\n    bytes(options?: { copy?: boolean }): Uint8Array;\n    /** Returns whether the unread portion of the buffer is empty. */\n    empty(): boolean;\n    /** A read only number of bytes of the unread portion of the buffer. */\n    readonly length: number;\n    /** The read only capacity of the buffer's underlying byte slice, that is,\n     * the total space allocated for the buffer's data. */\n    readonly capacity: number;\n    /** Discards all but the first `n` unread bytes from the buffer but\n     * continues to use the same allocated storage. It throws if `n` is\n     * negative or greater than the length of the buffer. */\n    truncate(n: number): void;\n    /** Resets the buffer to be empty, but it retains the underlying storage for\n     * use by future writes. `.reset()` is the same as `.truncate(0)`. */\n    reset(): void;\n    /** Reads the next `p.length` bytes from the buffer or until the buffer is\n     * drained. Returns the number of bytes read. If the buffer has no data to\n     * return, the return is EOF (`null`). */\n    readSync(p: Uint8Array): number | null;\n    /** Reads the next `p.length` bytes from the buffer or until the buffer is\n     * drained. Resolves to the number of bytes read. If the buffer has no\n     * data to return, resolves to EOF (`null`).\n     *\n     * NOTE: This methods reads bytes synchronously; it's provided for\n     * compatibility with `Reader` interfaces.\n     */\n    read(p: Uint8Array): Promise<number | null>;\n    writeSync(p: Uint8Array): number;\n    /** NOTE: This methods writes bytes synchronously; it's provided for\n     * compatibility with `Writer` interface. */\n    write(p: Uint8Array): Promise<number>;\n    /** Grows the buffer's capacity, if necessary, to guarantee space for\n     * another `n` bytes. After `.grow(n)`, at least `n` bytes can be written to\n     * the buffer without another allocation. If `n` is negative, `.grow()` will\n     * throw. If the buffer can't grow it will throw an error.\n     *\n     * Based on Go Lang's\n     * [Buffer.Grow](https://golang.org/pkg/bytes/#Buffer.Grow). */\n    grow(n: number): void;\n    /** Reads data from `r` until EOF (`null`) and appends it to the buffer,\n     * growing the buffer as needed. It resolves to the number of bytes read.\n     * If the buffer becomes too large, `.readFrom()` will reject with an error.\n     *\n     * Based on Go Lang's\n     * [Buffer.ReadFrom](https://golang.org/pkg/bytes/#Buffer.ReadFrom). */\n    readFrom(r: Reader): Promise<number>;\n    /** Reads data from `r` until EOF (`null`) and appends it to the buffer,\n     * growing the buffer as needed. It returns the number of bytes read. If the\n     * buffer becomes too large, `.readFromSync()` will throw an error.\n     *\n     * Based on Go Lang's\n     * [Buffer.ReadFrom](https://golang.org/pkg/bytes/#Buffer.ReadFrom). */\n    readFromSync(r: ReaderSync): number;\n  }\n\n  /** Read Reader `r` until EOF (`null`) and resolve to the content as\n   * Uint8Array`.\n   *\n   * ```ts\n   * // Example from stdin\n   * const stdinContent = await Deno.readAll(Deno.stdin);\n   *\n   * // Example from file\n   * const file = await Deno.open(\"my_file.txt\", {read: true});\n   * const myFileContent = await Deno.readAll(file);\n   * Deno.close(file.rid);\n   *\n   * // Example from buffer\n   * const myData = new Uint8Array(100);\n   * // ... fill myData array with data\n   * const reader = new Deno.Buffer(myData.buffer as ArrayBuffer);\n   * const bufferContent = await Deno.readAll(reader);\n   * ```\n   */\n  export function readAll(r: Reader): Promise<Uint8Array>;\n\n  /** Synchronously reads Reader `r` until EOF (`null`) and returns the content\n   * as `Uint8Array`.\n   *\n   * ```ts\n   * // Example from stdin\n   * const stdinContent = Deno.readAllSync(Deno.stdin);\n   *\n   * // Example from file\n   * const file = Deno.openSync(\"my_file.txt\", {read: true});\n   * const myFileContent = Deno.readAllSync(file);\n   * Deno.close(file.rid);\n   *\n   * // Example from buffer\n   * const myData = new Uint8Array(100);\n   * // ... fill myData array with data\n   * const reader = new Deno.Buffer(myData.buffer as ArrayBuffer);\n   * const bufferContent = Deno.readAllSync(reader);\n   * ```\n   */\n  export function readAllSync(r: ReaderSync): Uint8Array;\n\n  /** Write all the content of the array buffer (`arr`) to the writer (`w`).\n   *\n   * ```ts\n   * // Example writing to stdout\n   * const contentBytes = new TextEncoder().encode(\"Hello World\");\n   * await Deno.writeAll(Deno.stdout, contentBytes);\n   *\n   * // Example writing to file\n   * const contentBytes = new TextEncoder().encode(\"Hello World\");\n   * const file = await Deno.open('test.file', {write: true});\n   * await Deno.writeAll(file, contentBytes);\n   * Deno.close(file.rid);\n   *\n   * // Example writing to buffer\n   * const contentBytes = new TextEncoder().encode(\"Hello World\");\n   * const writer = new Deno.Buffer();\n   * await Deno.writeAll(writer, contentBytes);\n   * console.log(writer.bytes().length);  // 11\n   * ```\n   */\n  export function writeAll(w: Writer, arr: Uint8Array): Promise<void>;\n\n  /** Synchronously write all the content of the array buffer (`arr`) to the\n   * writer (`w`).\n   *\n   * ```ts\n   * // Example writing to stdout\n   * const contentBytes = new TextEncoder().encode(\"Hello World\");\n   * Deno.writeAllSync(Deno.stdout, contentBytes);\n   *\n   * // Example writing to file\n   * const contentBytes = new TextEncoder().encode(\"Hello World\");\n   * const file = Deno.openSync('test.file', {write: true});\n   * Deno.writeAllSync(file, contentBytes);\n   * Deno.close(file.rid);\n   *\n   * // Example writing to buffer\n   * const contentBytes = new TextEncoder().encode(\"Hello World\");\n   * const writer = new Deno.Buffer();\n   * Deno.writeAllSync(writer, contentBytes);\n   * console.log(writer.bytes().length);  // 11\n   * ```\n   */\n  export function writeAllSync(w: WriterSync, arr: Uint8Array): void;\n\n  export interface MkdirOptions {\n    /** Defaults to `false`. If set to `true`, means that any intermediate\n     * directories will also be created (as with the shell command `mkdir -p`).\n     * Intermediate directories are created with the same permissions.\n     * When recursive is set to `true`, succeeds silently (without changing any\n     * permissions) if a directory already exists at the path, or if the path\n     * is a symlink to an existing directory. */\n    recursive?: boolean;\n    /** Permissions to use when creating the directory (defaults to `0o777`,\n     * before the process's umask).\n     * Ignored on Windows. */\n    mode?: number;\n  }\n\n  /** Synchronously creates a new directory with the specified path.\n   *\n   * ```ts\n   * Deno.mkdirSync(\"new_dir\");\n   * Deno.mkdirSync(\"nested/directories\", { recursive: true });\n   * Deno.mkdirSync(\"restricted_access_dir\", { mode: 0o700 });\n   * ```\n   *\n   * Defaults to throwing error if the directory already exists.\n   *\n   * Requires `allow-write` permission. */\n  export function mkdirSync(path: string | URL, options?: MkdirOptions): void;\n\n  /** Creates a new directory with the specified path.\n   *\n   * ```ts\n   * await Deno.mkdir(\"new_dir\");\n   * await Deno.mkdir(\"nested/directories\", { recursive: true });\n   * await Deno.mkdir(\"restricted_access_dir\", { mode: 0o700 });\n   * ```\n   *\n   * Defaults to throwing error if the directory already exists.\n   *\n   * Requires `allow-write` permission. */\n  export function mkdir(\n    path: string | URL,\n    options?: MkdirOptions,\n  ): Promise<void>;\n\n  export interface MakeTempOptions {\n    /** Directory where the temporary directory should be created (defaults to\n     * the env variable TMPDIR, or the system's default, usually /tmp).\n     *\n     * Note that if the passed `dir` is relative, the path returned by\n     * makeTempFile() and makeTempDir() will also be relative. Be mindful of\n     * this when changing working directory. */\n    dir?: string;\n    /** String that should precede the random portion of the temporary\n     * directory's name. */\n    prefix?: string;\n    /** String that should follow the random portion of the temporary\n     * directory's name. */\n    suffix?: string;\n  }\n\n  /** Synchronously creates a new temporary directory in the default directory\n   * for temporary files, unless `dir` is specified. Other optional options\n   * include prefixing and suffixing the directory name with `prefix` and\n   * `suffix` respectively.\n   *\n   * The full path to the newly created directory is returned.\n   *\n   * Multiple programs calling this function simultaneously will create different\n   * directories. It is the caller's responsibility to remove the directory when\n   * no longer needed.\n   *\n   * ```ts\n   * const tempDirName0 = Deno.makeTempDirSync();  // e.g. /tmp/2894ea76\n   * const tempDirName1 = Deno.makeTempDirSync({ prefix: 'my_temp' });  // e.g. /tmp/my_temp339c944d\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  // TODO(ry) Doesn't check permissions.\n  export function makeTempDirSync(options?: MakeTempOptions): string;\n\n  /** Creates a new temporary directory in the default directory for temporary\n   * files, unless `dir` is specified. Other optional options include\n   * prefixing and suffixing the directory name with `prefix` and `suffix`\n   * respectively.\n   *\n   * This call resolves to the full path to the newly created directory.\n   *\n   * Multiple programs calling this function simultaneously will create different\n   * directories. It is the caller's responsibility to remove the directory when\n   * no longer needed.\n   *\n   * ```ts\n   * const tempDirName0 = await Deno.makeTempDir();  // e.g. /tmp/2894ea76\n   * const tempDirName1 = await Deno.makeTempDir({ prefix: 'my_temp' }); // e.g. /tmp/my_temp339c944d\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  // TODO(ry) Doesn't check permissions.\n  export function makeTempDir(options?: MakeTempOptions): Promise<string>;\n\n  /** Synchronously creates a new temporary file in the default directory for\n   * temporary files, unless `dir` is specified.\n   * Other optional options include prefixing and suffixing the directory name\n   * with `prefix` and `suffix` respectively.\n   *\n   * The full path to the newly created file is returned.\n   *\n   * Multiple programs calling this function simultaneously will create different\n   * files. It is the caller's responsibility to remove the file when no longer\n   * needed.\n   *\n   * ```ts\n   * const tempFileName0 = Deno.makeTempFileSync(); // e.g. /tmp/419e0bf2\n   * const tempFileName1 = Deno.makeTempFileSync({ prefix: 'my_temp' });  // e.g. /tmp/my_temp754d3098\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  export function makeTempFileSync(options?: MakeTempOptions): string;\n\n  /** Creates a new temporary file in the default directory for temporary\n   * files, unless `dir` is specified.  Other\n   * optional options include prefixing and suffixing the directory name with\n   * `prefix` and `suffix` respectively.\n   *\n   * This call resolves to the full path to the newly created file.\n   *\n   * Multiple programs calling this function simultaneously will create different\n   * files. It is the caller's responsibility to remove the file when no longer\n   * needed.\n   *\n   * ```ts\n   * const tmpFileName0 = await Deno.makeTempFile();  // e.g. /tmp/419e0bf2\n   * const tmpFileName1 = await Deno.makeTempFile({ prefix: 'my_temp' });  // e.g. /tmp/my_temp754d3098\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  export function makeTempFile(options?: MakeTempOptions): Promise<string>;\n\n  /** Synchronously changes the permission of a specific file/directory of\n   * specified path.  Ignores the process's umask.\n   *\n   * ```ts\n   * Deno.chmodSync(\"/path/to/file\", 0o666);\n   * ```\n   *\n   * For a full description, see [chmod](#Deno.chmod)\n   *\n   * NOTE: This API currently throws on Windows\n   *\n   * Requires `allow-write` permission. */\n  export function chmodSync(path: string | URL, mode: number): void;\n\n  /** Changes the permission of a specific file/directory of specified path.\n   * Ignores the process's umask.\n   *\n   * ```ts\n   * await Deno.chmod(\"/path/to/file\", 0o666);\n   * ```\n   *\n   * The mode is a sequence of 3 octal numbers.  The first/left-most number\n   * specifies the permissions for the owner.  The second number specifies the\n   * permissions for the group. The last/right-most number specifies the\n   * permissions for others.  For example, with a mode of 0o764, the owner (7) can\n   * read/write/execute, the group (6) can read/write and everyone else (4) can\n   * read only.\n   *\n   * | Number | Description |\n   * | ------ | ----------- |\n   * | 7      | read, write, and execute |\n   * | 6      | read and write |\n   * | 5      | read and execute |\n   * | 4      | read only |\n   * | 3      | write and execute |\n   * | 2      | write only |\n   * | 1      | execute only |\n   * | 0      | no permission |\n   *\n   * NOTE: This API currently throws on Windows\n   *\n   * Requires `allow-write` permission. */\n  export function chmod(path: string | URL, mode: number): Promise<void>;\n\n  /** Synchronously change owner of a regular file or directory. This functionality\n   * is not available on Windows.\n   *\n   * ```ts\n   * Deno.chownSync(\"myFile.txt\", 1000, 1002);\n   * ```\n   *\n   * Requires `allow-write` permission.\n   *\n   * Throws Error (not implemented) if executed on Windows\n   *\n   * @param path path to the file\n   * @param uid user id (UID) of the new owner, or `null` for no change\n   * @param gid group id (GID) of the new owner, or `null` for no change\n   */\n  export function chownSync(\n    path: string | URL,\n    uid: number | null,\n    gid: number | null,\n  ): void;\n\n  /** Change owner of a regular file or directory. This functionality\n   * is not available on Windows.\n   *\n   * ```ts\n   * await Deno.chown(\"myFile.txt\", 1000, 1002);\n   * ```\n   *\n   * Requires `allow-write` permission.\n   *\n   * Throws Error (not implemented) if executed on Windows\n   *\n   * @param path path to the file\n   * @param uid user id (UID) of the new owner, or `null` for no change\n   * @param gid group id (GID) of the new owner, or `null` for no change\n   */\n  export function chown(\n    path: string | URL,\n    uid: number | null,\n    gid: number | null,\n  ): Promise<void>;\n\n  export interface RemoveOptions {\n    /** Defaults to `false`. If set to `true`, path will be removed even if\n     * it's a non-empty directory. */\n    recursive?: boolean;\n  }\n\n  /** Synchronously removes the named file or directory.\n   *\n   * ```ts\n   * Deno.removeSync(\"/path/to/empty_dir/or/file\");\n   * Deno.removeSync(\"/path/to/populated_dir/or/file\", { recursive: true });\n   * ```\n   *\n   * Throws error if permission denied, path not found, or path is a non-empty\n   * directory and the `recursive` option isn't set to `true`.\n   *\n   * Requires `allow-write` permission. */\n  export function removeSync(path: string | URL, options?: RemoveOptions): void;\n\n  /** Removes the named file or directory.\n   *\n   * ```ts\n   * await Deno.remove(\"/path/to/empty_dir/or/file\");\n   * await Deno.remove(\"/path/to/populated_dir/or/file\", { recursive: true });\n   * ```\n   *\n   * Throws error if permission denied, path not found, or path is a non-empty\n   * directory and the `recursive` option isn't set to `true`.\n   *\n   * Requires `allow-write` permission. */\n  export function remove(\n    path: string | URL,\n    options?: RemoveOptions,\n  ): Promise<void>;\n\n  /** Synchronously renames (moves) `oldpath` to `newpath`. Paths may be files or\n   * directories.  If `newpath` already exists and is not a directory,\n   * `renameSync()` replaces it. OS-specific restrictions may apply when\n   * `oldpath` and `newpath` are in different directories.\n   *\n   * ```ts\n   * Deno.renameSync(\"old/path\", \"new/path\");\n   * ```\n   *\n   * On Unix, this operation does not follow symlinks at either path.\n   *\n   * It varies between platforms when the operation throws errors, and if so what\n   * they are. It's always an error to rename anything to a non-empty directory.\n   *\n   * Requires `allow-read` and `allow-write` permissions. */\n  export function renameSync(oldpath: string, newpath: string): void;\n\n  /** Renames (moves) `oldpath` to `newpath`.  Paths may be files or directories.\n   * If `newpath` already exists and is not a directory, `rename()` replaces it.\n   * OS-specific restrictions may apply when `oldpath` and `newpath` are in\n   * different directories.\n   *\n   * ```ts\n   * await Deno.rename(\"old/path\", \"new/path\");\n   * ```\n   *\n   * On Unix, this operation does not follow symlinks at either path.\n   *\n   * It varies between platforms when the operation throws errors, and if so what\n   * they are. It's always an error to rename anything to a non-empty directory.\n   *\n   * Requires `allow-read` and `allow-write` permission. */\n  export function rename(oldpath: string, newpath: string): Promise<void>;\n\n  /** Synchronously reads and returns the entire contents of a file as utf8\n   *  encoded string. Reading a directory throws an error.\n   *\n   * ```ts\n   * const data = Deno.readTextFileSync(\"hello.txt\");\n   * console.log(data);\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function readTextFileSync(path: string | URL): string;\n\n  /** Asynchronously reads and returns the entire contents of a file as utf8\n   *  encoded string. Reading a directory throws an error.\n   *\n   * ```ts\n   * const data = await Deno.readTextFile(\"hello.txt\");\n   * console.log(data);\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function readTextFile(path: string | URL): Promise<string>;\n\n  /** Synchronously reads and returns the entire contents of a file as an array\n   * of bytes. `TextDecoder` can be used to transform the bytes to string if\n   * required.  Reading a directory returns an empty data array.\n   *\n   * ```ts\n   * const decoder = new TextDecoder(\"utf-8\");\n   * const data = Deno.readFileSync(\"hello.txt\");\n   * console.log(decoder.decode(data));\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function readFileSync(path: string | URL): Uint8Array;\n\n  /** Reads and resolves to the entire contents of a file as an array of bytes.\n   * `TextDecoder` can be used to transform the bytes to string if required.\n   * Reading a directory returns an empty data array.\n   *\n   * ```ts\n   * const decoder = new TextDecoder(\"utf-8\");\n   * const data = await Deno.readFile(\"hello.txt\");\n   * console.log(decoder.decode(data));\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function readFile(path: string | URL): Promise<Uint8Array>;\n\n  /** A FileInfo describes a file and is returned by `stat`, `lstat`,\n   * `statSync`, `lstatSync`. */\n  export interface FileInfo {\n    /** True if this is info for a regular file. Mutually exclusive to\n     * `FileInfo.isDirectory` and `FileInfo.isSymlink`. */\n    isFile: boolean;\n    /** True if this is info for a regular directory. Mutually exclusive to\n     * `FileInfo.isFile` and `FileInfo.isSymlink`. */\n    isDirectory: boolean;\n    /** True if this is info for a symlink. Mutually exclusive to\n     * `FileInfo.isFile` and `FileInfo.isDirectory`. */\n    isSymlink: boolean;\n    /** The size of the file, in bytes. */\n    size: number;\n    /** The last modification time of the file. This corresponds to the `mtime`\n     * field from `stat` on Linux/Mac OS and `ftLastWriteTime` on Windows. This\n     * may not be available on all platforms. */\n    mtime: Date | null;\n    /** The last access time of the file. This corresponds to the `atime`\n     * field from `stat` on Unix and `ftLastAccessTime` on Windows. This may not\n     * be available on all platforms. */\n    atime: Date | null;\n    /** The creation time of the file. This corresponds to the `birthtime`\n     * field from `stat` on Mac/BSD and `ftCreationTime` on Windows. This may\n     * not be available on all platforms. */\n    birthtime: Date | null;\n    /** ID of the device containing the file.\n     *\n     * _Linux/Mac OS only._ */\n    dev: number | null;\n    /** Inode number.\n     *\n     * _Linux/Mac OS only._ */\n    ino: number | null;\n    /** **UNSTABLE**: Match behavior with Go on Windows for `mode`.\n     *\n     * The underlying raw `st_mode` bits that contain the standard Unix\n     * permissions for this file/directory. */\n    mode: number | null;\n    /** Number of hard links pointing to this file.\n     *\n     * _Linux/Mac OS only._ */\n    nlink: number | null;\n    /** User ID of the owner of this file.\n     *\n     * _Linux/Mac OS only._ */\n    uid: number | null;\n    /** Group ID of the owner of this file.\n     *\n     * _Linux/Mac OS only._ */\n    gid: number | null;\n    /** Device ID of this file.\n     *\n     * _Linux/Mac OS only._ */\n    rdev: number | null;\n    /** Blocksize for filesystem I/O.\n     *\n     * _Linux/Mac OS only._ */\n    blksize: number | null;\n    /** Number of blocks allocated to the file, in 512-byte units.\n     *\n     * _Linux/Mac OS only._ */\n    blocks: number | null;\n  }\n\n  /** Returns absolute normalized path, with symbolic links resolved.\n   *\n   * ```ts\n   * // e.g. given /home/alice/file.txt and current directory /home/alice\n   * Deno.symlinkSync(\"file.txt\", \"symlink_file.txt\");\n   * const realPath = Deno.realPathSync(\"./file.txt\");\n   * const realSymLinkPath = Deno.realPathSync(\"./symlink_file.txt\");\n   * console.log(realPath);  // outputs \"/home/alice/file.txt\"\n   * console.log(realSymLinkPath);  // outputs \"/home/alice/file.txt\"\n   * ```\n   *\n   * Requires `allow-read` permission for the target path.\n   * Also requires `allow-read` permission for the CWD if the target path is\n   * relative.*/\n  export function realPathSync(path: string): string;\n\n  /** Resolves to the absolute normalized path, with symbolic links resolved.\n   *\n   * ```ts\n   * // e.g. given /home/alice/file.txt and current directory /home/alice\n   * await Deno.symlink(\"file.txt\", \"symlink_file.txt\");\n   * const realPath = await Deno.realPath(\"./file.txt\");\n   * const realSymLinkPath = await Deno.realPath(\"./symlink_file.txt\");\n   * console.log(realPath);  // outputs \"/home/alice/file.txt\"\n   * console.log(realSymLinkPath);  // outputs \"/home/alice/file.txt\"\n   * ```\n   *\n   * Requires `allow-read` permission for the target path.\n   * Also requires `allow-read` permission for the CWD if the target path is\n   * relative.*/\n  export function realPath(path: string): Promise<string>;\n\n  export interface DirEntry {\n    name: string;\n    isFile: boolean;\n    isDirectory: boolean;\n    isSymlink: boolean;\n  }\n\n  /** Synchronously reads the directory given by `path` and returns an iterable\n   * of `Deno.DirEntry`.\n   *\n   * ```ts\n   * for (const dirEntry of Deno.readDirSync(\"/\")) {\n   *   console.log(dirEntry.name);\n   * }\n   * ```\n   *\n   * Throws error if `path` is not a directory.\n   *\n   * Requires `allow-read` permission. */\n  export function readDirSync(path: string | URL): Iterable<DirEntry>;\n\n  /** Reads the directory given by `path` and returns an async iterable of\n   * `Deno.DirEntry`.\n   *\n   * ```ts\n   * for await (const dirEntry of Deno.readDir(\"/\")) {\n   *   console.log(dirEntry.name);\n   * }\n   * ```\n   *\n   * Throws error if `path` is not a directory.\n   *\n   * Requires `allow-read` permission. */\n  export function readDir(path: string | URL): AsyncIterable<DirEntry>;\n\n  /** Synchronously copies the contents and permissions of one file to another\n   * specified path, by default creating a new file if needed, else overwriting.\n   * Fails if target path is a directory or is unwritable.\n   *\n   * ```ts\n   * Deno.copyFileSync(\"from.txt\", \"to.txt\");\n   * ```\n   *\n   * Requires `allow-read` permission on fromPath.\n   * Requires `allow-write` permission on toPath. */\n  export function copyFileSync(\n    fromPath: string | URL,\n    toPath: string | URL,\n  ): void;\n\n  /** Copies the contents and permissions of one file to another specified path,\n   * by default creating a new file if needed, else overwriting. Fails if target\n   * path is a directory or is unwritable.\n   *\n   * ```ts\n   * await Deno.copyFile(\"from.txt\", \"to.txt\");\n   * ```\n   *\n   * Requires `allow-read` permission on fromPath.\n   * Requires `allow-write` permission on toPath. */\n  export function copyFile(\n    fromPath: string | URL,\n    toPath: string | URL,\n  ): Promise<void>;\n\n  /** Returns the full path destination of the named symbolic link.\n   *\n   * ```ts\n   * Deno.symlinkSync(\"./test.txt\", \"./test_link.txt\");\n   * const target = Deno.readLinkSync(\"./test_link.txt\"); // full path of ./test.txt\n   * ```\n   *\n   * Throws TypeError if called with a hard link\n   *\n   * Requires `allow-read` permission. */\n  export function readLinkSync(path: string | URL): string;\n\n  /** Resolves to the full path destination of the named symbolic link.\n   *\n   * ```ts\n   * await Deno.symlink(\"./test.txt\", \"./test_link.txt\");\n   * const target = await Deno.readLink(\"./test_link.txt\"); // full path of ./test.txt\n   * ```\n   *\n   * Throws TypeError if called with a hard link\n   *\n   * Requires `allow-read` permission. */\n  export function readLink(path: string | URL): Promise<string>;\n\n  /** Resolves to a `Deno.FileInfo` for the specified `path`. If `path` is a\n   * symlink, information for the symlink will be returned instead of what it\n   * points to.\n   *\n   * ```ts\n   * import { assert } from \"https://deno.land/std/testing/asserts.ts\";\n   * const fileInfo = await Deno.lstat(\"hello.txt\");\n   * assert(fileInfo.isFile);\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function lstat(path: string | URL): Promise<FileInfo>;\n\n  /** Synchronously returns a `Deno.FileInfo` for the specified `path`. If\n   * `path` is a symlink, information for the symlink will be returned instead of\n   * what it points to..\n   *\n   * ```ts\n   * const fileInfo = Deno.lstatSync(\"hello.txt\");\n   * assert(fileInfo.isFile);\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function lstatSync(path: string | URL): FileInfo;\n\n  /** Resolves to a `Deno.FileInfo` for the specified `path`. Will always\n   * follow symlinks.\n   *\n   * ```ts\n   * import { assert } from \"https://deno.land/std/testing/asserts.ts\";\n   * const fileInfo = await Deno.stat(\"hello.txt\");\n   * assert(fileInfo.isFile);\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function stat(path: string | URL): Promise<FileInfo>;\n\n  /** Synchronously returns a `Deno.FileInfo` for the specified `path`. Will\n   * always follow symlinks.\n   *\n   * ```ts\n   * import { assert } from \"https://deno.land/std/testing/asserts.ts\";\n   * const fileInfo = Deno.statSync(\"hello.txt\");\n   * assert(fileInfo.isFile);\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function statSync(path: string | URL): FileInfo;\n\n  /** Options for writing to a file. */\n  export interface WriteFileOptions {\n    /** Defaults to `false`. If set to `true`, will append to a file instead of\n     * overwriting previous contents. */\n    append?: boolean;\n    /** Sets the option to allow creating a new file, if one doesn't already\n     * exist at the specified path (defaults to `true`). */\n    create?: boolean;\n    /** Permissions always applied to file. */\n    mode?: number;\n  }\n\n  /** Synchronously write `data` to the given `path`, by default creating a new\n   * file if needed, else overwriting.\n   *\n   * ```ts\n   * const encoder = new TextEncoder();\n   * const data = encoder.encode(\"Hello world\\n\");\n   * Deno.writeFileSync(\"hello1.txt\", data);  // overwrite \"hello1.txt\" or create it\n   * Deno.writeFileSync(\"hello2.txt\", data, {create: false});  // only works if \"hello2.txt\" exists\n   * Deno.writeFileSync(\"hello3.txt\", data, {mode: 0o777});  // set permissions on new file\n   * Deno.writeFileSync(\"hello4.txt\", data, {append: true});  // add data to the end of the file\n   * ```\n   *\n   * Requires `allow-write` permission, and `allow-read` if `options.create` is\n   * `false`.\n   */\n  export function writeFileSync(\n    path: string | URL,\n    data: Uint8Array,\n    options?: WriteFileOptions,\n  ): void;\n\n  /** Write `data` to the given `path`, by default creating a new file if needed,\n   * else overwriting.\n   *\n   * ```ts\n   * const encoder = new TextEncoder();\n   * const data = encoder.encode(\"Hello world\\n\");\n   * await Deno.writeFile(\"hello1.txt\", data);  // overwrite \"hello1.txt\" or create it\n   * await Deno.writeFile(\"hello2.txt\", data, {create: false});  // only works if \"hello2.txt\" exists\n   * await Deno.writeFile(\"hello3.txt\", data, {mode: 0o777});  // set permissions on new file\n   * await Deno.writeFile(\"hello4.txt\", data, {append: true});  // add data to the end of the file\n   * ```\n   *\n   * Requires `allow-write` permission, and `allow-read` if `options.create` is `false`.\n   */\n  export function writeFile(\n    path: string | URL,\n    data: Uint8Array,\n    options?: WriteFileOptions,\n  ): Promise<void>;\n\n  /** Synchronously write string `data` to the given `path`, by default creating a new file if needed,\n   * else overwriting.\n   *\n   * ```ts\n   * Deno.writeTextFileSync(\"hello1.txt\", \"Hello world\\n\");  // overwrite \"hello1.txt\" or create it\n   * ```\n   *\n   * Requires `allow-write` permission, and `allow-read` if `options.create` is `false`.\n   */\n  export function writeTextFileSync(\n    path: string | URL,\n    data: string,\n    options?: WriteFileOptions,\n  ): void;\n\n  /** Asynchronously write string `data` to the given `path`, by default creating a new file if needed,\n   * else overwriting.\n   *\n   * ```ts\n   * await Deno.writeTextFile(\"hello1.txt\", \"Hello world\\n\");  // overwrite \"hello1.txt\" or create it\n   * ```\n   *\n   * Requires `allow-write` permission, and `allow-read` if `options.create` is `false`.\n   */\n  export function writeTextFile(\n    path: string | URL,\n    data: string,\n    options?: WriteFileOptions,\n  ): Promise<void>;\n\n  /** Synchronously truncates or extends the specified file, to reach the\n   * specified `len`.  If `len` is not specified then the entire file contents\n   * are truncated.\n   *\n   * ```ts\n   * // truncate the entire file\n   * Deno.truncateSync(\"my_file.txt\");\n   *\n   * // truncate part of the file\n   * const file = Deno.makeTempFileSync();\n   * Deno.writeFileSync(file, new TextEncoder().encode(\"Hello World\"));\n   * Deno.truncateSync(file, 7);\n   * const data = Deno.readFileSync(file);\n   * console.log(new TextDecoder().decode(data));\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  export function truncateSync(name: string, len?: number): void;\n\n  /** Truncates or extends the specified file, to reach the specified `len`. If\n   * `len` is not specified then the entire file contents are truncated.\n   *\n   * ```ts\n   * // truncate the entire file\n   * await Deno.truncate(\"my_file.txt\");\n   *\n   * // truncate part of the file\n   * const file = await Deno.makeTempFile();\n   * await Deno.writeFile(file, new TextEncoder().encode(\"Hello World\"));\n   * await Deno.truncate(file, 7);\n   * const data = await Deno.readFile(file);\n   * console.log(new TextDecoder().decode(data));  // \"Hello W\"\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  export function truncate(name: string, len?: number): Promise<void>;\n\n  export interface NetAddr {\n    transport: \"tcp\" | \"udp\";\n    hostname: string;\n    port: number;\n  }\n\n  export interface UnixAddr {\n    transport: \"unix\" | \"unixpacket\";\n    path: string;\n  }\n\n  export type Addr = NetAddr | UnixAddr;\n\n  /** A generic network listener for stream-oriented protocols. */\n  export interface Listener extends AsyncIterable<Conn> {\n    /** Waits for and resolves to the next connection to the `Listener`. */\n    accept(): Promise<Conn>;\n    /** Close closes the listener. Any pending accept promises will be rejected\n     * with errors. */\n    close(): void;\n    /** Return the address of the `Listener`. */\n    readonly addr: Addr;\n\n    /** Return the rid of the `Listener`. */\n    readonly rid: number;\n\n    [Symbol.asyncIterator](): AsyncIterableIterator<Conn>;\n  }\n\n  export interface Conn extends Reader, Writer, Closer {\n    /** The local address of the connection. */\n    readonly localAddr: Addr;\n    /** The remote address of the connection. */\n    readonly remoteAddr: Addr;\n    /** The resource ID of the connection. */\n    readonly rid: number;\n    /** Shuts down (`shutdown(2)`) the write side of the connection. Most\n     * callers should just use `close()`. */\n    closeWrite(): Promise<void>;\n  }\n\n  export interface ListenOptions {\n    /** The port to listen on. */\n    port: number;\n    /** A literal IP address or host name that can be resolved to an IP address.\n     * If not specified, defaults to `0.0.0.0`. */\n    hostname?: string;\n  }\n\n  /** Listen announces on the local transport address.\n   *\n   * ```ts\n   * const listener1 = Deno.listen({ port: 80 })\n   * const listener2 = Deno.listen({ hostname: \"192.0.2.1\", port: 80 })\n   * const listener3 = Deno.listen({ hostname: \"[2001:db8::1]\", port: 80 });\n   * const listener4 = Deno.listen({ hostname: \"golang.org\", port: 80, transport: \"tcp\" });\n   * ```\n   *\n   * Requires `allow-net` permission. */\n  export function listen(\n    options: ListenOptions & { transport?: \"tcp\" },\n  ): Listener;\n\n  export interface ListenTlsOptions extends ListenOptions {\n    /** Server certificate file. */\n    certFile: string;\n    /** Server public key file. */\n    keyFile: string;\n\n    transport?: \"tcp\";\n  }\n\n  /** Listen announces on the local transport address over TLS (transport layer\n   * security).\n   *\n   * ```ts\n   * const lstnr = Deno.listenTls({ port: 443, certFile: \"./server.crt\", keyFile: \"./server.key\" });\n   * ```\n   *\n   * Requires `allow-net` permission. */\n  export function listenTls(options: ListenTlsOptions): Listener;\n\n  export interface ConnectOptions {\n    /** The port to connect to. */\n    port: number;\n    /** A literal IP address or host name that can be resolved to an IP address.\n     * If not specified, defaults to `127.0.0.1`. */\n    hostname?: string;\n    transport?: \"tcp\";\n  }\n\n  /**\n   * Connects to the hostname (default is \"127.0.0.1\") and port on the named\n   * transport (default is \"tcp\"), and resolves to the connection (`Conn`).\n   *\n   * ```ts\n   * const conn1 = await Deno.connect({ port: 80 });\n   * const conn2 = await Deno.connect({ hostname: \"192.0.2.1\", port: 80 });\n   * const conn3 = await Deno.connect({ hostname: \"[2001:db8::1]\", port: 80 });\n   * const conn4 = await Deno.connect({ hostname: \"golang.org\", port: 80, transport: \"tcp\" });\n   * ```\n   *\n   * Requires `allow-net` permission for \"tcp\". */\n  export function connect(options: ConnectOptions): Promise<Conn>;\n\n  export interface ConnectTlsOptions {\n    /** The port to connect to. */\n    port: number;\n    /** A literal IP address or host name that can be resolved to an IP address.\n     * If not specified, defaults to `127.0.0.1`. */\n    hostname?: string;\n    /** Server certificate file. */\n    certFile?: string;\n  }\n\n  /** Establishes a secure connection over TLS (transport layer security) using\n   * an optional cert file, hostname (default is \"127.0.0.1\") and port.  The\n   * cert file is optional and if not included Mozilla's root certificates will\n   * be used (see also https://github.com/ctz/webpki-roots for specifics)\n   *\n   * ```ts\n   * const conn1 = await Deno.connectTls({ port: 80 });\n   * const conn2 = await Deno.connectTls({ certFile: \"./certs/my_custom_root_CA.pem\", hostname: \"192.0.2.1\", port: 80 });\n   * const conn3 = await Deno.connectTls({ hostname: \"[2001:db8::1]\", port: 80 });\n   * const conn4 = await Deno.connectTls({ certFile: \"./certs/my_custom_root_CA.pem\", hostname: \"golang.org\", port: 80});\n   * ```\n   *\n   * Requires `allow-net` permission.\n   */\n  export function connectTls(options: ConnectTlsOptions): Promise<Conn>;\n\n  /** Shutdown socket send operations.\n   *\n   * Matches behavior of POSIX shutdown(3).\n   *\n   * ```ts\n   * const listener = Deno.listen({ port: 80 });\n   * const conn = await listener.accept();\n   * Deno.shutdown(conn.rid);\n   * ```\n   */\n  export function shutdown(rid: number): Promise<void>;\n\n  export interface Metrics {\n    opsDispatched: number;\n    opsDispatchedSync: number;\n    opsDispatchedAsync: number;\n    opsDispatchedAsyncUnref: number;\n    opsCompleted: number;\n    opsCompletedSync: number;\n    opsCompletedAsync: number;\n    opsCompletedAsyncUnref: number;\n    bytesSentControl: number;\n    bytesSentData: number;\n    bytesReceived: number;\n  }\n\n  /** Receive metrics from the privileged side of Deno. This is primarily used\n   * in the development of Deno. 'Ops', also called 'bindings', are the go-between\n   * between Deno JavaScript and Deno Rust.\n   *\n   *      > console.table(Deno.metrics())\n   *      ┌─────────────────────────┬────────┐\n   *      │         (index)         │ Values │\n   *      ├─────────────────────────┼────────┤\n   *      │      opsDispatched      │   3    │\n   *      │    opsDispatchedSync    │   2    │\n   *      │   opsDispatchedAsync    │   1    │\n   *      │ opsDispatchedAsyncUnref │   0    │\n   *      │      opsCompleted       │   3    │\n   *      │    opsCompletedSync     │   2    │\n   *      │    opsCompletedAsync    │   1    │\n   *      │ opsCompletedAsyncUnref  │   0    │\n   *      │    bytesSentControl     │   73   │\n   *      │      bytesSentData      │   0    │\n   *      │      bytesReceived      │  375   │\n   *      └─────────────────────────┴────────┘\n   */\n  export function metrics(): Metrics;\n\n  interface ResourceMap {\n    // deno-lint-ignore no-explicit-any\n    [rid: number]: any;\n  }\n\n  /** Returns a map of open resource ids (rid) along with their string\n   * representations. This is an internal API and as such resource\n   * representation has `any` type; that means it can change any time.\n   *\n   * ```ts\n   * console.log(Deno.resources());\n   * // { 0: \"stdin\", 1: \"stdout\", 2: \"stderr\" }\n   * Deno.openSync('../test.file');\n   * console.log(Deno.resources());\n   * // { 0: \"stdin\", 1: \"stdout\", 2: \"stderr\", 3: \"fsFile\" }\n   * ```\n   */\n  export function resources(): ResourceMap;\n\n  export interface FsEvent {\n    kind: \"any\" | \"access\" | \"create\" | \"modify\" | \"remove\";\n    paths: string[];\n  }\n\n  /** Watch for file system events against one or more `paths`, which can be files\n   * or directories.  These paths must exist already.  One user action (e.g.\n   * `touch test.file`) can  generate multiple file system events.  Likewise,\n   * one user action can result in multiple file paths in one event (e.g. `mv\n   * old_name.txt new_name.txt`).  Recursive option is `true` by default and,\n   * for directories, will watch the specified directory and all sub directories.\n   * Note that the exact ordering of the events can vary between operating systems.\n   *\n   * ```ts\n   * const watcher = Deno.watchFs(\"/\");\n   * for await (const event of watcher) {\n   *    console.log(\">>>> event\", event);\n   *    // { kind: \"create\", paths: [ \"/foo.txt\" ] }\n   * }\n   *```\n   *\n   * Requires `allow-read` permission.\n   */\n  export function watchFs(\n    paths: string | string[],\n    options?: { recursive: boolean },\n  ): AsyncIterableIterator<FsEvent>;\n\n  export class Process<T extends RunOptions = RunOptions> {\n    readonly rid: number;\n    readonly pid: number;\n    readonly stdin: T[\"stdin\"] extends \"piped\" ? Writer & Closer\n      : (Writer & Closer) | null;\n    readonly stdout: T[\"stdout\"] extends \"piped\" ? Reader & Closer\n      : (Reader & Closer) | null;\n    readonly stderr: T[\"stderr\"] extends \"piped\" ? Reader & Closer\n      : (Reader & Closer) | null;\n    /** Wait for the process to exit and return its exit status.\n     *\n     * Calling this function multiple times will return the same status.\n     *\n     * Stdin handle to the process will be closed before waiting to avoid\n     * a deadlock.\n     *\n     * If `stdout` and/or `stderr` were set to `\"piped\"`, they must be closed\n     * manually before the process can exit.\n     * \n     * To run process to completion and collect output from both `stdout` and\n     * `stderr` use:\n     * \n     * ```ts\n     * const p = Deno.run({ cmd, stderr: 'piped', stdout: 'piped' });\n     * const [status, stdout, stderr] = await Promise.all([\n     *   p.status(),\n     *   p.output(),\n     *   p.stderrOutput()\n     * ]);\n     * p.close();\n     * ```\n     **/\n    status(): Promise<ProcessStatus>;\n    /** Buffer the stdout until EOF and return it as `Uint8Array`.\n     *\n     * You must set stdout to `\"piped\"` when creating the process.\n     *\n     * This calls `close()` on stdout after its done. */\n    output(): Promise<Uint8Array>;\n    /** Buffer the stderr until EOF and return it as `Uint8Array`.\n     *\n     * You must set stderr to `\"piped\"` when creating the process.\n     *\n     * This calls `close()` on stderr after its done. */\n    stderrOutput(): Promise<Uint8Array>;\n    close(): void;\n\n    /** **UNSTABLE**: The `signo` argument may change to require the Deno.Signal\n     * enum.\n     *\n     * Send a signal to process. This functionality currently only works on\n     * Linux and Mac OS.\n     */\n    kill(signo: number): void;\n  }\n\n  export type ProcessStatus =\n    | {\n      success: true;\n      code: 0;\n      signal?: undefined;\n    }\n    | {\n      success: false;\n      code: number;\n      signal?: number;\n    };\n\n  export interface RunOptions {\n    /** Arguments to pass. Note, the first element needs to be a path to the\n     * binary */\n    cmd: string[] | [URL, ...string[]];\n    cwd?: string;\n    env?: {\n      [key: string]: string;\n    };\n    stdout?: \"inherit\" | \"piped\" | \"null\" | number;\n    stderr?: \"inherit\" | \"piped\" | \"null\" | number;\n    stdin?: \"inherit\" | \"piped\" | \"null\" | number;\n  }\n\n  /** Spawns new subprocess.  RunOptions must contain at a minimum the `opt.cmd`,\n   * an array of program arguments, the first of which is the binary.\n   *\n   * ```ts\n   * const p = Deno.run({\n   *   cmd: [\"echo\", \"hello\"],\n   * });\n   * ```\n   *\n   * Subprocess uses same working directory as parent process unless `opt.cwd`\n   * is specified.\n   *\n   * Environmental variables for subprocess can be specified using `opt.env`\n   * mapping.\n   *\n   * By default subprocess inherits stdio of parent process. To change that\n   * `opt.stdout`, `opt.stderr` and `opt.stdin` can be specified independently -\n   * they can be set to either an rid of open file or set to \"inherit\" \"piped\"\n   * or \"null\":\n   *\n   * `\"inherit\"` The default if unspecified. The child inherits from the\n   * corresponding parent descriptor.\n   *\n   * `\"piped\"` A new pipe should be arranged to connect the parent and child\n   * sub-processes.\n   *\n   * `\"null\"` This stream will be ignored. This is the equivalent of attaching\n   * the stream to `/dev/null`.\n   *\n   * Details of the spawned process are returned.\n   *\n   * Requires `allow-run` permission. */\n  export function run<T extends RunOptions = RunOptions>(opt: T): Process<T>;\n\n  export interface InspectOptions {\n    /** Stylize output with ANSI colors. Defaults to false. */\n    colors?: boolean;\n    /** Try to fit more than one entry of a collection on the same line.\n     * Defaults to true. */\n    compact?: boolean;\n    /** Traversal depth for nested objects. Defaults to 4. */\n    depth?: number;\n    /** The maximum number of iterable entries to print. Defaults to 100. */\n    iterableLimit?: number;\n    /** Show a Proxy's target and handler. Defaults to false. */\n    showProxy?: boolean;\n    /** Sort Object, Set and Map entries by key. Defaults to false. */\n    sorted?: boolean;\n    /** Add a trailing comma for multiline collections. Defaults to false. */\n    trailingComma?: boolean;\n    /*** Evaluate the result of calling getters. Defaults to false. */\n    getters?: boolean;\n    /** Show an object's non-enumerable properties. Defaults to false. */\n    showHidden?: boolean;\n  }\n\n  /** Converts the input into a string that has the same format as printed by\n   * `console.log()`.\n   *\n   * ```ts\n   * const obj = {};\n   * obj.propA = 10;\n   * obj.propB = \"hello\";\n   * const objAsString = Deno.inspect(obj); // { propA: 10, propB: \"hello\" }\n   * console.log(obj);  // prints same value as objAsString, e.g. { propA: 10, propB: \"hello\" }\n   * ```\n   *\n   * You can also register custom inspect functions, via the `customInspect` Deno\n   * symbol on objects, to control and customize the output.\n   *\n   * ```ts\n   * class A {\n   *   x = 10;\n   *   y = \"hello\";\n   *   [Deno.customInspect](): string {\n   *     return \"x=\" + this.x + \", y=\" + this.y;\n   *   }\n   * }\n   * ```\n   *\n   *      const inStringFormat = Deno.inspect(new A()); // \"x=10, y=hello\"\n   *      console.log(inStringFormat);  // prints \"x=10, y=hello\"\n   *\n   * Finally, you can also specify the depth to which it will format.\n   *\n   *      Deno.inspect({a: {b: {c: {d: 'hello'}}}}, {depth: 2}); // { a: { b: [Object] } }\n   *\n   */\n  export function inspect(value: unknown, options?: InspectOptions): string;\n\n  /** The name of a \"powerful feature\" which needs permission. */\n  export type PermissionName =\n    | \"run\"\n    | \"read\"\n    | \"write\"\n    | \"net\"\n    | \"env\"\n    | \"plugin\"\n    | \"hrtime\";\n\n  /** The current status of the permission. */\n  export type PermissionState = \"granted\" | \"denied\" | \"prompt\";\n\n  export interface RunPermissionDescriptor {\n    name: \"run\";\n  }\n\n  export interface ReadPermissionDescriptor {\n    name: \"read\";\n    path?: string;\n  }\n\n  export interface WritePermissionDescriptor {\n    name: \"write\";\n    path?: string;\n  }\n\n  export interface NetPermissionDescriptor {\n    name: \"net\";\n    /** Optional host string of the form `\"<hostname>[:<port>]\"`. Examples:\n     *\n     *      \"github.com\"\n     *      \"deno.land:8080\"\n     */\n    host?: string;\n  }\n\n  export interface EnvPermissionDescriptor {\n    name: \"env\";\n  }\n\n  export interface PluginPermissionDescriptor {\n    name: \"plugin\";\n  }\n\n  export interface HrtimePermissionDescriptor {\n    name: \"hrtime\";\n  }\n\n  /** Permission descriptors which define a permission and can be queried,\n   * requested, or revoked. */\n  export type PermissionDescriptor =\n    | RunPermissionDescriptor\n    | ReadPermissionDescriptor\n    | WritePermissionDescriptor\n    | NetPermissionDescriptor\n    | EnvPermissionDescriptor\n    | PluginPermissionDescriptor\n    | HrtimePermissionDescriptor;\n\n  export interface PermissionStatusEventMap {\n    \"change\": Event;\n  }\n\n  export class PermissionStatus extends EventTarget {\n    // deno-lint-ignore no-explicit-any\n    onchange: ((this: PermissionStatus, ev: Event) => any) | null;\n    readonly state: PermissionState;\n    addEventListener<K extends keyof PermissionStatusEventMap>(\n      type: K,\n      listener: (\n        this: PermissionStatus,\n        ev: PermissionStatusEventMap[K],\n      ) => any,\n      options?: boolean | AddEventListenerOptions,\n    ): void;\n    addEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | AddEventListenerOptions,\n    ): void;\n    removeEventListener<K extends keyof PermissionStatusEventMap>(\n      type: K,\n      listener: (\n        this: PermissionStatus,\n        ev: PermissionStatusEventMap[K],\n      ) => any,\n      options?: boolean | EventListenerOptions,\n    ): void;\n    removeEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | EventListenerOptions,\n    ): void;\n  }\n\n  export class Permissions {\n    /** Resolves to the current status of a permission.\n     *\n     * ```ts\n     * const status = await Deno.permissions.query({ name: \"read\", path: \"/etc\" });\n     * if (status.state === \"granted\") {\n     *   data = await Deno.readFile(\"/etc/passwd\");\n     * }\n     * ```\n     */\n    query(desc: PermissionDescriptor): Promise<PermissionStatus>;\n\n    /** Revokes a permission, and resolves to the state of the permission.\n     *\n     * ```ts\n     * const status = await Deno.permissions.revoke({ name: \"run\" });\n     * assert(status.state !== \"granted\")\n     * ```\n     */\n    revoke(desc: PermissionDescriptor): Promise<PermissionStatus>;\n\n    /** Requests the permission, and resolves to the state of the permission.\n     *\n     * ```ts\n     * const status = await Deno.permissions.request({ name: \"env\" });\n     * if (status.state === \"granted\") {\n     *   console.log(\"'env' permission is granted.\");\n     * } else {\n     *   console.log(\"'env' permission is denied.\");\n     * }\n     * ```\n     */\n    request(desc: PermissionDescriptor): Promise<PermissionStatus>;\n  }\n\n  /** Deno's permission management API. */\n  export const permissions: Permissions;\n\n  /** Build related information. */\n  export const build: {\n    /** The LLVM target triple */\n    target: string;\n    /** Instruction set architecture */\n    arch: \"x86_64\";\n    /** Operating system */\n    os: \"darwin\" | \"linux\" | \"windows\";\n    /** Computer vendor */\n    vendor: string;\n    /** Optional environment */\n    env?: string;\n  };\n\n  /** Version related information. */\n  export const version: {\n    /** Deno's version. For example: `\"1.0.0\"` */\n    deno: string;\n    /** The V8 version used by Deno. For example: `\"8.0.0.0\"` */\n    v8: string;\n    /** The TypeScript version used by Deno. For example: `\"4.0.0\"` */\n    typescript: string;\n  };\n\n  /** Returns the script arguments to the program. If for example we run a\n   * program:\n   *\n   * deno run --allow-read https://deno.land/std/examples/cat.ts /etc/passwd\n   *\n   * Then `Deno.args` will contain:\n   *\n   * [ \"/etc/passwd\" ]\n   */\n  export const args: string[];\n\n  /** A symbol which can be used as a key for a custom method which will be\n   * called when `Deno.inspect()` is called, or when the object is logged to\n   * the console. */\n  export const customInspect: unique symbol;\n\n  /** The URL of the entrypoint module entered from the command-line. */\n  export const mainModule: string;\n\n  export type SymlinkOptions = {\n    type: \"file\" | \"dir\";\n  };\n\n  /**\n   * Creates `newpath` as a symbolic link to `oldpath`.\n   *\n   * The options.type parameter can be set to `file` or `dir`. This argument is only\n   * available on Windows and ignored on other platforms.\n   *\n   * ```ts\n   * Deno.symlinkSync(\"old/name\", \"new/name\");\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  export function symlinkSync(\n    oldpath: string,\n    newpath: string,\n    options?: SymlinkOptions,\n  ): void;\n\n  /**\n   * Creates `newpath` as a symbolic link to `oldpath`.\n   *\n   * The options.type parameter can be set to `file` or `dir`. This argument is only\n   * available on Windows and ignored on other platforms.\n   *\n   * ```ts\n   * await Deno.symlink(\"old/name\", \"new/name\");\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  export function symlink(\n    oldpath: string,\n    newpath: string,\n    options?: SymlinkOptions,\n  ): Promise<void>;\n}\n",
			"file": "deno_src/cli/dts/lib.deno.ns.d.ts",
			"file_size": 81682,
			"file_write_time": 132597970090000000,
			"settings":
			{
				"buffer_size": 81394,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "deno_src/cli/dts/lib.dom.d.ts",
			"settings":
			{
				"buffer_size": 842607,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.\n\n/// <reference no-default-lib=\"true\" />\n/// <reference lib=\"esnext\" />\n\n/** Deno provides extra properties on `import.meta`.  These are included here\n * to ensure that these are still available when using the Deno namespace in\n * conjunction with other type libs, like `dom`. */\ndeclare interface ImportMeta {\n  /** A string representation of the fully qualified module URL. */\n  url: string;\n\n  /** A flag that indicates if the current module is the main module that was\n   * called when starting the program under Deno.\n   *\n   * ```ts\n   * if (import.meta.main) {\n   *   // this was loaded as the main module, maybe do some bootstrapping\n   * }\n   * ```\n   */\n  main: boolean;\n}\n\n/** Deno supports user timing Level 3 (see: https://w3c.github.io/user-timing)\n * which is not widely supported yet in other runtimes.  These types are here\n * so that these features are still available when using the Deno namespace\n * in conjunction with other type libs, like `dom`. */\ndeclare interface Performance {\n  /** Stores a timestamp with the associated name (a \"mark\"). */\n  mark(markName: string, options?: PerformanceMarkOptions): PerformanceMark;\n\n  /** Stores the `DOMHighResTimeStamp` duration between two marks along with the\n   * associated name (a \"measure\"). */\n  measure(\n    measureName: string,\n    options?: PerformanceMeasureOptions,\n  ): PerformanceMeasure;\n}\n\ndeclare interface PerformanceMarkOptions {\n  /** Metadata to be included in the mark. */\n  // deno-lint-ignore no-explicit-any\n  detail?: any;\n\n  /** Timestamp to be used as the mark time. */\n  startTime?: number;\n}\n\ndeclare interface PerformanceMeasureOptions {\n  /** Metadata to be included in the measure. */\n  // deno-lint-ignore no-explicit-any\n  detail?: any;\n\n  /** Timestamp to be used as the start time or string to be used as start\n   * mark.*/\n  start?: string | number;\n\n  /** Duration between the start and end times. */\n  duration?: number;\n\n  /** Timestamp to be used as the end time or string to be used as end mark. */\n  end?: string | number;\n}\n\ndeclare namespace Deno {\n  /** A set of error constructors that are raised by Deno APIs. */\n  export const errors: {\n    NotFound: ErrorConstructor;\n    PermissionDenied: ErrorConstructor;\n    ConnectionRefused: ErrorConstructor;\n    ConnectionReset: ErrorConstructor;\n    ConnectionAborted: ErrorConstructor;\n    NotConnected: ErrorConstructor;\n    AddrInUse: ErrorConstructor;\n    AddrNotAvailable: ErrorConstructor;\n    BrokenPipe: ErrorConstructor;\n    AlreadyExists: ErrorConstructor;\n    InvalidData: ErrorConstructor;\n    TimedOut: ErrorConstructor;\n    Interrupted: ErrorConstructor;\n    WriteZero: ErrorConstructor;\n    UnexpectedEof: ErrorConstructor;\n    BadResource: ErrorConstructor;\n    Http: ErrorConstructor;\n    Busy: ErrorConstructor;\n  };\n\n  /** The current process id of the runtime. */\n  export const pid: number;\n\n  /** Reflects the `NO_COLOR` environment variable.\n   *\n   * See: https://no-color.org/ */\n  export const noColor: boolean;\n\n  export interface TestDefinition {\n    fn: () => void | Promise<void>;\n    name: string;\n    ignore?: boolean;\n    /** If at lease one test has `only` set to true, only run tests that have\n     * `only` set to true and fail the test suite. */\n    only?: boolean;\n    /** Check that the number of async completed ops after the test is the same\n     * as number of dispatched ops. Defaults to true.*/\n    sanitizeOps?: boolean;\n    /** Ensure the test case does not \"leak\" resources - ie. the resource table\n     * after the test has exactly the same contents as before the test. Defaults\n     * to true. */\n    sanitizeResources?: boolean;\n\n    /** Ensure the test case does not prematurely cause the process to exit,\n     * for example via a call to `Deno.exit`. Defaults to true. */\n    sanitizeExit?: boolean;\n  }\n\n  /** Register a test which will be run when `deno test` is used on the command\n   * line and the containing module looks like a test module.\n   * `fn` can be async if required.\n   * ```ts\n   * import {assert, fail, assertEquals} from \"https://deno.land/std/testing/asserts.ts\";\n   *\n   * Deno.test({\n   *   name: \"example test\",\n   *   fn(): void {\n   *     assertEquals(\"world\", \"world\");\n   *   },\n   * });\n   *\n   * Deno.test({\n   *   name: \"example ignored test\",\n   *   ignore: Deno.build.os === \"windows\",\n   *   fn(): void {\n   *     // This test is ignored only on Windows machines\n   *   },\n   * });\n   *\n   * Deno.test({\n   *   name: \"example async test\",\n   *   async fn() {\n   *     const decoder = new TextDecoder(\"utf-8\");\n   *     const data = await Deno.readFile(\"hello_world.txt\");\n   *     assertEquals(decoder.decode(data), \"Hello world\");\n   *   }\n   * });\n   * ```\n   */\n  export function test(t: TestDefinition): void;\n\n  /** Register a test which will be run when `deno test` is used on the command\n   * line and the containing module looks like a test module.\n   * `fn` can be async if required.\n   *\n   * ```ts\n   * import {assert, fail, assertEquals} from \"https://deno.land/std/testing/asserts.ts\";\n   *\n   * Deno.test(\"My test description\", ():void => {\n   *   assertEquals(\"hello\", \"hello\");\n   * });\n   *\n   * Deno.test(\"My async test description\", async ():Promise<void> => {\n   *   const decoder = new TextDecoder(\"utf-8\");\n   *   const data = await Deno.readFile(\"hello_world.txt\");\n   *   assertEquals(decoder.decode(data), \"Hello world\");\n   * });\n   * ```\n   * */\n  export function test(name: string, fn: () => void | Promise<void>): void;\n\n  /** Exit the Deno process with optional exit code. If no exit code is supplied\n   * then Deno will exit with return code of 0.\n   *\n   * ```ts\n   * Deno.exit(5);\n   * ```\n   */\n  export function exit(code?: number): never;\n\n  export const env: {\n    /** Retrieve the value of an environment variable. Returns undefined if that\n     * key doesn't exist.\n     *\n     * ```ts\n     * console.log(Deno.env.get(\"HOME\"));  // e.g. outputs \"/home/alice\"\n     * console.log(Deno.env.get(\"MADE_UP_VAR\"));  // outputs \"Undefined\"\n     * ```\n     * Requires `allow-env` permission. */\n    get(key: string): string | undefined;\n\n    /** Set the value of an environment variable.\n     *\n     * ```ts\n     * Deno.env.set(\"SOME_VAR\", \"Value\"));\n     * Deno.env.get(\"SOME_VAR\");  // outputs \"Value\"\n     * ```\n     *\n     * Requires `allow-env` permission. */\n    set(key: string, value: string): void;\n\n    /** Delete the value of an environment variable.\n     *\n     * ```ts\n     * Deno.env.set(\"SOME_VAR\", \"Value\"));\n     * Deno.env.delete(\"SOME_VAR\");  // outputs \"Undefined\"\n     * ```\n     *\n     * Requires `allow-env` permission. */\n    delete(key: string): void;\n\n    /** Returns a snapshot of the environment variables at invocation.\n     *\n     * ```ts\n     * Deno.env.set(\"TEST_VAR\", \"A\");\n     * const myEnv = Deno.env.toObject();\n     * console.log(myEnv.SHELL);\n     * Deno.env.set(\"TEST_VAR\", \"B\");\n     * console.log(myEnv.TEST_VAR);  // outputs \"A\"\n     * ```\n     *\n     * Requires `allow-env` permission. */\n    toObject(): { [index: string]: string };\n  };\n\n  /**\n   * Returns the path to the current deno executable.\n   *\n   * ```ts\n   * console.log(Deno.execPath());  // e.g. \"/home/alice/.local/bin/deno\"\n   * ```\n   *\n   * Requires `allow-read` permission.\n   */\n  export function execPath(): string;\n\n  /**\n   * Change the current working directory to the specified path.\n   *\n   * ```ts\n   * Deno.chdir(\"/home/userA\");\n   * Deno.chdir(\"../userB\");\n   * Deno.chdir(\"C:\\\\Program Files (x86)\\\\Java\");\n   * ```\n   *\n   * Throws `Deno.errors.NotFound` if directory not found.\n   * Throws `Deno.errors.PermissionDenied` if the user does not have access\n   * rights\n   *\n   * Requires --allow-read.\n   */\n  export function chdir(directory: string): void;\n\n  /**\n   * Return a string representing the current working directory.\n   *\n   * If the current directory can be reached via multiple paths (due to symbolic\n   * links), `cwd()` may return any one of them.\n   *\n   * ```ts\n   * const currentWorkingDirectory = Deno.cwd();\n   * ```\n   *\n   * Throws `Deno.errors.NotFound` if directory not available.\n   *\n   * Requires --allow-read\n   */\n  export function cwd(): string;\n\n  /**\n   * Synchronously creates `newpath` as a hard link to `oldpath`.\n   *\n   * ```ts\n   * Deno.linkSync(\"old/name\", \"new/name\");\n   * ```\n   *\n   * Requires `allow-read` and `allow-write` permissions. */\n  export function linkSync(oldpath: string, newpath: string): void;\n\n  /**\n   *\n   * Creates `newpath` as a hard link to `oldpath`.\n   *\n   * ```ts\n   * await Deno.link(\"old/name\", \"new/name\");\n   * ```\n   *\n   * Requires `allow-read` and `allow-write` permissions. */\n  export function link(oldpath: string, newpath: string): Promise<void>;\n\n  export enum SeekMode {\n    Start = 0,\n    Current = 1,\n    End = 2,\n  }\n\n  export interface Reader {\n    /** Reads up to `p.byteLength` bytes into `p`. It resolves to the number of\n     * bytes read (`0` < `n` <= `p.byteLength`) and rejects if any error\n     * encountered. Even if `read()` resolves to `n` < `p.byteLength`, it may\n     * use all of `p` as scratch space during the call. If some data is\n     * available but not `p.byteLength` bytes, `read()` conventionally resolves\n     * to what is available instead of waiting for more.\n     *\n     * When `read()` encounters end-of-file condition, it resolves to EOF\n     * (`null`).\n     *\n     * When `read()` encounters an error, it rejects with an error.\n     *\n     * Callers should always process the `n` > `0` bytes returned before\n     * considering the EOF (`null`). Doing so correctly handles I/O errors that\n     * happen after reading some bytes and also both of the allowed EOF\n     * behaviors.\n     *\n     * Implementations should not retain a reference to `p`.\n     *\n     * Use Deno.iter() to turn a Reader into an AsyncIterator.\n     */\n    read(p: Uint8Array): Promise<number | null>;\n  }\n\n  export interface ReaderSync {\n    /** Reads up to `p.byteLength` bytes into `p`. It resolves to the number\n     * of bytes read (`0` < `n` <= `p.byteLength`) and rejects if any error\n     * encountered. Even if `read()` returns `n` < `p.byteLength`, it may use\n     * all of `p` as scratch space during the call. If some data is available\n     * but not `p.byteLength` bytes, `read()` conventionally returns what is\n     * available instead of waiting for more.\n     *\n     * When `readSync()` encounters end-of-file condition, it returns EOF\n     * (`null`).\n     *\n     * When `readSync()` encounters an error, it throws with an error.\n     *\n     * Callers should always process the `n` > `0` bytes returned before\n     * considering the EOF (`null`). Doing so correctly handles I/O errors that happen\n     * after reading some bytes and also both of the allowed EOF behaviors.\n     *\n     * Implementations should not retain a reference to `p`.\n     *\n     * Use Deno.iterSync() to turn a ReaderSync into an Iterator.\n     */\n    readSync(p: Uint8Array): number | null;\n  }\n\n  export interface Writer {\n    /** Writes `p.byteLength` bytes from `p` to the underlying data stream. It\n     * resolves to the number of bytes written from `p` (`0` <= `n` <=\n     * `p.byteLength`) or reject with the error encountered that caused the\n     * write to stop early. `write()` must reject with a non-null error if\n     * would resolve to `n` < `p.byteLength`. `write()` must not modify the\n     * slice data, even temporarily.\n     *\n     * Implementations should not retain a reference to `p`.\n     */\n    write(p: Uint8Array): Promise<number>;\n  }\n\n  export interface WriterSync {\n    /** Writes `p.byteLength` bytes from `p` to the underlying data\n     * stream. It returns the number of bytes written from `p` (`0` <= `n`\n     * <= `p.byteLength`) and any error encountered that caused the write to\n     * stop early. `writeSync()` must throw a non-null error if it returns `n` <\n     * `p.byteLength`. `writeSync()` must not modify the slice data, even\n     * temporarily.\n     *\n     * Implementations should not retain a reference to `p`.\n     */\n    writeSync(p: Uint8Array): number;\n  }\n\n  export interface Closer {\n    close(): void;\n  }\n\n  export interface Seeker {\n    /** Seek sets the offset for the next `read()` or `write()` to offset,\n     * interpreted according to `whence`: `Start` means relative to the\n     * start of the file, `Current` means relative to the current offset,\n     * and `End` means relative to the end. Seek resolves to the new offset\n     * relative to the start of the file.\n     *\n     * Seeking to an offset before the start of the file is an error. Seeking to\n     * any positive offset is legal, but the behavior of subsequent I/O\n     * operations on the underlying object is implementation-dependent.\n     * It returns the number of cursor position.\n     */\n    seek(offset: number, whence: SeekMode): Promise<number>;\n  }\n\n  export interface SeekerSync {\n    /** Seek sets the offset for the next `readSync()` or `writeSync()` to\n     * offset, interpreted according to `whence`: `Start` means relative\n     * to the start of the file, `Current` means relative to the current\n     * offset, and `End` means relative to the end.\n     *\n     * Seeking to an offset before the start of the file is an error. Seeking to\n     * any positive offset is legal, but the behavior of subsequent I/O\n     * operations on the underlying object is implementation-dependent.\n     */\n    seekSync(offset: number, whence: SeekMode): number;\n  }\n\n  /** Copies from `src` to `dst` until either EOF (`null`) is read from `src` or\n   * an error occurs. It resolves to the number of bytes copied or rejects with\n   * the first error encountered while copying.\n   *\n   * ```ts\n   * const source = await Deno.open(\"my_file.txt\");\n   * const buffer = new Deno.Buffer()\n   * const bytesCopied1 = await Deno.copy(source, Deno.stdout);\n   * const bytesCopied2 = await Deno.copy(source, buffer);\n   * ```\n   *\n   * @param src The source to copy from\n   * @param dst The destination to copy to\n   * @param options Can be used to tune size of the buffer. Default size is 32kB\n   */\n  export function copy(\n    src: Reader,\n    dst: Writer,\n    options?: {\n      bufSize?: number;\n    },\n  ): Promise<number>;\n\n  /** Turns a Reader, `r`, into an async iterator.\n   *\n   * ```ts\n   * let f = await Deno.open(\"/etc/passwd\");\n   * for await (const chunk of Deno.iter(f)) {\n   *   console.log(chunk);\n   * }\n   * f.close();\n   * ```\n   *\n   * Second argument can be used to tune size of a buffer.\n   * Default size of the buffer is 32kB.\n   *\n   * ```ts\n   * let f = await Deno.open(\"/etc/passwd\");\n   * const iter = Deno.iter(f, {\n   *   bufSize: 1024 * 1024\n   * });\n   * for await (const chunk of iter) {\n   *   console.log(chunk);\n   * }\n   * f.close();\n   * ```\n   *\n   * Iterator uses an internal buffer of fixed size for efficiency; it returns\n   * a view on that buffer on each iteration. It is therefore caller's\n   * responsibility to copy contents of the buffer if needed; otherwise the\n   * next iteration will overwrite contents of previously returned chunk.\n   */\n  export function iter(\n    r: Reader,\n    options?: {\n      bufSize?: number;\n    },\n  ): AsyncIterableIterator<Uint8Array>;\n\n  /** Turns a ReaderSync, `r`, into an iterator.\n   *\n   * ```ts\n   * let f = Deno.openSync(\"/etc/passwd\");\n   * for (const chunk of Deno.iterSync(f)) {\n   *   console.log(chunk);\n   * }\n   * f.close();\n   * ```\n   *\n   * Second argument can be used to tune size of a buffer.\n   * Default size of the buffer is 32kB.\n   *\n   * ```ts\n   * let f = await Deno.open(\"/etc/passwd\");\n   * const iter = Deno.iterSync(f, {\n   *   bufSize: 1024 * 1024\n   * });\n   * for (const chunk of iter) {\n   *   console.log(chunk);\n   * }\n   * f.close();\n   * ```\n   *\n   * Iterator uses an internal buffer of fixed size for efficiency; it returns\n   * a view on that buffer on each iteration. It is therefore caller's\n   * responsibility to copy contents of the buffer if needed; otherwise the\n   * next iteration will overwrite contents of previously returned chunk.\n   */\n  export function iterSync(\n    r: ReaderSync,\n    options?: {\n      bufSize?: number;\n    },\n  ): IterableIterator<Uint8Array>;\n\n  /** Synchronously open a file and return an instance of `Deno.File`.  The\n   * file does not need to previously exist if using the `create` or `createNew`\n   * open options.  It is the callers responsibility to close the file when finished\n   * with it.\n   *\n   * ```ts\n   * const file = Deno.openSync(\"/foo/bar.txt\", { read: true, write: true });\n   * // Do work with file\n   * Deno.close(file.rid);\n   * ```\n   *\n   * Requires `allow-read` and/or `allow-write` permissions depending on options.\n   */\n  export function openSync(path: string | URL, options?: OpenOptions): File;\n\n  /** Open a file and resolve to an instance of `Deno.File`.  The\n   * file does not need to previously exist if using the `create` or `createNew`\n   * open options.  It is the callers responsibility to close the file when finished\n   * with it.\n   *\n   * ```ts\n   * const file = await Deno.open(\"/foo/bar.txt\", { read: true, write: true });\n   * // Do work with file\n   * Deno.close(file.rid);\n   * ```\n   *\n   * Requires `allow-read` and/or `allow-write` permissions depending on options.\n   */\n  export function open(\n    path: string | URL,\n    options?: OpenOptions,\n  ): Promise<File>;\n\n  /** Creates a file if none exists or truncates an existing file and returns\n   *  an instance of `Deno.File`.\n   *\n   * ```ts\n   * const file = Deno.createSync(\"/foo/bar.txt\");\n   * ```\n   *\n   * Requires `allow-read` and `allow-write` permissions.\n   */\n  export function createSync(path: string | URL): File;\n\n  /** Creates a file if none exists or truncates an existing file and resolves to\n   *  an instance of `Deno.File`.\n   *\n   * ```ts\n   * const file = await Deno.create(\"/foo/bar.txt\");\n   * ```\n   *\n   * Requires `allow-read` and `allow-write` permissions.\n   */\n  export function create(path: string | URL): Promise<File>;\n\n  /** Synchronously read from a resource ID (`rid`) into an array buffer (`buffer`).\n   *\n   * Returns either the number of bytes read during the operation or EOF\n   * (`null`) if there was nothing more to read.\n   *\n   * It is possible for a read to successfully return with `0` bytes. This does\n   * not indicate EOF.\n   *\n   * This function is one of the lowest level APIs and most users should not\n   * work with this directly, but rather use Deno.readAllSync() instead.\n   *\n   * **It is not guaranteed that the full buffer will be read in a single call.**\n   *\n   * ```ts\n   * // if \"/foo/bar.txt\" contains the text \"hello world\":\n   * const file = Deno.openSync(\"/foo/bar.txt\");\n   * const buf = new Uint8Array(100);\n   * const numberOfBytesRead = Deno.readSync(file.rid, buf); // 11 bytes\n   * const text = new TextDecoder().decode(buf);  // \"hello world\"\n   * Deno.close(file.rid);\n   * ```\n   */\n  export function readSync(rid: number, buffer: Uint8Array): number | null;\n\n  /** Read from a resource ID (`rid`) into an array buffer (`buffer`).\n   *\n   * Resolves to either the number of bytes read during the operation or EOF\n   * (`null`) if there was nothing more to read.\n   *\n   * It is possible for a read to successfully return with `0` bytes. This does\n   * not indicate EOF.\n   *\n   * This function is one of the lowest level APIs and most users should not\n   * work with this directly, but rather use Deno.readAll() instead.\n   *\n   * **It is not guaranteed that the full buffer will be read in a single call.**\n   *\n   * ```ts\n   * // if \"/foo/bar.txt\" contains the text \"hello world\":\n   * const file = await Deno.open(\"/foo/bar.txt\");\n   * const buf = new Uint8Array(100);\n   * const numberOfBytesRead = await Deno.read(file.rid, buf); // 11 bytes\n   * const text = new TextDecoder().decode(buf);  // \"hello world\"\n   * Deno.close(file.rid);\n   * ```\n   */\n  export function read(rid: number, buffer: Uint8Array): Promise<number | null>;\n\n  /** Synchronously write to the resource ID (`rid`) the contents of the array\n   * buffer (`data`).\n   *\n   * Returns the number of bytes written.  This function is one of the lowest\n   * level APIs and most users should not work with this directly, but rather use\n   * Deno.writeAllSync() instead.\n   *\n   * **It is not guaranteed that the full buffer will be written in a single\n   * call.**\n   *\n   * ```ts\n   * const encoder = new TextEncoder();\n   * const data = encoder.encode(\"Hello world\");\n   * const file = Deno.openSync(\"/foo/bar.txt\", {write: true});\n   * const bytesWritten = Deno.writeSync(file.rid, data); // 11\n   * Deno.close(file.rid);\n   * ```\n   */\n  export function writeSync(rid: number, data: Uint8Array): number;\n\n  /** Write to the resource ID (`rid`) the contents of the array buffer (`data`).\n   *\n   * Resolves to the number of bytes written.  This function is one of the lowest\n   * level APIs and most users should not work with this directly, but rather use\n   * Deno.writeAll() instead.\n   *\n   * **It is not guaranteed that the full buffer will be written in a single\n   * call.**\n   *\n   * ```ts\n   * const encoder = new TextEncoder();\n   * const data = encoder.encode(\"Hello world\");\n   * const file = await Deno.open(\"/foo/bar.txt\", { write: true });\n   * const bytesWritten = await Deno.write(file.rid, data); // 11\n   * Deno.close(file.rid);\n   * ```\n   */\n  export function write(rid: number, data: Uint8Array): Promise<number>;\n\n  /** Synchronously seek a resource ID (`rid`) to the given `offset` under mode\n   * given by `whence`.  The new position within the resource (bytes from the\n   * start) is returned.\n   *\n   * ```ts\n   * const file = Deno.openSync('hello.txt', {read: true, write: true, truncate: true, create: true});\n   * Deno.writeSync(file.rid, new TextEncoder().encode(\"Hello world\"));\n   * // advance cursor 6 bytes\n   * const cursorPosition = Deno.seekSync(file.rid, 6, Deno.SeekMode.Start);\n   * console.log(cursorPosition);  // 6\n   * const buf = new Uint8Array(100);\n   * file.readSync(buf);\n   * console.log(new TextDecoder().decode(buf)); // \"world\"\n   * ```\n   *\n   * The seek modes work as follows:\n   *\n   * ```ts\n   * // Given file.rid pointing to file with \"Hello world\", which is 11 bytes long:\n   * // Seek 6 bytes from the start of the file\n   * console.log(Deno.seekSync(file.rid, 6, Deno.SeekMode.Start)); // \"6\"\n   * // Seek 2 more bytes from the current position\n   * console.log(Deno.seekSync(file.rid, 2, Deno.SeekMode.Current)); // \"8\"\n   * // Seek backwards 2 bytes from the end of the file\n   * console.log(Deno.seekSync(file.rid, -2, Deno.SeekMode.End)); // \"9\" (e.g. 11-2)\n   * ```\n   */\n  export function seekSync(\n    rid: number,\n    offset: number,\n    whence: SeekMode,\n  ): number;\n\n  /** Seek a resource ID (`rid`) to the given `offset` under mode given by `whence`.\n   * The call resolves to the new position within the resource (bytes from the start).\n   *\n   * ```ts\n   * const file = await Deno.open('hello.txt', {read: true, write: true, truncate: true, create: true});\n   * await Deno.write(file.rid, new TextEncoder().encode(\"Hello world\"));\n   * // advance cursor 6 bytes\n   * const cursorPosition = await Deno.seek(file.rid, 6, Deno.SeekMode.Start);\n   * console.log(cursorPosition);  // 6\n   * const buf = new Uint8Array(100);\n   * await file.read(buf);\n   * console.log(new TextDecoder().decode(buf)); // \"world\"\n   * ```\n   *\n   * The seek modes work as follows:\n   *\n   * ```ts\n   * // Given file.rid pointing to file with \"Hello world\", which is 11 bytes long:\n   * // Seek 6 bytes from the start of the file\n   * console.log(await Deno.seek(file.rid, 6, Deno.SeekMode.Start)); // \"6\"\n   * // Seek 2 more bytes from the current position\n   * console.log(await Deno.seek(file.rid, 2, Deno.SeekMode.Current)); // \"8\"\n   * // Seek backwards 2 bytes from the end of the file\n   * console.log(await Deno.seek(file.rid, -2, Deno.SeekMode.End)); // \"9\" (e.g. 11-2)\n   * ```\n   */\n  export function seek(\n    rid: number,\n    offset: number,\n    whence: SeekMode,\n  ): Promise<number>;\n\n  /**\n   * Synchronously flushes any pending data and metadata operations of the given file stream to disk.\n   *  ```ts\n   * const file = Deno.openSync(\"my_file.txt\", { read: true, write: true, create: true });\n   * Deno.writeSync(file.rid, new TextEncoder().encode(\"Hello World\"));\n   * Deno.ftruncateSync(file.rid, 1);\n   * Deno.fsyncSync(file.rid);\n   * console.log(new TextDecoder().decode(Deno.readFileSync(\"my_file.txt\"))); // H\n   * ```\n   */\n  export function fsyncSync(rid: number): void;\n\n  /**\n   * Flushes any pending data and metadata operations of the given file stream to disk.\n   *  ```ts\n   * const file = await Deno.open(\"my_file.txt\", { read: true, write: true, create: true });\n   * await Deno.write(file.rid, new TextEncoder().encode(\"Hello World\"));\n   * await Deno.ftruncate(file.rid, 1);\n   * await Deno.fsync(file.rid);\n   * console.log(new TextDecoder().decode(await Deno.readFile(\"my_file.txt\"))); // H\n   * ```\n   */\n  export function fsync(rid: number): Promise<void>;\n\n  /*\n   * Synchronously flushes any pending data operations of the given file stream to disk.\n   *  ```ts\n   * const file = Deno.openSync(\"my_file.txt\", { read: true, write: true, create: true });\n   * Deno.writeSync(file.rid, new TextEncoder().encode(\"Hello World\"));\n   * Deno.fdatasyncSync(file.rid);\n   * console.log(new TextDecoder().decode(Deno.readFileSync(\"my_file.txt\"))); // Hello World\n   * ```\n   */\n  export function fdatasyncSync(rid: number): void;\n\n  /**\n   * Flushes any pending data operations of the given file stream to disk.\n   *  ```ts\n   * const file = await Deno.open(\"my_file.txt\", { read: true, write: true, create: true });\n   * await Deno.write(file.rid, new TextEncoder().encode(\"Hello World\"));\n   * await Deno.fdatasync(file.rid);\n   * console.log(new TextDecoder().decode(await Deno.readFile(\"my_file.txt\"))); // Hello World\n   * ```\n   */\n  export function fdatasync(rid: number): Promise<void>;\n\n  /** Close the given resource ID (rid) which has been previously opened, such\n   * as via opening or creating a file.  Closing a file when you are finished\n   * with it is important to avoid leaking resources.\n   *\n   * ```ts\n   * const file = await Deno.open(\"my_file.txt\");\n   * // do work with \"file\" object\n   * Deno.close(file.rid);\n   * ````\n   */\n  export function close(rid: number): void;\n\n  /** The Deno abstraction for reading and writing files. */\n  export class File\n    implements\n      Reader,\n      ReaderSync,\n      Writer,\n      WriterSync,\n      Seeker,\n      SeekerSync,\n      Closer {\n    readonly rid: number;\n    constructor(rid: number);\n    write(p: Uint8Array): Promise<number>;\n    writeSync(p: Uint8Array): number;\n    read(p: Uint8Array): Promise<number | null>;\n    readSync(p: Uint8Array): number | null;\n    seek(offset: number, whence: SeekMode): Promise<number>;\n    seekSync(offset: number, whence: SeekMode): number;\n    close(): void;\n  }\n\n  /** A handle for `stdin`. */\n  export const stdin: Reader & ReaderSync & Closer & { readonly rid: number };\n  /** A handle for `stdout`. */\n  export const stdout: Writer & WriterSync & Closer & { readonly rid: number };\n  /** A handle for `stderr`. */\n  export const stderr: Writer & WriterSync & Closer & { readonly rid: number };\n\n  export interface OpenOptions {\n    /** Sets the option for read access. This option, when `true`, means that the\n     * file should be read-able if opened. */\n    read?: boolean;\n    /** Sets the option for write access. This option, when `true`, means that\n     * the file should be write-able if opened. If the file already exists,\n     * any write calls on it will overwrite its contents, by default without\n     * truncating it. */\n    write?: boolean;\n    /**Sets the option for the append mode. This option, when `true`, means that\n     * writes will append to a file instead of overwriting previous contents.\n     * Note that setting `{ write: true, append: true }` has the same effect as\n     * setting only `{ append: true }`. */\n    append?: boolean;\n    /** Sets the option for truncating a previous file. If a file is\n     * successfully opened with this option set it will truncate the file to `0`\n     * size if it already exists. The file must be opened with write access\n     * for truncate to work. */\n    truncate?: boolean;\n    /** Sets the option to allow creating a new file, if one doesn't already\n     * exist at the specified path. Requires write or append access to be\n     * used. */\n    create?: boolean;\n    /** Defaults to `false`. If set to `true`, no file, directory, or symlink is\n     * allowed to exist at the target location. Requires write or append\n     * access to be used. When createNew is set to `true`, create and truncate\n     * are ignored. */\n    createNew?: boolean;\n    /** Permissions to use if creating the file (defaults to `0o666`, before\n     * the process's umask).\n     * Ignored on Windows. */\n    mode?: number;\n  }\n\n  /**\n   *\n   *  Check if a given resource id (`rid`) is a TTY.\n   *\n   * ```ts\n   * // This example is system and context specific\n   * const nonTTYRid = Deno.openSync(\"my_file.txt\").rid;\n   * const ttyRid = Deno.openSync(\"/dev/tty6\").rid;\n   * console.log(Deno.isatty(nonTTYRid)); // false\n   * console.log(Deno.isatty(ttyRid)); // true\n   * Deno.close(nonTTYRid);\n   * Deno.close(ttyRid);\n   * ```\n   */\n  export function isatty(rid: number): boolean;\n\n  /** A variable-sized buffer of bytes with `read()` and `write()` methods.\n   *\n   * Deno.Buffer is almost always used with some I/O like files and sockets. It\n   * allows one to buffer up a download from a socket. Buffer grows and shrinks\n   * as necessary.\n   *\n   * Deno.Buffer is NOT the same thing as Node's Buffer. Node's Buffer was\n   * created in 2009 before JavaScript had the concept of ArrayBuffers. It's\n   * simply a non-standard ArrayBuffer.\n   *\n   * ArrayBuffer is a fixed memory allocation. Deno.Buffer is implemented on top\n   * of ArrayBuffer.\n   *\n   * Based on [Go Buffer](https://golang.org/pkg/bytes/#Buffer). */\n  export class Buffer implements Reader, ReaderSync, Writer, WriterSync {\n    constructor(ab?: ArrayBuffer);\n    /** Returns a slice holding the unread portion of the buffer.\n     *\n     * The slice is valid for use only until the next buffer modification (that\n     * is, only until the next call to a method like `read()`, `write()`,\n     * `reset()`, or `truncate()`). If `options.copy` is false the slice aliases the buffer content at\n     * least until the next buffer modification, so immediate changes to the\n     * slice will affect the result of future reads.\n     * @param options Defaults to `{ copy: true }`\n     */\n    bytes(options?: { copy?: boolean }): Uint8Array;\n    /** Returns whether the unread portion of the buffer is empty. */\n    empty(): boolean;\n    /** A read only number of bytes of the unread portion of the buffer. */\n    readonly length: number;\n    /** The read only capacity of the buffer's underlying byte slice, that is,\n     * the total space allocated for the buffer's data. */\n    readonly capacity: number;\n    /** Discards all but the first `n` unread bytes from the buffer but\n     * continues to use the same allocated storage. It throws if `n` is\n     * negative or greater than the length of the buffer. */\n    truncate(n: number): void;\n    /** Resets the buffer to be empty, but it retains the underlying storage for\n     * use by future writes. `.reset()` is the same as `.truncate(0)`. */\n    reset(): void;\n    /** Reads the next `p.length` bytes from the buffer or until the buffer is\n     * drained. Returns the number of bytes read. If the buffer has no data to\n     * return, the return is EOF (`null`). */\n    readSync(p: Uint8Array): number | null;\n    /** Reads the next `p.length` bytes from the buffer or until the buffer is\n     * drained. Resolves to the number of bytes read. If the buffer has no\n     * data to return, resolves to EOF (`null`).\n     *\n     * NOTE: This methods reads bytes synchronously; it's provided for\n     * compatibility with `Reader` interfaces.\n     */\n    read(p: Uint8Array): Promise<number | null>;\n    writeSync(p: Uint8Array): number;\n    /** NOTE: This methods writes bytes synchronously; it's provided for\n     * compatibility with `Writer` interface. */\n    write(p: Uint8Array): Promise<number>;\n    /** Grows the buffer's capacity, if necessary, to guarantee space for\n     * another `n` bytes. After `.grow(n)`, at least `n` bytes can be written to\n     * the buffer without another allocation. If `n` is negative, `.grow()` will\n     * throw. If the buffer can't grow it will throw an error.\n     *\n     * Based on Go Lang's\n     * [Buffer.Grow](https://golang.org/pkg/bytes/#Buffer.Grow). */\n    grow(n: number): void;\n    /** Reads data from `r` until EOF (`null`) and appends it to the buffer,\n     * growing the buffer as needed. It resolves to the number of bytes read.\n     * If the buffer becomes too large, `.readFrom()` will reject with an error.\n     *\n     * Based on Go Lang's\n     * [Buffer.ReadFrom](https://golang.org/pkg/bytes/#Buffer.ReadFrom). */\n    readFrom(r: Reader): Promise<number>;\n    /** Reads data from `r` until EOF (`null`) and appends it to the buffer,\n     * growing the buffer as needed. It returns the number of bytes read. If the\n     * buffer becomes too large, `.readFromSync()` will throw an error.\n     *\n     * Based on Go Lang's\n     * [Buffer.ReadFrom](https://golang.org/pkg/bytes/#Buffer.ReadFrom). */\n    readFromSync(r: ReaderSync): number;\n  }\n\n  /** Read Reader `r` until EOF (`null`) and resolve to the content as\n   * Uint8Array`.\n   *\n   * ```ts\n   * // Example from stdin\n   * const stdinContent = await Deno.readAll(Deno.stdin);\n   *\n   * // Example from file\n   * const file = await Deno.open(\"my_file.txt\", {read: true});\n   * const myFileContent = await Deno.readAll(file);\n   * Deno.close(file.rid);\n   *\n   * // Example from buffer\n   * const myData = new Uint8Array(100);\n   * // ... fill myData array with data\n   * const reader = new Deno.Buffer(myData.buffer as ArrayBuffer);\n   * const bufferContent = await Deno.readAll(reader);\n   * ```\n   */\n  export function readAll(r: Reader): Promise<Uint8Array>;\n\n  /** Synchronously reads Reader `r` until EOF (`null`) and returns the content\n   * as `Uint8Array`.\n   *\n   * ```ts\n   * // Example from stdin\n   * const stdinContent = Deno.readAllSync(Deno.stdin);\n   *\n   * // Example from file\n   * const file = Deno.openSync(\"my_file.txt\", {read: true});\n   * const myFileContent = Deno.readAllSync(file);\n   * Deno.close(file.rid);\n   *\n   * // Example from buffer\n   * const myData = new Uint8Array(100);\n   * // ... fill myData array with data\n   * const reader = new Deno.Buffer(myData.buffer as ArrayBuffer);\n   * const bufferContent = Deno.readAllSync(reader);\n   * ```\n   */\n  export function readAllSync(r: ReaderSync): Uint8Array;\n\n  /** Write all the content of the array buffer (`arr`) to the writer (`w`).\n   *\n   * ```ts\n   * // Example writing to stdout\n   * const contentBytes = new TextEncoder().encode(\"Hello World\");\n   * await Deno.writeAll(Deno.stdout, contentBytes);\n   *\n   * // Example writing to file\n   * const contentBytes = new TextEncoder().encode(\"Hello World\");\n   * const file = await Deno.open('test.file', {write: true});\n   * await Deno.writeAll(file, contentBytes);\n   * Deno.close(file.rid);\n   *\n   * // Example writing to buffer\n   * const contentBytes = new TextEncoder().encode(\"Hello World\");\n   * const writer = new Deno.Buffer();\n   * await Deno.writeAll(writer, contentBytes);\n   * console.log(writer.bytes().length);  // 11\n   * ```\n   */\n  export function writeAll(w: Writer, arr: Uint8Array): Promise<void>;\n\n  /** Synchronously write all the content of the array buffer (`arr`) to the\n   * writer (`w`).\n   *\n   * ```ts\n   * // Example writing to stdout\n   * const contentBytes = new TextEncoder().encode(\"Hello World\");\n   * Deno.writeAllSync(Deno.stdout, contentBytes);\n   *\n   * // Example writing to file\n   * const contentBytes = new TextEncoder().encode(\"Hello World\");\n   * const file = Deno.openSync('test.file', {write: true});\n   * Deno.writeAllSync(file, contentBytes);\n   * Deno.close(file.rid);\n   *\n   * // Example writing to buffer\n   * const contentBytes = new TextEncoder().encode(\"Hello World\");\n   * const writer = new Deno.Buffer();\n   * Deno.writeAllSync(writer, contentBytes);\n   * console.log(writer.bytes().length);  // 11\n   * ```\n   */\n  export function writeAllSync(w: WriterSync, arr: Uint8Array): void;\n\n  export interface MkdirOptions {\n    /** Defaults to `false`. If set to `true`, means that any intermediate\n     * directories will also be created (as with the shell command `mkdir -p`).\n     * Intermediate directories are created with the same permissions.\n     * When recursive is set to `true`, succeeds silently (without changing any\n     * permissions) if a directory already exists at the path, or if the path\n     * is a symlink to an existing directory. */\n    recursive?: boolean;\n    /** Permissions to use when creating the directory (defaults to `0o777`,\n     * before the process's umask).\n     * Ignored on Windows. */\n    mode?: number;\n  }\n\n  /** Synchronously creates a new directory with the specified path.\n   *\n   * ```ts\n   * Deno.mkdirSync(\"new_dir\");\n   * Deno.mkdirSync(\"nested/directories\", { recursive: true });\n   * Deno.mkdirSync(\"restricted_access_dir\", { mode: 0o700 });\n   * ```\n   *\n   * Defaults to throwing error if the directory already exists.\n   *\n   * Requires `allow-write` permission. */\n  export function mkdirSync(path: string | URL, options?: MkdirOptions): void;\n\n  /** Creates a new directory with the specified path.\n   *\n   * ```ts\n   * await Deno.mkdir(\"new_dir\");\n   * await Deno.mkdir(\"nested/directories\", { recursive: true });\n   * await Deno.mkdir(\"restricted_access_dir\", { mode: 0o700 });\n   * ```\n   *\n   * Defaults to throwing error if the directory already exists.\n   *\n   * Requires `allow-write` permission. */\n  export function mkdir(\n    path: string | URL,\n    options?: MkdirOptions,\n  ): Promise<void>;\n\n  export interface MakeTempOptions {\n    /** Directory where the temporary directory should be created (defaults to\n     * the env variable TMPDIR, or the system's default, usually /tmp).\n     *\n     * Note that if the passed `dir` is relative, the path returned by\n     * makeTempFile() and makeTempDir() will also be relative. Be mindful of\n     * this when changing working directory. */\n    dir?: string;\n    /** String that should precede the random portion of the temporary\n     * directory's name. */\n    prefix?: string;\n    /** String that should follow the random portion of the temporary\n     * directory's name. */\n    suffix?: string;\n  }\n\n  /** Synchronously creates a new temporary directory in the default directory\n   * for temporary files, unless `dir` is specified. Other optional options\n   * include prefixing and suffixing the directory name with `prefix` and\n   * `suffix` respectively.\n   *\n   * The full path to the newly created directory is returned.\n   *\n   * Multiple programs calling this function simultaneously will create different\n   * directories. It is the caller's responsibility to remove the directory when\n   * no longer needed.\n   *\n   * ```ts\n   * const tempDirName0 = Deno.makeTempDirSync();  // e.g. /tmp/2894ea76\n   * const tempDirName1 = Deno.makeTempDirSync({ prefix: 'my_temp' });  // e.g. /tmp/my_temp339c944d\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  // TODO(ry) Doesn't check permissions.\n  export function makeTempDirSync(options?: MakeTempOptions): string;\n\n  /** Creates a new temporary directory in the default directory for temporary\n   * files, unless `dir` is specified. Other optional options include\n   * prefixing and suffixing the directory name with `prefix` and `suffix`\n   * respectively.\n   *\n   * This call resolves to the full path to the newly created directory.\n   *\n   * Multiple programs calling this function simultaneously will create different\n   * directories. It is the caller's responsibility to remove the directory when\n   * no longer needed.\n   *\n   * ```ts\n   * const tempDirName0 = await Deno.makeTempDir();  // e.g. /tmp/2894ea76\n   * const tempDirName1 = await Deno.makeTempDir({ prefix: 'my_temp' }); // e.g. /tmp/my_temp339c944d\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  // TODO(ry) Doesn't check permissions.\n  export function makeTempDir(options?: MakeTempOptions): Promise<string>;\n\n  /** Synchronously creates a new temporary file in the default directory for\n   * temporary files, unless `dir` is specified.\n   * Other optional options include prefixing and suffixing the directory name\n   * with `prefix` and `suffix` respectively.\n   *\n   * The full path to the newly created file is returned.\n   *\n   * Multiple programs calling this function simultaneously will create different\n   * files. It is the caller's responsibility to remove the file when no longer\n   * needed.\n   *\n   * ```ts\n   * const tempFileName0 = Deno.makeTempFileSync(); // e.g. /tmp/419e0bf2\n   * const tempFileName1 = Deno.makeTempFileSync({ prefix: 'my_temp' });  // e.g. /tmp/my_temp754d3098\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  export function makeTempFileSync(options?: MakeTempOptions): string;\n\n  /** Creates a new temporary file in the default directory for temporary\n   * files, unless `dir` is specified.  Other\n   * optional options include prefixing and suffixing the directory name with\n   * `prefix` and `suffix` respectively.\n   *\n   * This call resolves to the full path to the newly created file.\n   *\n   * Multiple programs calling this function simultaneously will create different\n   * files. It is the caller's responsibility to remove the file when no longer\n   * needed.\n   *\n   * ```ts\n   * const tmpFileName0 = await Deno.makeTempFile();  // e.g. /tmp/419e0bf2\n   * const tmpFileName1 = await Deno.makeTempFile({ prefix: 'my_temp' });  // e.g. /tmp/my_temp754d3098\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  export function makeTempFile(options?: MakeTempOptions): Promise<string>;\n\n  /** Synchronously changes the permission of a specific file/directory of\n   * specified path.  Ignores the process's umask.\n   *\n   * ```ts\n   * Deno.chmodSync(\"/path/to/file\", 0o666);\n   * ```\n   *\n   * For a full description, see [chmod](#Deno.chmod)\n   *\n   * NOTE: This API currently throws on Windows\n   *\n   * Requires `allow-write` permission. */\n  export function chmodSync(path: string | URL, mode: number): void;\n\n  /** Changes the permission of a specific file/directory of specified path.\n   * Ignores the process's umask.\n   *\n   * ```ts\n   * await Deno.chmod(\"/path/to/file\", 0o666);\n   * ```\n   *\n   * The mode is a sequence of 3 octal numbers.  The first/left-most number\n   * specifies the permissions for the owner.  The second number specifies the\n   * permissions for the group. The last/right-most number specifies the\n   * permissions for others.  For example, with a mode of 0o764, the owner (7) can\n   * read/write/execute, the group (6) can read/write and everyone else (4) can\n   * read only.\n   *\n   * | Number | Description |\n   * | ------ | ----------- |\n   * | 7      | read, write, and execute |\n   * | 6      | read and write |\n   * | 5      | read and execute |\n   * | 4      | read only |\n   * | 3      | write and execute |\n   * | 2      | write only |\n   * | 1      | execute only |\n   * | 0      | no permission |\n   *\n   * NOTE: This API currently throws on Windows\n   *\n   * Requires `allow-write` permission. */\n  export function chmod(path: string | URL, mode: number): Promise<void>;\n\n  /** Synchronously change owner of a regular file or directory. This functionality\n   * is not available on Windows.\n   *\n   * ```ts\n   * Deno.chownSync(\"myFile.txt\", 1000, 1002);\n   * ```\n   *\n   * Requires `allow-write` permission.\n   *\n   * Throws Error (not implemented) if executed on Windows\n   *\n   * @param path path to the file\n   * @param uid user id (UID) of the new owner, or `null` for no change\n   * @param gid group id (GID) of the new owner, or `null` for no change\n   */\n  export function chownSync(\n    path: string | URL,\n    uid: number | null,\n    gid: number | null,\n  ): void;\n\n  /** Change owner of a regular file or directory. This functionality\n   * is not available on Windows.\n   *\n   * ```ts\n   * await Deno.chown(\"myFile.txt\", 1000, 1002);\n   * ```\n   *\n   * Requires `allow-write` permission.\n   *\n   * Throws Error (not implemented) if executed on Windows\n   *\n   * @param path path to the file\n   * @param uid user id (UID) of the new owner, or `null` for no change\n   * @param gid group id (GID) of the new owner, or `null` for no change\n   */\n  export function chown(\n    path: string | URL,\n    uid: number | null,\n    gid: number | null,\n  ): Promise<void>;\n\n  export interface RemoveOptions {\n    /** Defaults to `false`. If set to `true`, path will be removed even if\n     * it's a non-empty directory. */\n    recursive?: boolean;\n  }\n\n  /** Synchronously removes the named file or directory.\n   *\n   * ```ts\n   * Deno.removeSync(\"/path/to/empty_dir/or/file\");\n   * Deno.removeSync(\"/path/to/populated_dir/or/file\", { recursive: true });\n   * ```\n   *\n   * Throws error if permission denied, path not found, or path is a non-empty\n   * directory and the `recursive` option isn't set to `true`.\n   *\n   * Requires `allow-write` permission. */\n  export function removeSync(path: string | URL, options?: RemoveOptions): void;\n\n  /** Removes the named file or directory.\n   *\n   * ```ts\n   * await Deno.remove(\"/path/to/empty_dir/or/file\");\n   * await Deno.remove(\"/path/to/populated_dir/or/file\", { recursive: true });\n   * ```\n   *\n   * Throws error if permission denied, path not found, or path is a non-empty\n   * directory and the `recursive` option isn't set to `true`.\n   *\n   * Requires `allow-write` permission. */\n  export function remove(\n    path: string | URL,\n    options?: RemoveOptions,\n  ): Promise<void>;\n\n  /** Synchronously renames (moves) `oldpath` to `newpath`. Paths may be files or\n   * directories.  If `newpath` already exists and is not a directory,\n   * `renameSync()` replaces it. OS-specific restrictions may apply when\n   * `oldpath` and `newpath` are in different directories.\n   *\n   * ```ts\n   * Deno.renameSync(\"old/path\", \"new/path\");\n   * ```\n   *\n   * On Unix, this operation does not follow symlinks at either path.\n   *\n   * It varies between platforms when the operation throws errors, and if so what\n   * they are. It's always an error to rename anything to a non-empty directory.\n   *\n   * Requires `allow-read` and `allow-write` permissions. */\n  export function renameSync(oldpath: string, newpath: string): void;\n\n  /** Renames (moves) `oldpath` to `newpath`.  Paths may be files or directories.\n   * If `newpath` already exists and is not a directory, `rename()` replaces it.\n   * OS-specific restrictions may apply when `oldpath` and `newpath` are in\n   * different directories.\n   *\n   * ```ts\n   * await Deno.rename(\"old/path\", \"new/path\");\n   * ```\n   *\n   * On Unix, this operation does not follow symlinks at either path.\n   *\n   * It varies between platforms when the operation throws errors, and if so what\n   * they are. It's always an error to rename anything to a non-empty directory.\n   *\n   * Requires `allow-read` and `allow-write` permission. */\n  export function rename(oldpath: string, newpath: string): Promise<void>;\n\n  /** Synchronously reads and returns the entire contents of a file as utf8\n   *  encoded string. Reading a directory throws an error.\n   *\n   * ```ts\n   * const data = Deno.readTextFileSync(\"hello.txt\");\n   * console.log(data);\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function readTextFileSync(path: string | URL): string;\n\n  /** Asynchronously reads and returns the entire contents of a file as utf8\n   *  encoded string. Reading a directory throws an error.\n   *\n   * ```ts\n   * const data = await Deno.readTextFile(\"hello.txt\");\n   * console.log(data);\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function readTextFile(path: string | URL): Promise<string>;\n\n  /** Synchronously reads and returns the entire contents of a file as an array\n   * of bytes. `TextDecoder` can be used to transform the bytes to string if\n   * required.  Reading a directory returns an empty data array.\n   *\n   * ```ts\n   * const decoder = new TextDecoder(\"utf-8\");\n   * const data = Deno.readFileSync(\"hello.txt\");\n   * console.log(decoder.decode(data));\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function readFileSync(path: string | URL): Uint8Array;\n\n  /** Reads and resolves to the entire contents of a file as an array of bytes.\n   * `TextDecoder` can be used to transform the bytes to string if required.\n   * Reading a directory returns an empty data array.\n   *\n   * ```ts\n   * const decoder = new TextDecoder(\"utf-8\");\n   * const data = await Deno.readFile(\"hello.txt\");\n   * console.log(decoder.decode(data));\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function readFile(path: string | URL): Promise<Uint8Array>;\n\n  /** A FileInfo describes a file and is returned by `stat`, `lstat`,\n   * `statSync`, `lstatSync`. */\n  export interface FileInfo {\n    /** True if this is info for a regular file. Mutually exclusive to\n     * `FileInfo.isDirectory` and `FileInfo.isSymlink`. */\n    isFile: boolean;\n    /** True if this is info for a regular directory. Mutually exclusive to\n     * `FileInfo.isFile` and `FileInfo.isSymlink`. */\n    isDirectory: boolean;\n    /** True if this is info for a symlink. Mutually exclusive to\n     * `FileInfo.isFile` and `FileInfo.isDirectory`. */\n    isSymlink: boolean;\n    /** The size of the file, in bytes. */\n    size: number;\n    /** The last modification time of the file. This corresponds to the `mtime`\n     * field from `stat` on Linux/Mac OS and `ftLastWriteTime` on Windows. This\n     * may not be available on all platforms. */\n    mtime: Date | null;\n    /** The last access time of the file. This corresponds to the `atime`\n     * field from `stat` on Unix and `ftLastAccessTime` on Windows. This may not\n     * be available on all platforms. */\n    atime: Date | null;\n    /** The creation time of the file. This corresponds to the `birthtime`\n     * field from `stat` on Mac/BSD and `ftCreationTime` on Windows. This may\n     * not be available on all platforms. */\n    birthtime: Date | null;\n    /** ID of the device containing the file.\n     *\n     * _Linux/Mac OS only._ */\n    dev: number | null;\n    /** Inode number.\n     *\n     * _Linux/Mac OS only._ */\n    ino: number | null;\n    /** **UNSTABLE**: Match behavior with Go on Windows for `mode`.\n     *\n     * The underlying raw `st_mode` bits that contain the standard Unix\n     * permissions for this file/directory. */\n    mode: number | null;\n    /** Number of hard links pointing to this file.\n     *\n     * _Linux/Mac OS only._ */\n    nlink: number | null;\n    /** User ID of the owner of this file.\n     *\n     * _Linux/Mac OS only._ */\n    uid: number | null;\n    /** Group ID of the owner of this file.\n     *\n     * _Linux/Mac OS only._ */\n    gid: number | null;\n    /** Device ID of this file.\n     *\n     * _Linux/Mac OS only._ */\n    rdev: number | null;\n    /** Blocksize for filesystem I/O.\n     *\n     * _Linux/Mac OS only._ */\n    blksize: number | null;\n    /** Number of blocks allocated to the file, in 512-byte units.\n     *\n     * _Linux/Mac OS only._ */\n    blocks: number | null;\n  }\n\n  /** Returns absolute normalized path, with symbolic links resolved.\n   *\n   * ```ts\n   * // e.g. given /home/alice/file.txt and current directory /home/alice\n   * Deno.symlinkSync(\"file.txt\", \"symlink_file.txt\");\n   * const realPath = Deno.realPathSync(\"./file.txt\");\n   * const realSymLinkPath = Deno.realPathSync(\"./symlink_file.txt\");\n   * console.log(realPath);  // outputs \"/home/alice/file.txt\"\n   * console.log(realSymLinkPath);  // outputs \"/home/alice/file.txt\"\n   * ```\n   *\n   * Requires `allow-read` permission for the target path.\n   * Also requires `allow-read` permission for the CWD if the target path is\n   * relative.*/\n  export function realPathSync(path: string): string;\n\n  /** Resolves to the absolute normalized path, with symbolic links resolved.\n   *\n   * ```ts\n   * // e.g. given /home/alice/file.txt and current directory /home/alice\n   * await Deno.symlink(\"file.txt\", \"symlink_file.txt\");\n   * const realPath = await Deno.realPath(\"./file.txt\");\n   * const realSymLinkPath = await Deno.realPath(\"./symlink_file.txt\");\n   * console.log(realPath);  // outputs \"/home/alice/file.txt\"\n   * console.log(realSymLinkPath);  // outputs \"/home/alice/file.txt\"\n   * ```\n   *\n   * Requires `allow-read` permission for the target path.\n   * Also requires `allow-read` permission for the CWD if the target path is\n   * relative.*/\n  export function realPath(path: string): Promise<string>;\n\n  export interface DirEntry {\n    name: string;\n    isFile: boolean;\n    isDirectory: boolean;\n    isSymlink: boolean;\n  }\n\n  /** Synchronously reads the directory given by `path` and returns an iterable\n   * of `Deno.DirEntry`.\n   *\n   * ```ts\n   * for (const dirEntry of Deno.readDirSync(\"/\")) {\n   *   console.log(dirEntry.name);\n   * }\n   * ```\n   *\n   * Throws error if `path` is not a directory.\n   *\n   * Requires `allow-read` permission. */\n  export function readDirSync(path: string | URL): Iterable<DirEntry>;\n\n  /** Reads the directory given by `path` and returns an async iterable of\n   * `Deno.DirEntry`.\n   *\n   * ```ts\n   * for await (const dirEntry of Deno.readDir(\"/\")) {\n   *   console.log(dirEntry.name);\n   * }\n   * ```\n   *\n   * Throws error if `path` is not a directory.\n   *\n   * Requires `allow-read` permission. */\n  export function readDir(path: string | URL): AsyncIterable<DirEntry>;\n\n  /** Synchronously copies the contents and permissions of one file to another\n   * specified path, by default creating a new file if needed, else overwriting.\n   * Fails if target path is a directory or is unwritable.\n   *\n   * ```ts\n   * Deno.copyFileSync(\"from.txt\", \"to.txt\");\n   * ```\n   *\n   * Requires `allow-read` permission on fromPath.\n   * Requires `allow-write` permission on toPath. */\n  export function copyFileSync(\n    fromPath: string | URL,\n    toPath: string | URL,\n  ): void;\n\n  /** Copies the contents and permissions of one file to another specified path,\n   * by default creating a new file if needed, else overwriting. Fails if target\n   * path is a directory or is unwritable.\n   *\n   * ```ts\n   * await Deno.copyFile(\"from.txt\", \"to.txt\");\n   * ```\n   *\n   * Requires `allow-read` permission on fromPath.\n   * Requires `allow-write` permission on toPath. */\n  export function copyFile(\n    fromPath: string | URL,\n    toPath: string | URL,\n  ): Promise<void>;\n\n  /** Returns the full path destination of the named symbolic link.\n   *\n   * ```ts\n   * Deno.symlinkSync(\"./test.txt\", \"./test_link.txt\");\n   * const target = Deno.readLinkSync(\"./test_link.txt\"); // full path of ./test.txt\n   * ```\n   *\n   * Throws TypeError if called with a hard link\n   *\n   * Requires `allow-read` permission. */\n  export function readLinkSync(path: string | URL): string;\n\n  /** Resolves to the full path destination of the named symbolic link.\n   *\n   * ```ts\n   * await Deno.symlink(\"./test.txt\", \"./test_link.txt\");\n   * const target = await Deno.readLink(\"./test_link.txt\"); // full path of ./test.txt\n   * ```\n   *\n   * Throws TypeError if called with a hard link\n   *\n   * Requires `allow-read` permission. */\n  export function readLink(path: string | URL): Promise<string>;\n\n  /** Resolves to a `Deno.FileInfo` for the specified `path`. If `path` is a\n   * symlink, information for the symlink will be returned instead of what it\n   * points to.\n   *\n   * ```ts\n   * import { assert } from \"https://deno.land/std/testing/asserts.ts\";\n   * const fileInfo = await Deno.lstat(\"hello.txt\");\n   * assert(fileInfo.isFile);\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function lstat(path: string | URL): Promise<FileInfo>;\n\n  /** Synchronously returns a `Deno.FileInfo` for the specified `path`. If\n   * `path` is a symlink, information for the symlink will be returned instead of\n   * what it points to..\n   *\n   * ```ts\n   * const fileInfo = Deno.lstatSync(\"hello.txt\");\n   * assert(fileInfo.isFile);\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function lstatSync(path: string | URL): FileInfo;\n\n  /** Resolves to a `Deno.FileInfo` for the specified `path`. Will always\n   * follow symlinks.\n   *\n   * ```ts\n   * import { assert } from \"https://deno.land/std/testing/asserts.ts\";\n   * const fileInfo = await Deno.stat(\"hello.txt\");\n   * assert(fileInfo.isFile);\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function stat(path: string | URL): Promise<FileInfo>;\n\n  /** Synchronously returns a `Deno.FileInfo` for the specified `path`. Will\n   * always follow symlinks.\n   *\n   * ```ts\n   * import { assert } from \"https://deno.land/std/testing/asserts.ts\";\n   * const fileInfo = Deno.statSync(\"hello.txt\");\n   * assert(fileInfo.isFile);\n   * ```\n   *\n   * Requires `allow-read` permission. */\n  export function statSync(path: string | URL): FileInfo;\n\n  /** Options for writing to a file. */\n  export interface WriteFileOptions {\n    /** Defaults to `false`. If set to `true`, will append to a file instead of\n     * overwriting previous contents. */\n    append?: boolean;\n    /** Sets the option to allow creating a new file, if one doesn't already\n     * exist at the specified path (defaults to `true`). */\n    create?: boolean;\n    /** Permissions always applied to file. */\n    mode?: number;\n  }\n\n  /** Synchronously write `data` to the given `path`, by default creating a new\n   * file if needed, else overwriting.\n   *\n   * ```ts\n   * const encoder = new TextEncoder();\n   * const data = encoder.encode(\"Hello world\\n\");\n   * Deno.writeFileSync(\"hello1.txt\", data);  // overwrite \"hello1.txt\" or create it\n   * Deno.writeFileSync(\"hello2.txt\", data, {create: false});  // only works if \"hello2.txt\" exists\n   * Deno.writeFileSync(\"hello3.txt\", data, {mode: 0o777});  // set permissions on new file\n   * Deno.writeFileSync(\"hello4.txt\", data, {append: true});  // add data to the end of the file\n   * ```\n   *\n   * Requires `allow-write` permission, and `allow-read` if `options.create` is\n   * `false`.\n   */\n  export function writeFileSync(\n    path: string | URL,\n    data: Uint8Array,\n    options?: WriteFileOptions,\n  ): void;\n\n  /** Write `data` to the given `path`, by default creating a new file if needed,\n   * else overwriting.\n   *\n   * ```ts\n   * const encoder = new TextEncoder();\n   * const data = encoder.encode(\"Hello world\\n\");\n   * await Deno.writeFile(\"hello1.txt\", data);  // overwrite \"hello1.txt\" or create it\n   * await Deno.writeFile(\"hello2.txt\", data, {create: false});  // only works if \"hello2.txt\" exists\n   * await Deno.writeFile(\"hello3.txt\", data, {mode: 0o777});  // set permissions on new file\n   * await Deno.writeFile(\"hello4.txt\", data, {append: true});  // add data to the end of the file\n   * ```\n   *\n   * Requires `allow-write` permission, and `allow-read` if `options.create` is `false`.\n   */\n  export function writeFile(\n    path: string | URL,\n    data: Uint8Array,\n    options?: WriteFileOptions,\n  ): Promise<void>;\n\n  /** Synchronously write string `data` to the given `path`, by default creating a new file if needed,\n   * else overwriting.\n   *\n   * ```ts\n   * Deno.writeTextFileSync(\"hello1.txt\", \"Hello world\\n\");  // overwrite \"hello1.txt\" or create it\n   * ```\n   *\n   * Requires `allow-write` permission, and `allow-read` if `options.create` is `false`.\n   */\n  export function writeTextFileSync(\n    path: string | URL,\n    data: string,\n    options?: WriteFileOptions,\n  ): void;\n\n  /** Asynchronously write string `data` to the given `path`, by default creating a new file if needed,\n   * else overwriting.\n   *\n   * ```ts\n   * await Deno.writeTextFile(\"hello1.txt\", \"Hello world\\n\");  // overwrite \"hello1.txt\" or create it\n   * ```\n   *\n   * Requires `allow-write` permission, and `allow-read` if `options.create` is `false`.\n   */\n  export function writeTextFile(\n    path: string | URL,\n    data: string,\n    options?: WriteFileOptions,\n  ): Promise<void>;\n\n  /** Synchronously truncates or extends the specified file, to reach the\n   * specified `len`.  If `len` is not specified then the entire file contents\n   * are truncated.\n   *\n   * ```ts\n   * // truncate the entire file\n   * Deno.truncateSync(\"my_file.txt\");\n   *\n   * // truncate part of the file\n   * const file = Deno.makeTempFileSync();\n   * Deno.writeFileSync(file, new TextEncoder().encode(\"Hello World\"));\n   * Deno.truncateSync(file, 7);\n   * const data = Deno.readFileSync(file);\n   * console.log(new TextDecoder().decode(data));\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  export function truncateSync(name: string, len?: number): void;\n\n  /** Truncates or extends the specified file, to reach the specified `len`. If\n   * `len` is not specified then the entire file contents are truncated.\n   *\n   * ```ts\n   * // truncate the entire file\n   * await Deno.truncate(\"my_file.txt\");\n   *\n   * // truncate part of the file\n   * const file = await Deno.makeTempFile();\n   * await Deno.writeFile(file, new TextEncoder().encode(\"Hello World\"));\n   * await Deno.truncate(file, 7);\n   * const data = await Deno.readFile(file);\n   * console.log(new TextDecoder().decode(data));  // \"Hello W\"\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  export function truncate(name: string, len?: number): Promise<void>;\n\n  export interface NetAddr {\n    transport: \"tcp\" | \"udp\";\n    hostname: string;\n    port: number;\n  }\n\n  export interface UnixAddr {\n    transport: \"unix\" | \"unixpacket\";\n    path: string;\n  }\n\n  export type Addr = NetAddr | UnixAddr;\n\n  /** A generic network listener for stream-oriented protocols. */\n  export interface Listener extends AsyncIterable<Conn> {\n    /** Waits for and resolves to the next connection to the `Listener`. */\n    accept(): Promise<Conn>;\n    /** Close closes the listener. Any pending accept promises will be rejected\n     * with errors. */\n    close(): void;\n    /** Return the address of the `Listener`. */\n    readonly addr: Addr;\n\n    /** Return the rid of the `Listener`. */\n    readonly rid: number;\n\n    [Symbol.asyncIterator](): AsyncIterableIterator<Conn>;\n  }\n\n  export interface Conn extends Reader, Writer, Closer {\n    /** The local address of the connection. */\n    readonly localAddr: Addr;\n    /** The remote address of the connection. */\n    readonly remoteAddr: Addr;\n    /** The resource ID of the connection. */\n    readonly rid: number;\n    /** Shuts down (`shutdown(2)`) the write side of the connection. Most\n     * callers should just use `close()`. */\n    closeWrite(): Promise<void>;\n  }\n\n  export interface ListenOptions {\n    /** The port to listen on. */\n    port: number;\n    /** A literal IP address or host name that can be resolved to an IP address.\n     * If not specified, defaults to `0.0.0.0`. */\n    hostname?: string;\n  }\n\n  /** Listen announces on the local transport address.\n   *\n   * ```ts\n   * const listener1 = Deno.listen({ port: 80 })\n   * const listener2 = Deno.listen({ hostname: \"192.0.2.1\", port: 80 })\n   * const listener3 = Deno.listen({ hostname: \"[2001:db8::1]\", port: 80 });\n   * const listener4 = Deno.listen({ hostname: \"golang.org\", port: 80, transport: \"tcp\" });\n   * ```\n   *\n   * Requires `allow-net` permission. */\n  export function listen(\n    options: ListenOptions & { transport?: \"tcp\" },\n  ): Listener;\n\n  export interface ListenTlsOptions extends ListenOptions {\n    /** Server certificate file. */\n    certFile: string;\n    /** Server public key file. */\n    keyFile: string;\n\n    transport?: \"tcp\";\n  }\n\n  /** Listen announces on the local transport address over TLS (transport layer\n   * security).\n   *\n   * ```ts\n   * const lstnr = Deno.listenTls({ port: 443, certFile: \"./server.crt\", keyFile: \"./server.key\" });\n   * ```\n   *\n   * Requires `allow-net` permission. */\n  export function listenTls(options: ListenTlsOptions): Listener;\n\n  export interface ConnectOptions {\n    /** The port to connect to. */\n    port: number;\n    /** A literal IP address or host name that can be resolved to an IP address.\n     * If not specified, defaults to `127.0.0.1`. */\n    hostname?: string;\n    transport?: \"tcp\";\n  }\n\n  /**\n   * Connects to the hostname (default is \"127.0.0.1\") and port on the named\n   * transport (default is \"tcp\"), and resolves to the connection (`Conn`).\n   *\n   * ```ts\n   * const conn1 = await Deno.connect({ port: 80 });\n   * const conn2 = await Deno.connect({ hostname: \"192.0.2.1\", port: 80 });\n   * const conn3 = await Deno.connect({ hostname: \"[2001:db8::1]\", port: 80 });\n   * const conn4 = await Deno.connect({ hostname: \"golang.org\", port: 80, transport: \"tcp\" });\n   * ```\n   *\n   * Requires `allow-net` permission for \"tcp\". */\n  export function connect(options: ConnectOptions): Promise<Conn>;\n\n  export interface ConnectTlsOptions {\n    /** The port to connect to. */\n    port: number;\n    /** A literal IP address or host name that can be resolved to an IP address.\n     * If not specified, defaults to `127.0.0.1`. */\n    hostname?: string;\n    /** Server certificate file. */\n    certFile?: string;\n  }\n\n  /** Establishes a secure connection over TLS (transport layer security) using\n   * an optional cert file, hostname (default is \"127.0.0.1\") and port.  The\n   * cert file is optional and if not included Mozilla's root certificates will\n   * be used (see also https://github.com/ctz/webpki-roots for specifics)\n   *\n   * ```ts\n   * const conn1 = await Deno.connectTls({ port: 80 });\n   * const conn2 = await Deno.connectTls({ certFile: \"./certs/my_custom_root_CA.pem\", hostname: \"192.0.2.1\", port: 80 });\n   * const conn3 = await Deno.connectTls({ hostname: \"[2001:db8::1]\", port: 80 });\n   * const conn4 = await Deno.connectTls({ certFile: \"./certs/my_custom_root_CA.pem\", hostname: \"golang.org\", port: 80});\n   * ```\n   *\n   * Requires `allow-net` permission.\n   */\n  export function connectTls(options: ConnectTlsOptions): Promise<Conn>;\n\n  /** Shutdown socket send operations.\n   *\n   * Matches behavior of POSIX shutdown(3).\n   *\n   * ```ts\n   * const listener = Deno.listen({ port: 80 });\n   * const conn = await listener.accept();\n   * Deno.shutdown(conn.rid);\n   * ```\n   */\n  export function shutdown(rid: number): Promise<void>;\n\n  export interface Metrics {\n    opsDispatched: number;\n    opsDispatchedSync: number;\n    opsDispatchedAsync: number;\n    opsDispatchedAsyncUnref: number;\n    opsCompleted: number;\n    opsCompletedSync: number;\n    opsCompletedAsync: number;\n    opsCompletedAsyncUnref: number;\n    bytesSentControl: number;\n    bytesSentData: number;\n    bytesReceived: number;\n  }\n\n  /** Receive metrics from the privileged side of Deno. This is primarily used\n   * in the development of Deno. 'Ops', also called 'bindings', are the go-between\n   * between Deno JavaScript and Deno Rust.\n   *\n   *      > console.table(Deno.metrics())\n   *      ┌─────────────────────────┬────────┐\n   *      │         (index)         │ Values │\n   *      ├─────────────────────────┼────────┤\n   *      │      opsDispatched      │   3    │\n   *      │    opsDispatchedSync    │   2    │\n   *      │   opsDispatchedAsync    │   1    │\n   *      │ opsDispatchedAsyncUnref │   0    │\n   *      │      opsCompleted       │   3    │\n   *      │    opsCompletedSync     │   2    │\n   *      │    opsCompletedAsync    │   1    │\n   *      │ opsCompletedAsyncUnref  │   0    │\n   *      │    bytesSentControl     │   73   │\n   *      │      bytesSentData      │   0    │\n   *      │      bytesReceived      │  375   │\n   *      └─────────────────────────┴────────┘\n   */\n  export function metrics(): Metrics;\n\n  interface ResourceMap {\n    // deno-lint-ignore no-explicit-any\n    [rid: number]: any;\n  }\n\n  /** Returns a map of open resource ids (rid) along with their string\n   * representations. This is an internal API and as such resource\n   * representation has `any` type; that means it can change any time.\n   *\n   * ```ts\n   * console.log(Deno.resources());\n   * // { 0: \"stdin\", 1: \"stdout\", 2: \"stderr\" }\n   * Deno.openSync('../test.file');\n   * console.log(Deno.resources());\n   * // { 0: \"stdin\", 1: \"stdout\", 2: \"stderr\", 3: \"fsFile\" }\n   * ```\n   */\n  export function resources(): ResourceMap;\n\n  export interface FsEvent {\n    kind: \"any\" | \"access\" | \"create\" | \"modify\" | \"remove\";\n    paths: string[];\n  }\n\n  /** Watch for file system events against one or more `paths`, which can be files\n   * or directories.  These paths must exist already.  One user action (e.g.\n   * `touch test.file`) can  generate multiple file system events.  Likewise,\n   * one user action can result in multiple file paths in one event (e.g. `mv\n   * old_name.txt new_name.txt`).  Recursive option is `true` by default and,\n   * for directories, will watch the specified directory and all sub directories.\n   * Note that the exact ordering of the events can vary between operating systems.\n   *\n   * ```ts\n   * const watcher = Deno.watchFs(\"/\");\n   * for await (const event of watcher) {\n   *    console.log(\">>>> event\", event);\n   *    // { kind: \"create\", paths: [ \"/foo.txt\" ] }\n   * }\n   *```\n   *\n   * Requires `allow-read` permission.\n   */\n  export function watchFs(\n    paths: string | string[],\n    options?: { recursive: boolean },\n  ): AsyncIterableIterator<FsEvent>;\n\n  export class Process<T extends RunOptions = RunOptions> {\n    readonly rid: number;\n    readonly pid: number;\n    readonly stdin: T[\"stdin\"] extends \"piped\" ? Writer & Closer\n      : (Writer & Closer) | null;\n    readonly stdout: T[\"stdout\"] extends \"piped\" ? Reader & Closer\n      : (Reader & Closer) | null;\n    readonly stderr: T[\"stderr\"] extends \"piped\" ? Reader & Closer\n      : (Reader & Closer) | null;\n    /** Wait for the process to exit and return its exit status.\n     *\n     * Calling this function multiple times will return the same status.\n     *\n     * Stdin handle to the process will be closed before waiting to avoid\n     * a deadlock.\n     *\n     * If `stdout` and/or `stderr` were set to `\"piped\"`, they must be closed\n     * manually before the process can exit.\n     * \n     * To run process to completion and collect output from both `stdout` and\n     * `stderr` use:\n     * \n     * ```ts\n     * const p = Deno.run({ cmd, stderr: 'piped', stdout: 'piped' });\n     * const [status, stdout, stderr] = await Promise.all([\n     *   p.status(),\n     *   p.output(),\n     *   p.stderrOutput()\n     * ]);\n     * p.close();\n     * ```\n     **/\n    status(): Promise<ProcessStatus>;\n    /** Buffer the stdout until EOF and return it as `Uint8Array`.\n     *\n     * You must set stdout to `\"piped\"` when creating the process.\n     *\n     * This calls `close()` on stdout after its done. */\n    output(): Promise<Uint8Array>;\n    /** Buffer the stderr until EOF and return it as `Uint8Array`.\n     *\n     * You must set stderr to `\"piped\"` when creating the process.\n     *\n     * This calls `close()` on stderr after its done. */\n    stderrOutput(): Promise<Uint8Array>;\n    close(): void;\n\n    /** **UNSTABLE**: The `signo` argument may change to require the Deno.Signal\n     * enum.\n     *\n     * Send a signal to process. This functionality currently only works on\n     * Linux and Mac OS.\n     */\n    kill(signo: number): void;\n  }\n\n  export type ProcessStatus =\n    | {\n      success: true;\n      code: 0;\n      signal?: undefined;\n    }\n    | {\n      success: false;\n      code: number;\n      signal?: number;\n    };\n\n  export interface RunOptions {\n    /** Arguments to pass. Note, the first element needs to be a path to the\n     * binary */\n    cmd: string[] | [URL, ...string[]];\n    cwd?: string;\n    env?: {\n      [key: string]: string;\n    };\n    stdout?: \"inherit\" | \"piped\" | \"null\" | number;\n    stderr?: \"inherit\" | \"piped\" | \"null\" | number;\n    stdin?: \"inherit\" | \"piped\" | \"null\" | number;\n  }\n\n  /** Spawns new subprocess.  RunOptions must contain at a minimum the `opt.cmd`,\n   * an array of program arguments, the first of which is the binary.\n   *\n   * ```ts\n   * const p = Deno.run({\n   *   cmd: [\"echo\", \"hello\"],\n   * });\n   * ```\n   *\n   * Subprocess uses same working directory as parent process unless `opt.cwd`\n   * is specified.\n   *\n   * Environmental variables for subprocess can be specified using `opt.env`\n   * mapping.\n   *\n   * By default subprocess inherits stdio of parent process. To change that\n   * `opt.stdout`, `opt.stderr` and `opt.stdin` can be specified independently -\n   * they can be set to either an rid of open file or set to \"inherit\" \"piped\"\n   * or \"null\":\n   *\n   * `\"inherit\"` The default if unspecified. The child inherits from the\n   * corresponding parent descriptor.\n   *\n   * `\"piped\"` A new pipe should be arranged to connect the parent and child\n   * sub-processes.\n   *\n   * `\"null\"` This stream will be ignored. This is the equivalent of attaching\n   * the stream to `/dev/null`.\n   *\n   * Details of the spawned process are returned.\n   *\n   * Requires `allow-run` permission. */\n  export function run<T extends RunOptions = RunOptions>(opt: T): Process<T>;\n\n  export interface InspectOptions {\n    /** Stylize output with ANSI colors. Defaults to false. */\n    colors?: boolean;\n    /** Try to fit more than one entry of a collection on the same line.\n     * Defaults to true. */\n    compact?: boolean;\n    /** Traversal depth for nested objects. Defaults to 4. */\n    depth?: number;\n    /** The maximum number of iterable entries to print. Defaults to 100. */\n    iterableLimit?: number;\n    /** Show a Proxy's target and handler. Defaults to false. */\n    showProxy?: boolean;\n    /** Sort Object, Set and Map entries by key. Defaults to false. */\n    sorted?: boolean;\n    /** Add a trailing comma for multiline collections. Defaults to false. */\n    trailingComma?: boolean;\n    /*** Evaluate the result of calling getters. Defaults to false. */\n    getters?: boolean;\n    /** Show an object's non-enumerable properties. Defaults to false. */\n    showHidden?: boolean;\n  }\n\n  /** Converts the input into a string that has the same format as printed by\n   * `console.log()`.\n   *\n   * ```ts\n   * const obj = {};\n   * obj.propA = 10;\n   * obj.propB = \"hello\";\n   * const objAsString = Deno.inspect(obj); // { propA: 10, propB: \"hello\" }\n   * console.log(obj);  // prints same value as objAsString, e.g. { propA: 10, propB: \"hello\" }\n   * ```\n   *\n   * You can also register custom inspect functions, via the `customInspect` Deno\n   * symbol on objects, to control and customize the output.\n   *\n   * ```ts\n   * class A {\n   *   x = 10;\n   *   y = \"hello\";\n   *   [Deno.customInspect](): string {\n   *     return \"x=\" + this.x + \", y=\" + this.y;\n   *   }\n   * }\n   * ```\n   *\n   *      const inStringFormat = Deno.inspect(new A()); // \"x=10, y=hello\"\n   *      console.log(inStringFormat);  // prints \"x=10, y=hello\"\n   *\n   * Finally, you can also specify the depth to which it will format.\n   *\n   *      Deno.inspect({a: {b: {c: {d: 'hello'}}}}, {depth: 2}); // { a: { b: [Object] } }\n   *\n   */\n  export function inspect(value: unknown, options?: InspectOptions): string;\n\n  /** The name of a \"powerful feature\" which needs permission. */\n  export type PermissionName =\n    | \"run\"\n    | \"read\"\n    | \"write\"\n    | \"net\"\n    | \"env\"\n    | \"plugin\"\n    | \"hrtime\";\n\n  /** The current status of the permission. */\n  export type PermissionState = \"granted\" | \"denied\" | \"prompt\";\n\n  export interface RunPermissionDescriptor {\n    name: \"run\";\n  }\n\n  export interface ReadPermissionDescriptor {\n    name: \"read\";\n    path?: string;\n  }\n\n  export interface WritePermissionDescriptor {\n    name: \"write\";\n    path?: string;\n  }\n\n  export interface NetPermissionDescriptor {\n    name: \"net\";\n    /** Optional host string of the form `\"<hostname>[:<port>]\"`. Examples:\n     *\n     *      \"github.com\"\n     *      \"deno.land:8080\"\n     */\n    host?: string;\n  }\n\n  export interface EnvPermissionDescriptor {\n    name: \"env\";\n  }\n\n  export interface PluginPermissionDescriptor {\n    name: \"plugin\";\n  }\n\n  export interface HrtimePermissionDescriptor {\n    name: \"hrtime\";\n  }\n\n  /** Permission descriptors which define a permission and can be queried,\n   * requested, or revoked. */\n  export type PermissionDescriptor =\n    | RunPermissionDescriptor\n    | ReadPermissionDescriptor\n    | WritePermissionDescriptor\n    | NetPermissionDescriptor\n    | EnvPermissionDescriptor\n    | PluginPermissionDescriptor\n    | HrtimePermissionDescriptor;\n\n  export interface PermissionStatusEventMap {\n    \"change\": Event;\n  }\n\n  export class PermissionStatus extends EventTarget {\n    // deno-lint-ignore no-explicit-any\n    onchange: ((this: PermissionStatus, ev: Event) => any) | null;\n    readonly state: PermissionState;\n    addEventListener<K extends keyof PermissionStatusEventMap>(\n      type: K,\n      listener: (\n        this: PermissionStatus,\n        ev: PermissionStatusEventMap[K],\n      ) => any,\n      options?: boolean | AddEventListenerOptions,\n    ): void;\n    addEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | AddEventListenerOptions,\n    ): void;\n    removeEventListener<K extends keyof PermissionStatusEventMap>(\n      type: K,\n      listener: (\n        this: PermissionStatus,\n        ev: PermissionStatusEventMap[K],\n      ) => any,\n      options?: boolean | EventListenerOptions,\n    ): void;\n    removeEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | EventListenerOptions,\n    ): void;\n  }\n\n  export class Permissions {\n    /** Resolves to the current status of a permission.\n     *\n     * ```ts\n     * const status = await Deno.permissions.query({ name: \"read\", path: \"/etc\" });\n     * if (status.state === \"granted\") {\n     *   data = await Deno.readFile(\"/etc/passwd\");\n     * }\n     * ```\n     */\n    query(desc: PermissionDescriptor): Promise<PermissionStatus>;\n\n    /** Revokes a permission, and resolves to the state of the permission.\n     *\n     * ```ts\n     * const status = await Deno.permissions.revoke({ name: \"run\" });\n     * assert(status.state !== \"granted\")\n     * ```\n     */\n    revoke(desc: PermissionDescriptor): Promise<PermissionStatus>;\n\n    /** Requests the permission, and resolves to the state of the permission.\n     *\n     * ```ts\n     * const status = await Deno.permissions.request({ name: \"env\" });\n     * if (status.state === \"granted\") {\n     *   console.log(\"'env' permission is granted.\");\n     * } else {\n     *   console.log(\"'env' permission is denied.\");\n     * }\n     * ```\n     */\n    request(desc: PermissionDescriptor): Promise<PermissionStatus>;\n  }\n\n  /** Deno's permission management API. */\n  export const permissions: Permissions;\n\n  /** Build related information. */\n  export const build: {\n    /** The LLVM target triple */\n    target: string;\n    /** Instruction set architecture */\n    arch: \"x86_64\";\n    /** Operating system */\n    os: \"darwin\" | \"linux\" | \"windows\";\n    /** Computer vendor */\n    vendor: string;\n    /** Optional environment */\n    env?: string;\n  };\n\n  /** Version related information. */\n  export const version: {\n    /** Deno's version. For example: `\"1.0.0\"` */\n    deno: string;\n    /** The V8 version used by Deno. For example: `\"8.0.0.0\"` */\n    v8: string;\n    /** The TypeScript version used by Deno. For example: `\"4.0.0\"` */\n    typescript: string;\n  };\n\n  /** Returns the script arguments to the program. If for example we run a\n   * program:\n   *\n   * deno run --allow-read https://deno.land/std/examples/cat.ts /etc/passwd\n   *\n   * Then `Deno.args` will contain:\n   *\n   * [ \"/etc/passwd\" ]\n   */\n  export const args: string[];\n\n  /** A symbol which can be used as a key for a custom method which will be\n   * called when `Deno.inspect()` is called, or when the object is logged to\n   * the console. */\n  export const customInspect: unique symbol;\n\n  /** The URL of the entrypoint module entered from the command-line. */\n  export const mainModule: string;\n\n  export type SymlinkOptions = {\n    type: \"file\" | \"dir\";\n  };\n\n  /**\n   * Creates `newpath` as a symbolic link to `oldpath`.\n   *\n   * The options.type parameter can be set to `file` or `dir`. This argument is only\n   * available on Windows and ignored on other platforms.\n   *\n   * ```ts\n   * Deno.symlinkSync(\"old/name\", \"new/name\");\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  export function symlinkSync(\n    oldpath: string,\n    newpath: string,\n    options?: SymlinkOptions,\n  ): void;\n\n  /**\n   * Creates `newpath` as a symbolic link to `oldpath`.\n   *\n   * The options.type parameter can be set to `file` or `dir`. This argument is only\n   * available on Windows and ignored on other platforms.\n   *\n   * ```ts\n   * await Deno.symlink(\"old/name\", \"new/name\");\n   * ```\n   *\n   * Requires `allow-write` permission. */\n  export function symlink(\n    oldpath: string,\n    newpath: string,\n    options?: SymlinkOptions,\n  ): Promise<void>;\n}\n\n// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.\n\n// deno-lint-ignore-file no-explicit-any\n\n/// <reference no-default-lib=\"true\" />\n/// <reference lib=\"esnext\" />\n\ndeclare class DOMException extends Error {\n  constructor(message?: string, name?: string);\n  readonly name: string;\n  readonly message: string;\n  readonly code: number;\n}\n\ninterface EventInit {\n  bubbles?: boolean;\n  cancelable?: boolean;\n  composed?: boolean;\n}\n\n/** An event which takes place in the DOM. */\ndeclare class Event {\n  constructor(type: string, eventInitDict?: EventInit);\n  /** Returns true or false depending on how event was initialized. True if\n     * event goes through its target's ancestors in reverse tree order, and\n     * false otherwise. */\n  readonly bubbles: boolean;\n  cancelBubble: boolean;\n  /** Returns true or false depending on how event was initialized. Its return\n     * value does not always carry meaning, but true can indicate that part of the\n     * operation during which event was dispatched, can be canceled by invoking\n     * the preventDefault() method. */\n  readonly cancelable: boolean;\n  /** Returns true or false depending on how event was initialized. True if\n     * event invokes listeners past a ShadowRoot node that is the root of its\n     * target, and false otherwise. */\n  readonly composed: boolean;\n  /** Returns the object whose event listener's callback is currently being\n     * invoked. */\n  readonly currentTarget: EventTarget | null;\n  /** Returns true if preventDefault() was invoked successfully to indicate\n     * cancellation, and false otherwise. */\n  readonly defaultPrevented: boolean;\n  /** Returns the event's phase, which is one of NONE, CAPTURING_PHASE,\n     * AT_TARGET, and BUBBLING_PHASE. */\n  readonly eventPhase: number;\n  /** Returns true if event was dispatched by the user agent, and false\n     * otherwise. */\n  readonly isTrusted: boolean;\n  /** Returns the object to which event is dispatched (its target). */\n  readonly target: EventTarget | null;\n  /** Returns the event's timestamp as the number of milliseconds measured\n     * relative to the time origin. */\n  readonly timeStamp: number;\n  /** Returns the type of event, e.g. \"click\", \"hashchange\", or \"submit\". */\n  readonly type: string;\n  /** Returns the invocation target objects of event's path (objects on which\n     * listeners will be invoked), except for any nodes in shadow trees of which\n     * the shadow root's mode is \"closed\" that are not reachable from event's\n     * currentTarget. */\n  composedPath(): EventTarget[];\n  /** If invoked when the cancelable attribute value is true, and while\n     * executing a listener for the event with passive set to false, signals to\n     * the operation that caused event to be dispatched that it needs to be\n     * canceled. */\n  preventDefault(): void;\n  /** Invoking this method prevents event from reaching any registered event\n     * listeners after the current one finishes running and, when dispatched in a\n     * tree, also prevents event from reaching any other objects. */\n  stopImmediatePropagation(): void;\n  /** When dispatched in a tree, invoking this method prevents event from\n     * reaching any objects other than the current object. */\n  stopPropagation(): void;\n  readonly AT_TARGET: number;\n  readonly BUBBLING_PHASE: number;\n  readonly CAPTURING_PHASE: number;\n  readonly NONE: number;\n  static readonly AT_TARGET: number;\n  static readonly BUBBLING_PHASE: number;\n  static readonly CAPTURING_PHASE: number;\n  static readonly NONE: number;\n}\n\n/**\n   * EventTarget is a DOM interface implemented by objects that can receive events\n   * and may have listeners for them.\n   */\ndeclare class EventTarget {\n  /** Appends an event listener for events whose type attribute value is type.\n     * The callback argument sets the callback that will be invoked when the event\n     * is dispatched.\n     *\n     * The options argument sets listener-specific options. For compatibility this\n     * can be a boolean, in which case the method behaves exactly as if the value\n     * was specified as options's capture.\n     *\n     * When set to true, options's capture prevents callback from being invoked\n     * when the event's eventPhase attribute value is BUBBLING_PHASE. When false\n     * (or not present), callback will not be invoked when event's eventPhase\n     * attribute value is CAPTURING_PHASE. Either way, callback will be invoked if\n     * event's eventPhase attribute value is AT_TARGET.\n     *\n     * When set to true, options's passive indicates that the callback will not\n     * cancel the event by invoking preventDefault(). This is used to enable\n     * performance optimizations described in § 2.8 Observing event listeners.\n     *\n     * When set to true, options's once indicates that the callback will only be\n     * invoked once after which the event listener will be removed.\n     *\n     * The event listener is appended to target's event listener list and is not\n     * appended if it has the same type, callback, and capture. */\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject | null,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  /** Dispatches a synthetic event event to target and returns true if either\n     * event's cancelable attribute value is false or its preventDefault() method\n     * was not invoked, and false otherwise. */\n  dispatchEvent(event: Event): boolean;\n  /** Removes the event listener in target's event listener list with the same\n     * type, callback, and options. */\n  removeEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject | null,\n    options?: EventListenerOptions | boolean,\n  ): void;\n  [Symbol.toStringTag]: string;\n}\n\ninterface EventListener {\n  (evt: Event): void | Promise<void>;\n}\n\ninterface EventListenerObject {\n  handleEvent(evt: Event): void | Promise<void>;\n}\n\ndeclare type EventListenerOrEventListenerObject =\n  | EventListener\n  | EventListenerObject;\n\ninterface AddEventListenerOptions extends EventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\ninterface EventListenerOptions {\n  capture?: boolean;\n}\n\ninterface ProgressEventInit extends EventInit {\n  lengthComputable?: boolean;\n  loaded?: number;\n  total?: number;\n}\n\n/** Events measuring progress of an underlying process, like an HTTP request\n * (for an XMLHttpRequest, or the loading of the underlying resource of an\n * <img>, <audio>, <video>, <style> or <link>). */\ndeclare class ProgressEvent<T extends EventTarget = EventTarget> extends Event {\n  constructor(type: string, eventInitDict?: ProgressEventInit);\n  readonly lengthComputable: boolean;\n  readonly loaded: number;\n  readonly target: T | null;\n  readonly total: number;\n}\n\n/** Decodes a string of data which has been encoded using base-64 encoding.\n *\n *     console.log(atob(\"aGVsbG8gd29ybGQ=\")); // outputs 'hello world'\n */\ndeclare function atob(s: string): string;\n\n/** Creates a base-64 ASCII encoded string from the input string.\n *\n *     console.log(btoa(\"hello world\"));  // outputs \"aGVsbG8gd29ybGQ=\"\n */\ndeclare function btoa(s: string): string;\n\ndeclare class TextDecoder {\n  /** Returns encoding's name, lowercased. */\n  readonly encoding: string;\n  /** Returns `true` if error mode is \"fatal\", and `false` otherwise. */\n  readonly fatal: boolean;\n  /** Returns `true` if ignore BOM flag is set, and `false` otherwise. */\n  readonly ignoreBOM = false;\n  constructor(\n    label?: string,\n    options?: { fatal?: boolean; ignoreBOM?: boolean },\n  );\n  /** Returns the result of running encoding's decoder. */\n  decode(input?: BufferSource, options?: { stream?: false }): string;\n  readonly [Symbol.toStringTag]: string;\n}\n\ndeclare class TextEncoder {\n  /** Returns \"utf-8\". */\n  readonly encoding = \"utf-8\";\n  /** Returns the result of running UTF-8's encoder. */\n  encode(input?: string): Uint8Array;\n  encodeInto(\n    input: string,\n    dest: Uint8Array,\n  ): { read: number; written: number };\n  readonly [Symbol.toStringTag]: string;\n}\n\n/** A controller object that allows you to abort one or more DOM requests as and\n * when desired. */\ndeclare class AbortController {\n  /** Returns the AbortSignal object associated with this object. */\n  readonly signal: AbortSignal;\n  /** Invoking this method will set this object's AbortSignal's aborted flag and\n    * signal to any observers that the associated activity is to be aborted. */\n  abort(): void;\n}\n\ninterface AbortSignalEventMap {\n  abort: Event;\n}\n\n/** A signal object that allows you to communicate with a DOM request (such as a\n  * Fetch) and abort it if required via an AbortController object. */\ninterface AbortSignal extends EventTarget {\n  /** Returns true if this AbortSignal's AbortController has signaled to abort,\n    * and false otherwise. */\n  readonly aborted: boolean;\n  onabort: ((this: AbortSignal, ev: Event) => any) | null;\n  addEventListener<K extends keyof AbortSignalEventMap>(\n    type: K,\n    listener: (this: AbortSignal, ev: AbortSignalEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  removeEventListener<K extends keyof AbortSignalEventMap>(\n    type: K,\n    listener: (this: AbortSignal, ev: AbortSignalEventMap[K]) => any,\n    options?: boolean | EventListenerOptions,\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void;\n}\n\ndeclare var AbortSignal: {\n  prototype: AbortSignal;\n  new (): AbortSignal;\n};\n\ninterface FileReaderEventMap {\n  \"abort\": ProgressEvent<FileReader>;\n  \"error\": ProgressEvent<FileReader>;\n  \"load\": ProgressEvent<FileReader>;\n  \"loadend\": ProgressEvent<FileReader>;\n  \"loadstart\": ProgressEvent<FileReader>;\n  \"progress\": ProgressEvent<FileReader>;\n}\n\n/** Lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read. */\ninterface FileReader extends EventTarget {\n  readonly error: DOMException | null;\n  onabort: ((this: FileReader, ev: ProgressEvent<FileReader>) => any) | null;\n  onerror: ((this: FileReader, ev: ProgressEvent<FileReader>) => any) | null;\n  onload: ((this: FileReader, ev: ProgressEvent<FileReader>) => any) | null;\n  onloadend: ((this: FileReader, ev: ProgressEvent<FileReader>) => any) | null;\n  onloadstart:\n    | ((this: FileReader, ev: ProgressEvent<FileReader>) => any)\n    | null;\n  onprogress: ((this: FileReader, ev: ProgressEvent<FileReader>) => any) | null;\n  readonly readyState: number;\n  readonly result: string | ArrayBuffer | null;\n  abort(): void;\n  readAsArrayBuffer(blob: Blob): void;\n  readAsBinaryString(blob: Blob): void;\n  readAsDataURL(blob: Blob): void;\n  readAsText(blob: Blob, encoding?: string): void;\n  readonly DONE: number;\n  readonly EMPTY: number;\n  readonly LOADING: number;\n  addEventListener<K extends keyof FileReaderEventMap>(\n    type: K,\n    listener: (this: FileReader, ev: FileReaderEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  removeEventListener<K extends keyof FileReaderEventMap>(\n    type: K,\n    listener: (this: FileReader, ev: FileReaderEventMap[K]) => any,\n    options?: boolean | EventListenerOptions,\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void;\n}\n\ndeclare var FileReader: {\n  prototype: FileReader;\n  new (): FileReader;\n  readonly DONE: number;\n  readonly EMPTY: number;\n  readonly LOADING: number;\n};\n\ndeclare class URLSearchParams {\n  constructor(\n    init?: string[][] | Record<string, string> | string | URLSearchParams,\n  );\n  static toString(): string;\n\n  /** Appends a specified key/value pair as a new search parameter.\n   *\n   * ```ts\n   * let searchParams = new URLSearchParams();\n   * searchParams.append('name', 'first');\n   * searchParams.append('name', 'second');\n   * ```\n   */\n  append(name: string, value: string): void;\n\n  /** Deletes the given search parameter and its associated value,\n   * from the list of all search parameters.\n   *\n   * ```ts\n   * let searchParams = new URLSearchParams([['name', 'value']]);\n   * searchParams.delete('name');\n   * ```\n   */\n  delete(name: string): void;\n\n  /** Returns all the values associated with a given search parameter\n   * as an array.\n   *\n   * ```ts\n   * searchParams.getAll('name');\n   * ```\n   */\n  getAll(name: string): string[];\n\n  /** Returns the first value associated to the given search parameter.\n   *\n   * ```ts\n   * searchParams.get('name');\n   * ```\n   */\n  get(name: string): string | null;\n\n  /** Returns a Boolean that indicates whether a parameter with the\n   * specified name exists.\n   *\n   * ```ts\n   * searchParams.has('name');\n   * ```\n   */\n  has(name: string): boolean;\n\n  /** Sets the value associated with a given search parameter to the\n   * given value. If there were several matching values, this method\n   * deletes the others. If the search parameter doesn't exist, this\n   * method creates it.\n   *\n   * ```ts\n   * searchParams.set('name', 'value');\n   * ```\n   */\n  set(name: string, value: string): void;\n\n  /** Sort all key/value pairs contained in this object in place and\n   * return undefined. The sort order is according to Unicode code\n   * points of the keys.\n   *\n   * ```ts\n   * searchParams.sort();\n   * ```\n   */\n  sort(): void;\n\n  /** Calls a function for each element contained in this object in\n   * place and return undefined. Optionally accepts an object to use\n   * as this when executing callback as second argument.\n   *\n   * ```ts\n   * const params = new URLSearchParams([[\"a\", \"b\"], [\"c\", \"d\"]]);\n   * params.forEach((value, key, parent) => {\n   *   console.log(value, key, parent);\n   * });\n   * ```\n   *\n   */\n  forEach(\n    callbackfn: (value: string, key: string, parent: this) => void,\n    thisArg?: any,\n  ): void;\n\n  /** Returns an iterator allowing to go through all keys contained\n   * in this object.\n   *\n   * ```ts\n   * const params = new URLSearchParams([[\"a\", \"b\"], [\"c\", \"d\"]]);\n   * for (const key of params.keys()) {\n   *   console.log(key);\n   * }\n   * ```\n   */\n  keys(): IterableIterator<string>;\n\n  /** Returns an iterator allowing to go through all values contained\n   * in this object.\n   *\n   * ```ts\n   * const params = new URLSearchParams([[\"a\", \"b\"], [\"c\", \"d\"]]);\n   * for (const value of params.values()) {\n   *   console.log(value);\n   * }\n   * ```\n   */\n  values(): IterableIterator<string>;\n\n  /** Returns an iterator allowing to go through all key/value\n   * pairs contained in this object.\n   *\n   * ```ts\n   * const params = new URLSearchParams([[\"a\", \"b\"], [\"c\", \"d\"]]);\n   * for (const [key, value] of params.entries()) {\n   *   console.log(key, value);\n   * }\n   * ```\n   */\n  entries(): IterableIterator<[string, string]>;\n\n  /** Returns an iterator allowing to go through all key/value\n   * pairs contained in this object.\n   *\n   * ```ts\n   * const params = new URLSearchParams([[\"a\", \"b\"], [\"c\", \"d\"]]);\n   * for (const [key, value] of params) {\n   *   console.log(key, value);\n   * }\n   * ```\n   */\n  [Symbol.iterator](): IterableIterator<[string, string]>;\n\n  /** Returns a query string suitable for use in a URL.\n   *\n   * ```ts\n   * searchParams.toString();\n   * ```\n   */\n  toString(): string;\n}\n\n/** The URL interface represents an object providing static methods used for creating object URLs. */\ndeclare class URL {\n  constructor(url: string, base?: string | URL);\n  createObjectURL(object: any): string;\n  revokeObjectURL(url: string): void;\n\n  hash: string;\n  host: string;\n  hostname: string;\n  href: string;\n  toString(): string;\n  readonly origin: string;\n  password: string;\n  pathname: string;\n  port: string;\n  protocol: string;\n  search: string;\n  readonly searchParams: URLSearchParams;\n  username: string;\n  toJSON(): string;\n}\n\n// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.\n\n// deno-lint-ignore-file no-explicit-any\n\n/// <reference no-default-lib=\"true\" />\n/// <reference lib=\"esnext\" />\n\ninterface DomIterable<K, V> {\n  keys(): IterableIterator<K>;\n  values(): IterableIterator<V>;\n  entries(): IterableIterator<[K, V]>;\n  [Symbol.iterator](): IterableIterator<[K, V]>;\n  forEach(\n    callback: (value: V, key: K, parent: this) => void,\n    thisArg?: any,\n  ): void;\n}\n\ninterface ReadableStreamReadDoneResult<T> {\n  done: true;\n  value?: T;\n}\n\ninterface ReadableStreamReadValueResult<T> {\n  done: false;\n  value: T;\n}\n\ntype ReadableStreamReadResult<T> =\n  | ReadableStreamReadValueResult<T>\n  | ReadableStreamReadDoneResult<T>;\n\ninterface ReadableStreamDefaultReader<R = any> {\n  readonly closed: Promise<void>;\n  cancel(reason?: any): Promise<void>;\n  read(): Promise<ReadableStreamReadResult<R>>;\n  releaseLock(): void;\n}\n\ndeclare var ReadableStreamDefaultReader: {\n  prototype: ReadableStreamDefaultReader;\n  new <R>(stream: ReadableStream<R>): ReadableStreamDefaultReader<R>;\n};\n\ninterface ReadableStreamReader<R = any> {\n  cancel(): Promise<void>;\n  read(): Promise<ReadableStreamReadResult<R>>;\n  releaseLock(): void;\n}\n\ndeclare var ReadableStreamReader: {\n  prototype: ReadableStreamReader;\n  new (): ReadableStreamReader;\n};\n\ninterface ReadableByteStreamControllerCallback {\n  (controller: ReadableByteStreamController): void | PromiseLike<void>;\n}\n\ninterface UnderlyingByteSource {\n  autoAllocateChunkSize?: number;\n  cancel?: ReadableStreamErrorCallback;\n  pull?: ReadableByteStreamControllerCallback;\n  start?: ReadableByteStreamControllerCallback;\n  type: \"bytes\";\n}\n\ninterface UnderlyingSink<W = any> {\n  abort?: WritableStreamErrorCallback;\n  close?: WritableStreamDefaultControllerCloseCallback;\n  start?: WritableStreamDefaultControllerStartCallback;\n  type?: undefined;\n  write?: WritableStreamDefaultControllerWriteCallback<W>;\n}\n\ninterface UnderlyingSource<R = any> {\n  cancel?: ReadableStreamErrorCallback;\n  pull?: ReadableStreamDefaultControllerCallback<R>;\n  start?: ReadableStreamDefaultControllerCallback<R>;\n  type?: undefined;\n}\n\ninterface ReadableStreamErrorCallback {\n  (reason: any): void | PromiseLike<void>;\n}\n\ninterface ReadableStreamDefaultControllerCallback<R> {\n  (controller: ReadableStreamDefaultController<R>): void | PromiseLike<void>;\n}\n\ninterface ReadableStreamDefaultController<R = any> {\n  readonly desiredSize: number | null;\n  close(): void;\n  enqueue(chunk: R): void;\n  error(error?: any): void;\n}\n\ndeclare var ReadableStreamDefaultController: {\n  prototype: ReadableStreamDefaultController;\n  new (): ReadableStreamDefaultController;\n};\n\ninterface ReadableByteStreamController {\n  readonly byobRequest: undefined;\n  readonly desiredSize: number | null;\n  close(): void;\n  enqueue(chunk: ArrayBufferView): void;\n  error(error?: any): void;\n}\n\ndeclare var ReadableByteStreamController: {\n  prototype: ReadableByteStreamController;\n  new (): ReadableByteStreamController;\n};\n\ninterface PipeOptions {\n  preventAbort?: boolean;\n  preventCancel?: boolean;\n  preventClose?: boolean;\n  signal?: AbortSignal;\n}\n\ninterface QueuingStrategySizeCallback<T = any> {\n  (chunk: T): number;\n}\n\ninterface QueuingStrategy<T = any> {\n  highWaterMark?: number;\n  size?: QueuingStrategySizeCallback<T>;\n}\n\n/** This Streams API interface provides a built-in byte length queuing strategy\n * that can be used when constructing streams. */\ndeclare class CountQueuingStrategy implements QueuingStrategy {\n  constructor(options: { highWaterMark: number });\n  highWaterMark: number;\n  size(chunk: any): 1;\n}\n\ndeclare class ByteLengthQueuingStrategy\n  implements QueuingStrategy<ArrayBufferView> {\n  constructor(options: { highWaterMark: number });\n  highWaterMark: number;\n  size(chunk: ArrayBufferView): number;\n}\n\n/** This Streams API interface represents a readable stream of byte data. The\n * Fetch API offers a concrete instance of a ReadableStream through the body\n * property of a Response object. */\ninterface ReadableStream<R = any> {\n  readonly locked: boolean;\n  cancel(reason?: any): Promise<void>;\n  /**\n   * @deprecated This is no longer part of the Streams standard and the async\n   *             iterable should be obtained by just using the stream as an\n   *             async iterator.\n   */\n  getIterator(options?: { preventCancel?: boolean }): AsyncIterableIterator<R>;\n  getReader(): ReadableStreamDefaultReader<R>;\n  pipeThrough<T>(\n    { writable, readable }: {\n      writable: WritableStream<R>;\n      readable: ReadableStream<T>;\n    },\n    options?: PipeOptions,\n  ): ReadableStream<T>;\n  pipeTo(dest: WritableStream<R>, options?: PipeOptions): Promise<void>;\n  tee(): [ReadableStream<R>, ReadableStream<R>];\n  [Symbol.asyncIterator](options?: {\n    preventCancel?: boolean;\n  }): AsyncIterableIterator<R>;\n}\n\ndeclare var ReadableStream: {\n  prototype: ReadableStream;\n  new (\n    underlyingSource: UnderlyingByteSource,\n    strategy?: { highWaterMark?: number; size?: undefined },\n  ): ReadableStream<Uint8Array>;\n  new <R = any>(\n    underlyingSource?: UnderlyingSource<R>,\n    strategy?: QueuingStrategy<R>,\n  ): ReadableStream<R>;\n};\n\ninterface WritableStreamDefaultControllerCloseCallback {\n  (): void | PromiseLike<void>;\n}\n\ninterface WritableStreamDefaultControllerStartCallback {\n  (controller: WritableStreamDefaultController): void | PromiseLike<void>;\n}\n\ninterface WritableStreamDefaultControllerWriteCallback<W> {\n  (chunk: W, controller: WritableStreamDefaultController):\n    | void\n    | PromiseLike<\n      void\n    >;\n}\n\ninterface WritableStreamErrorCallback {\n  (reason: any): void | PromiseLike<void>;\n}\n\n/** This Streams API interface provides a standard abstraction for writing\n * streaming data to a destination, known as a sink. This object comes with\n * built-in backpressure and queuing. */\ninterface WritableStream<W = any> {\n  readonly locked: boolean;\n  abort(reason?: any): Promise<void>;\n  getWriter(): WritableStreamDefaultWriter<W>;\n}\n\ndeclare var WritableStream: {\n  prototype: WritableStream;\n  new <W = any>(\n    underlyingSink?: UnderlyingSink<W>,\n    strategy?: QueuingStrategy<W>,\n  ): WritableStream<W>;\n};\n\n/** This Streams API interface represents a controller allowing control of a\n * WritableStream's state. When constructing a WritableStream, the underlying\n * sink is given a corresponding WritableStreamDefaultController instance to\n * manipulate. */\ninterface WritableStreamDefaultController {\n  error(error?: any): void;\n}\n\n/** This Streams API interface is the object returned by\n * WritableStream.getWriter() and once created locks the < writer to the\n * WritableStream ensuring that no other streams can write to the underlying\n * sink. */\ninterface WritableStreamDefaultWriter<W = any> {\n  readonly closed: Promise<void>;\n  readonly desiredSize: number | null;\n  readonly ready: Promise<void>;\n  abort(reason?: any): Promise<void>;\n  close(): Promise<void>;\n  releaseLock(): void;\n  write(chunk: W): Promise<void>;\n}\n\ndeclare var WritableStreamDefaultWriter: {\n  prototype: WritableStreamDefaultWriter;\n  new (): WritableStreamDefaultWriter;\n};\n\ninterface TransformStream<I = any, O = any> {\n  readonly readable: ReadableStream<O>;\n  readonly writable: WritableStream<I>;\n}\n\ndeclare var TransformStream: {\n  prototype: TransformStream;\n  new <I = any, O = any>(\n    transformer?: Transformer<I, O>,\n    writableStrategy?: QueuingStrategy<I>,\n    readableStrategy?: QueuingStrategy<O>,\n  ): TransformStream<I, O>;\n};\n\ninterface TransformStreamDefaultController<O = any> {\n  readonly desiredSize: number | null;\n  enqueue(chunk: O): void;\n  error(reason?: any): void;\n  terminate(): void;\n}\n\ninterface Transformer<I = any, O = any> {\n  flush?: TransformStreamDefaultControllerCallback<O>;\n  readableType?: undefined;\n  start?: TransformStreamDefaultControllerCallback<O>;\n  transform?: TransformStreamDefaultControllerTransformCallback<I, O>;\n  writableType?: undefined;\n}\n\ninterface TransformStreamDefaultControllerCallback<O> {\n  (controller: TransformStreamDefaultController<O>): void | PromiseLike<void>;\n}\n\ninterface TransformStreamDefaultControllerTransformCallback<I, O> {\n  (\n    chunk: I,\n    controller: TransformStreamDefaultController<O>,\n  ): void | PromiseLike<void>;\n}\n\ntype BlobPart = BufferSource | Blob | string;\n\ninterface BlobPropertyBag {\n  type?: string;\n  endings?: \"transparent\" | \"native\";\n}\n\n/** A file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system. */\ndeclare class Blob {\n  constructor(blobParts?: BlobPart[], options?: BlobPropertyBag);\n\n  readonly size: number;\n  readonly type: string;\n  arrayBuffer(): Promise<ArrayBuffer>;\n  slice(start?: number, end?: number, contentType?: string): Blob;\n  stream(): ReadableStream;\n  text(): Promise<string>;\n}\n\ninterface FilePropertyBag extends BlobPropertyBag {\n  lastModified?: number;\n}\n\n/** Provides information about files and allows JavaScript in a web page to\n * access their content. */\ndeclare class File extends Blob {\n  constructor(\n    fileBits: BlobPart[],\n    fileName: string,\n    options?: FilePropertyBag,\n  );\n\n  readonly lastModified: number;\n  readonly name: string;\n}\n\ntype FormDataEntryValue = File | string;\n\n/** Provides a way to easily construct a set of key/value pairs representing\n * form fields and their values, which can then be easily sent using the\n * XMLHttpRequest.send() method. It uses the same format a form would use if the\n * encoding type were set to \"multipart/form-data\". */\ndeclare class FormData implements DomIterable<string, FormDataEntryValue> {\n  // TODO(ry) FormData constructor is non-standard.\n  // new(form?: HTMLFormElement): FormData;\n  constructor();\n\n  append(name: string, value: string | Blob, fileName?: string): void;\n  delete(name: string): void;\n  get(name: string): FormDataEntryValue | null;\n  getAll(name: string): FormDataEntryValue[];\n  has(name: string): boolean;\n  set(name: string, value: string | Blob, fileName?: string): void;\n  keys(): IterableIterator<string>;\n  values(): IterableIterator<string>;\n  entries(): IterableIterator<[string, FormDataEntryValue]>;\n  [Symbol.iterator](): IterableIterator<[string, FormDataEntryValue]>;\n  forEach(\n    callback: (value: FormDataEntryValue, key: string, parent: this) => void,\n    thisArg?: any,\n  ): void;\n}\n\ninterface Body {\n  /** A simple getter used to expose a `ReadableStream` of the body contents. */\n  readonly body: ReadableStream<Uint8Array> | null;\n  /** Stores a `Boolean` that declares whether the body has been used in a\n   * response yet.\n   */\n  readonly bodyUsed: boolean;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with an `ArrayBuffer`.\n   */\n  arrayBuffer(): Promise<ArrayBuffer>;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with a `Blob`.\n   */\n  blob(): Promise<Blob>;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with a `FormData` object.\n   */\n  formData(): Promise<FormData>;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with the result of parsing the body text as JSON.\n   */\n  json(): Promise<any>;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with a `USVString` (text).\n   */\n  text(): Promise<string>;\n}\n\ntype HeadersInit = Headers | string[][] | Record<string, string>;\n\n/** This Fetch API interface allows you to perform various actions on HTTP\n * request and response headers. These actions include retrieving, setting,\n * adding to, and removing. A Headers object has an associated header list,\n * which is initially empty and consists of zero or more name and value pairs.\n * You can add to this using methods like append() (see Examples). In all\n * methods of this interface, header names are matched by case-insensitive byte\n * sequence. */\ninterface Headers {\n  append(name: string, value: string): void;\n  delete(name: string): void;\n  get(name: string): string | null;\n  has(name: string): boolean;\n  set(name: string, value: string): void;\n  forEach(\n    callbackfn: (value: string, key: string, parent: Headers) => void,\n    thisArg?: any,\n  ): void;\n}\n\ndeclare class Headers implements DomIterable<string, string> {\n  constructor(init?: HeadersInit);\n\n  /** Appends a new value onto an existing header inside a `Headers` object, or\n   * adds the header if it does not already exist.\n   */\n  append(name: string, value: string): void;\n  /** Deletes a header from a `Headers` object. */\n  delete(name: string): void;\n  /** Returns an iterator allowing to go through all key/value pairs\n   * contained in this Headers object. The both the key and value of each pairs\n   * are ByteString objects.\n   */\n  entries(): IterableIterator<[string, string]>;\n  /** Returns a `ByteString` sequence of all the values of a header within a\n   * `Headers` object with a given name.\n   */\n  get(name: string): string | null;\n  /** Returns a boolean stating whether a `Headers` object contains a certain\n   * header.\n   */\n  has(name: string): boolean;\n  /** Returns an iterator allowing to go through all keys contained in\n   * this Headers object. The keys are ByteString objects.\n   */\n  keys(): IterableIterator<string>;\n  /** Sets a new value for an existing header inside a Headers object, or adds\n   * the header if it does not already exist.\n   */\n  set(name: string, value: string): void;\n  /** Returns an iterator allowing to go through all values contained in\n   * this Headers object. The values are ByteString objects.\n   */\n  values(): IterableIterator<string>;\n  forEach(\n    callbackfn: (value: string, key: string, parent: this) => void,\n    thisArg?: any,\n  ): void;\n  /** The Symbol.iterator well-known symbol specifies the default\n   * iterator for this Headers object\n   */\n  [Symbol.iterator](): IterableIterator<[string, string]>;\n}\n\ntype RequestInfo = Request | string;\ntype RequestCache =\n  | \"default\"\n  | \"force-cache\"\n  | \"no-cache\"\n  | \"no-store\"\n  | \"only-if-cached\"\n  | \"reload\";\ntype RequestCredentials = \"include\" | \"omit\" | \"same-origin\";\ntype RequestMode = \"cors\" | \"navigate\" | \"no-cors\" | \"same-origin\";\ntype RequestRedirect = \"error\" | \"follow\" | \"manual\";\ntype ReferrerPolicy =\n  | \"\"\n  | \"no-referrer\"\n  | \"no-referrer-when-downgrade\"\n  | \"origin\"\n  | \"origin-when-cross-origin\"\n  | \"same-origin\"\n  | \"strict-origin\"\n  | \"strict-origin-when-cross-origin\"\n  | \"unsafe-url\";\ntype BodyInit =\n  | Blob\n  | BufferSource\n  | FormData\n  | URLSearchParams\n  | ReadableStream<Uint8Array>\n  | string;\ntype RequestDestination =\n  | \"\"\n  | \"audio\"\n  | \"audioworklet\"\n  | \"document\"\n  | \"embed\"\n  | \"font\"\n  | \"image\"\n  | \"manifest\"\n  | \"object\"\n  | \"paintworklet\"\n  | \"report\"\n  | \"script\"\n  | \"sharedworker\"\n  | \"style\"\n  | \"track\"\n  | \"video\"\n  | \"worker\"\n  | \"xslt\";\n\ninterface RequestInit {\n  /**\n   * A BodyInit object or null to set request's body.\n   */\n  body?: BodyInit | null;\n  /**\n   * A string indicating how the request will interact with the browser's cache\n   * to set request's cache.\n   */\n  cache?: RequestCache;\n  /**\n   * A string indicating whether credentials will be sent with the request\n   * always, never, or only when sent to a same-origin URL. Sets request's\n   * credentials.\n   */\n  credentials?: RequestCredentials;\n  /**\n   * A Headers object, an object literal, or an array of two-item arrays to set\n   * request's headers.\n   */\n  headers?: HeadersInit;\n  /**\n   * A cryptographic hash of the resource to be fetched by request. Sets\n   * request's integrity.\n   */\n  integrity?: string;\n  /**\n   * A boolean to set request's keepalive.\n   */\n  keepalive?: boolean;\n  /**\n   * A string to set request's method.\n   */\n  method?: string;\n  /**\n   * A string to indicate whether the request will use CORS, or will be\n   * restricted to same-origin URLs. Sets request's mode.\n   */\n  mode?: RequestMode;\n  /**\n   * A string indicating whether request follows redirects, results in an error\n   * upon encountering a redirect, or returns the redirect (in an opaque\n   * fashion). Sets request's redirect.\n   */\n  redirect?: RequestRedirect;\n  /**\n   * A string whose value is a same-origin URL, \"about:client\", or the empty\n   * string, to set request's referrer.\n   */\n  referrer?: string;\n  /**\n   * A referrer policy to set request's referrerPolicy.\n   */\n  referrerPolicy?: ReferrerPolicy;\n  /**\n   * An AbortSignal to set request's signal.\n   */\n  signal?: AbortSignal | null;\n  /**\n   * Can only be null. Used to disassociate request from any Window.\n   */\n  window?: any;\n}\n\n/** This Fetch API interface represents a resource request. */\ndeclare class Request implements Body {\n  constructor(input: RequestInfo, init?: RequestInit);\n\n  /**\n   * Returns the cache mode associated with request, which is a string\n   * indicating how the request will interact with the browser's cache when\n   * fetching.\n   */\n  readonly cache: RequestCache;\n  /**\n   * Returns the credentials mode associated with request, which is a string\n   * indicating whether credentials will be sent with the request always, never,\n   * or only when sent to a same-origin URL.\n   */\n  readonly credentials: RequestCredentials;\n  /**\n   * Returns the kind of resource requested by request, e.g., \"document\" or \"script\".\n   */\n  readonly destination: RequestDestination;\n  /**\n   * Returns a Headers object consisting of the headers associated with request.\n   * Note that headers added in the network layer by the user agent will not be\n   * accounted for in this object, e.g., the \"Host\" header.\n   */\n  readonly headers: Headers;\n  /**\n   * Returns request's subresource integrity metadata, which is a cryptographic\n   * hash of the resource being fetched. Its value consists of multiple hashes\n   * separated by whitespace. [SRI]\n   */\n  readonly integrity: string;\n  /**\n   * Returns a boolean indicating whether or not request is for a history\n   * navigation (a.k.a. back-forward navigation).\n   */\n  readonly isHistoryNavigation: boolean;\n  /**\n   * Returns a boolean indicating whether or not request is for a reload\n   * navigation.\n   */\n  readonly isReloadNavigation: boolean;\n  /**\n   * Returns a boolean indicating whether or not request can outlive the global\n   * in which it was created.\n   */\n  readonly keepalive: boolean;\n  /**\n   * Returns request's HTTP method, which is \"GET\" by default.\n   */\n  readonly method: string;\n  /**\n   * Returns the mode associated with request, which is a string indicating\n   * whether the request will use CORS, or will be restricted to same-origin\n   * URLs.\n   */\n  readonly mode: RequestMode;\n  /**\n   * Returns the redirect mode associated with request, which is a string\n   * indicating how redirects for the request will be handled during fetching. A\n   * request will follow redirects by default.\n   */\n  readonly redirect: RequestRedirect;\n  /**\n   * Returns the referrer of request. Its value can be a same-origin URL if\n   * explicitly set in init, the empty string to indicate no referrer, and\n   * \"about:client\" when defaulting to the global's default. This is used during\n   * fetching to determine the value of the `Referer` header of the request\n   * being made.\n   */\n  readonly referrer: string;\n  /**\n   * Returns the referrer policy associated with request. This is used during\n   * fetching to compute the value of the request's referrer.\n   */\n  readonly referrerPolicy: ReferrerPolicy;\n  /**\n   * Returns the signal associated with request, which is an AbortSignal object\n   * indicating whether or not request has been aborted, and its abort event\n   * handler.\n   */\n  readonly signal: AbortSignal;\n  /**\n   * Returns the URL of request as a string.\n   */\n  readonly url: string;\n  clone(): Request;\n\n  /** A simple getter used to expose a `ReadableStream` of the body contents. */\n  readonly body: ReadableStream<Uint8Array> | null;\n  /** Stores a `Boolean` that declares whether the body has been used in a\n   * response yet.\n   */\n  readonly bodyUsed: boolean;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with an `ArrayBuffer`.\n   */\n  arrayBuffer(): Promise<ArrayBuffer>;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with a `Blob`.\n   */\n  blob(): Promise<Blob>;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with a `FormData` object.\n   */\n  formData(): Promise<FormData>;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with the result of parsing the body text as JSON.\n   */\n  json(): Promise<any>;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with a `USVString` (text).\n   */\n  text(): Promise<string>;\n}\n\ninterface ResponseInit {\n  headers?: HeadersInit;\n  status?: number;\n  statusText?: string;\n}\n\ntype ResponseType =\n  | \"basic\"\n  | \"cors\"\n  | \"default\"\n  | \"error\"\n  | \"opaque\"\n  | \"opaqueredirect\";\n\n/** This Fetch API interface represents the response to a request. */\ndeclare class Response implements Body {\n  constructor(body?: BodyInit | null, init?: ResponseInit);\n  static error(): Response;\n  static redirect(url: string, status?: number): Response;\n\n  readonly headers: Headers;\n  readonly ok: boolean;\n  readonly redirected: boolean;\n  readonly status: number;\n  readonly statusText: string;\n  readonly trailer: Promise<Headers>;\n  readonly type: ResponseType;\n  readonly url: string;\n  clone(): Response;\n\n  /** A simple getter used to expose a `ReadableStream` of the body contents. */\n  readonly body: ReadableStream<Uint8Array> | null;\n  /** Stores a `Boolean` that declares whether the body has been used in a\n   * response yet.\n   */\n  readonly bodyUsed: boolean;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with an `ArrayBuffer`.\n   */\n  arrayBuffer(): Promise<ArrayBuffer>;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with a `Blob`.\n   */\n  blob(): Promise<Blob>;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with a `FormData` object.\n   */\n  formData(): Promise<FormData>;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with the result of parsing the body text as JSON.\n   */\n  json(): Promise<any>;\n  /** Takes a `Response` stream and reads it to completion. It returns a promise\n   * that resolves with a `USVString` (text).\n   */\n  text(): Promise<string>;\n}\n\n/** Fetch a resource from the network. It returns a Promise that resolves to the\n * Response to that request, whether it is successful or not.\n *\n *     const response = await fetch(\"http://my.json.host/data.json\");\n *     console.log(response.status);  // e.g. 200\n *     console.log(response.statusText); // e.g. \"OK\"\n *     const jsonData = await response.json();\n */\ndeclare function fetch(\n  input: Request | URL | string,\n  init?: RequestInit,\n): Promise<Response>;\n\n// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.\n\n// deno-lint-ignore-file no-explicit-any no-empty-interface\n\n/// <reference no-default-lib=\"true\" />\n/// <reference lib=\"esnext\" />\n\n// 8cc98b6f10b7f354473a08c3773bb1de839845b9\n\ninterface GPUObjectBase {\n  label: string | null;\n}\n\ndeclare interface GPUObjectDescriptorBase {\n  label?: string;\n}\n\ndeclare class GPUAdapterLimits {\n  maxTextureDimension1D?: number;\n  maxTextureDimension2D?: number;\n  maxTextureDimension3D?: number;\n  maxTextureArrayLayers?: number;\n  maxBindGroups?: number;\n  maxDynamicUniformBuffersPerPipelineLayout?: number;\n  maxDynamicStorageBuffersPerPipelineLayout?: number;\n  maxSampledTexturesPerShaderStage?: number;\n  maxSamplersPerShaderStage?: number;\n  maxStorageBuffersPerShaderStage?: number;\n  maxStorageTexturesPerShaderStage?: number;\n  maxUniformBuffersPerShaderStage?: number;\n  maxUniformBufferBindingSize?: number;\n  maxStorageBufferBindingSize?: number;\n  maxVertexBuffers?: number;\n  maxVertexAttributes?: number;\n  maxVertexBufferArrayStride?: number;\n}\n\ndeclare class GPUAdapterFeatures {\n  forEach(\n    callbackfn: (\n      value: GPUFeatureName,\n      value2: GPUFeatureName,\n      set: Set<GPUFeatureName>,\n    ) => void,\n    thisArg?: any,\n  ): void;\n  has(value: GPUFeatureName): boolean;\n  size: number;\n  [\n    Symbol\n      .iterator\n  ](): IterableIterator<GPUFeatureName>;\n  entries(): IterableIterator<[GPUFeatureName, GPUFeatureName]>;\n  keys(): IterableIterator<GPUFeatureName>;\n  values(): IterableIterator<GPUFeatureName>;\n}\n\ndeclare class GPU {\n  requestAdapter(\n    options?: GPURequestAdapterOptions,\n  ): Promise<GPUAdapter | null>;\n}\n\ndeclare interface GPURequestAdapterOptions {\n  powerPreference?: GPUPowerPreference;\n}\n\ndeclare type GPUPowerPreference = \"low-power\" | \"high-performance\";\n\ndeclare class GPUAdapter {\n  readonly name: string;\n  readonly features: GPUAdapterFeatures;\n  readonly limits: GPUAdapterLimits;\n\n  requestDevice(descriptor?: GPUDeviceDescriptor): Promise<GPUDevice | null>;\n}\n\ndeclare interface GPUDeviceDescriptor extends GPUObjectDescriptorBase {\n  nonGuaranteedFeatures?: GPUFeatureName[];\n  nonGuaranteedLimits?: Record<string, number>;\n}\n\ndeclare type GPUFeatureName =\n  | \"depth-clamping\"\n  | \"depth24unorm-stencil8\"\n  | \"depth32float-stencil8\"\n  | \"pipeline-statistics-query\"\n  | \"texture-compression-bc\"\n  | \"timestamp-query\"\n  // extended from spec\n  | \"mappable-primary-buffers\"\n  | \"sampled-texture-binding-array\"\n  | \"sampled-texture-array-dynamic-indexing\"\n  | \"sampled-texture-array-non-uniform-indexing\"\n  | \"unsized-binding-array\"\n  | \"multi-draw-indirect\"\n  | \"multi-draw-indirect-count\"\n  | \"push-constants\"\n  | \"address-mode-clamp-to-border\"\n  | \"non-fill-polygon-mode\"\n  | \"texture-compression-etc2\"\n  | \"texture-compression-astc-ldr\"\n  | \"texture-adapter-specific-format-features\"\n  | \"shader-float64\"\n  | \"vertex-attribute-64bit\";\n\ndeclare class GPUDevice extends EventTarget implements GPUObjectBase {\n  label: string | null;\n\n  readonly lost: Promise<GPUDeviceLostInfo>;\n  pushErrorScope(filter: GPUErrorFilter): undefined;\n  popErrorScope(): Promise<GPUError | null>;\n  onuncapturederror:\n    | ((this: GPUDevice, ev: GPUUncapturedErrorEvent) => any)\n    | null;\n\n  readonly adapter: GPUAdapter;\n  readonly features: ReadonlyArray<GPUFeatureName>;\n  readonly limits: Record<string, number>;\n  readonly queue: GPUQueue;\n\n  destroy(): undefined;\n\n  createBuffer(descriptor: GPUBufferDescriptor): GPUBuffer;\n  createTexture(descriptor: GPUTextureDescriptor): GPUTexture;\n  createSampler(descriptor?: GPUSamplerDescriptor): GPUSampler;\n\n  createBindGroupLayout(\n    descriptor: GPUBindGroupLayoutDescriptor,\n  ): GPUBindGroupLayout;\n  createPipelineLayout(\n    descriptor: GPUPipelineLayoutDescriptor,\n  ): GPUPipelineLayout;\n  createBindGroup(descriptor: GPUBindGroupDescriptor): GPUBindGroup;\n\n  createShaderModule(descriptor: GPUShaderModuleDescriptor): GPUShaderModule;\n  createComputePipeline(\n    descriptor: GPUComputePipelineDescriptor,\n  ): GPUComputePipeline;\n  createRenderPipeline(\n    descriptor: GPURenderPipelineDescriptor,\n  ): GPURenderPipeline;\n  createComputePipelineAsync(\n    descriptor: GPUComputePipelineDescriptor,\n  ): Promise<GPUComputePipeline>;\n  createRenderPipelineAsync(\n    descriptor: GPURenderPipelineDescriptor,\n  ): Promise<GPURenderPipeline>;\n\n  createCommandEncoder(\n    descriptor?: GPUCommandEncoderDescriptor,\n  ): GPUCommandEncoder;\n  createRenderBundleEncoder(\n    descriptor: GPURenderBundleEncoderDescriptor,\n  ): GPURenderBundleEncoder;\n\n  createQuerySet(descriptor: GPUQuerySetDescriptor): GPUQuerySet;\n}\n\ndeclare class GPUBuffer implements GPUObjectBase {\n  label: string | null;\n\n  mapAsync(\n    mode: GPUMapModeFlags,\n    offset?: number,\n    size?: number,\n  ): Promise<undefined>;\n  getMappedRange(offset?: number, size?: number): ArrayBuffer;\n  unmap(): undefined;\n\n  destroy(): undefined;\n}\n\ndeclare interface GPUBufferDescriptor extends GPUObjectDescriptorBase {\n  size: number;\n  usage: GPUBufferUsageFlags;\n  mappedAtCreation?: boolean;\n}\n\ndeclare type GPUBufferUsageFlags = number;\ndeclare class GPUBufferUsage {\n  static MAP_READ: 0x0001;\n  static MAP_WRITE: 0x0002;\n  static COPY_SRC: 0x0004;\n  static COPY_DST: 0x0008;\n  static INDEX: 0x0010;\n  static VERTEX: 0x0020;\n  static UNIFORM: 0x0040;\n  static STORAGE: 0x0080;\n  static INDIRECT: 0x0100;\n  static QUERY_RESOLVE: 0x0200;\n}\n\ndeclare type GPUMapModeFlags = number;\ndeclare class GPUMapMode {\n  static READ: 0x0001;\n  static WRITE: 0x0002;\n}\n\ndeclare class GPUTexture implements GPUObjectBase {\n  label: string | null;\n\n  createView(descriptor?: GPUTextureViewDescriptor): GPUTextureView;\n  destroy(): undefined;\n}\n\ndeclare interface GPUTextureDescriptor extends GPUObjectDescriptorBase {\n  size: GPUExtent3D;\n  mipLevelCount?: number;\n  sampleCount?: number;\n  dimension?: GPUTextureDimension;\n  format: GPUTextureFormat;\n  usage: GPUTextureUsageFlags;\n}\n\ndeclare type GPUTextureDimension = \"1d\" | \"2d\" | \"3d\";\n\ndeclare type GPUTextureUsageFlags = number;\ndeclare class GPUTextureUsage {\n  static COPY_SRC: 0x01;\n  static COPY_DST: 0x02;\n  static SAMPLED: 0x04;\n  static STORAGE: 0x08;\n  static RENDER_ATTACHMENT: 0x10;\n}\n\ndeclare class GPUTextureView implements GPUObjectBase {\n  label: string | null;\n}\n\ndeclare interface GPUTextureViewDescriptor extends GPUObjectDescriptorBase {\n  format?: GPUTextureFormat;\n  dimension?: GPUTextureViewDimension;\n  aspect?: GPUTextureAspect;\n  baseMipLevel?: number;\n  mipLevelCount?: number;\n  baseArrayLayer?: number;\n  arrayLayerCount?: number;\n}\n\ndeclare type GPUTextureViewDimension =\n  | \"1d\"\n  | \"2d\"\n  | \"2d-array\"\n  | \"cube\"\n  | \"cube-array\"\n  | \"3d\";\n\ndeclare type GPUTextureAspect = \"all\" | \"stencil-only\" | \"depth-only\";\n\ndeclare type GPUTextureFormat =\n  | \"r8unorm\"\n  | \"r8snorm\"\n  | \"r8uint\"\n  | \"r8sint\"\n  | \"r16uint\"\n  | \"r16sint\"\n  | \"r16float\"\n  | \"rg8unorm\"\n  | \"rg8snorm\"\n  | \"rg8uint\"\n  | \"rg8sint\"\n  | \"r32uint\"\n  | \"r32sint\"\n  | \"r32float\"\n  | \"rg16uint\"\n  | \"rg16sint\"\n  | \"rg16float\"\n  | \"rgba8unorm\"\n  | \"rgba8unorm-srgb\"\n  | \"rgba8snorm\"\n  | \"rgba8uint\"\n  | \"rgba8sint\"\n  | \"bgra8unorm\"\n  | \"bgra8unorm-srgb\"\n  | \"rgb9e5ufloat\"\n  | \"rgb10a2unorm\"\n  | \"rg11b10ufloat\"\n  | \"rg32uint\"\n  | \"rg32sint\"\n  | \"rg32float\"\n  | \"rgba16uint\"\n  | \"rgba16sint\"\n  | \"rgba16float\"\n  | \"rgba32uint\"\n  | \"rgba32sint\"\n  | \"rgba32float\"\n  | \"stencil8\"\n  | \"depth16unorm\"\n  | \"depth24plus\"\n  | \"depth24plus-stencil8\"\n  | \"depth32float\"\n  | \"bc1-rgba-unorm\"\n  | \"bc1-rgba-unorm-srgb\"\n  | \"bc2-rgba-unorm\"\n  | \"bc2-rgba-unorm-srgb\"\n  | \"bc3-rgba-unorm\"\n  | \"bc3-rgba-unorm-srgb\"\n  | \"bc4-r-unorm\"\n  | \"bc4-r-snorm\"\n  | \"bc5-rg-unorm\"\n  | \"bc5-rg-snorm\"\n  | \"bc6h-rgb-ufloat\"\n  | \"bc6h-rgb-float\"\n  | \"bc7-rgba-unorm\"\n  | \"bc7-rgba-unorm-srgb\"\n  | \"depth24unorm-stencil8\"\n  | \"depth32float-stencil8\";\n\ndeclare class GPUSampler implements GPUObjectBase {\n  label: string | null;\n}\n\ndeclare interface GPUSamplerDescriptor extends GPUObjectDescriptorBase {\n  addressModeU?: GPUAddressMode;\n  addressModeV?: GPUAddressMode;\n  addressModeW?: GPUAddressMode;\n  magFilter?: GPUFilterMode;\n  minFilter?: GPUFilterMode;\n  mipmapFilter?: GPUFilterMode;\n  lodMinClamp?: number;\n  lodMaxClamp?: number;\n  compare?: GPUCompareFunction;\n  maxAnisotropy?: number;\n}\n\ndeclare type GPUAddressMode = \"clamp-to-edge\" | \"repeat\" | \"mirror-repeat\";\n\ndeclare type GPUFilterMode = \"nearest\" | \"linear\";\n\ndeclare type GPUCompareFunction =\n  | \"never\"\n  | \"less\"\n  | \"equal\"\n  | \"less-equal\"\n  | \"greater\"\n  | \"not-equal\"\n  | \"greater-equal\"\n  | \"always\";\n\ndeclare class GPUBindGroupLayout implements GPUObjectBase {\n  label: string | null;\n}\n\ndeclare interface GPUBindGroupLayoutDescriptor extends GPUObjectDescriptorBase {\n  entries: GPUBindGroupLayoutEntry[];\n}\n\ndeclare interface GPUBindGroupLayoutEntry {\n  binding: number;\n  visibility: GPUShaderStageFlags;\n\n  buffer?: GPUBufferBindingLayout;\n  sampler?: GPUSamplerBindingLayout;\n  texture?: GPUTextureBindingLayout;\n  storageTexture?: GPUStorageTextureBindingLayout;\n}\n\ndeclare type GPUShaderStageFlags = number;\ndeclare class GPUShaderStage {\n  static VERTEX: 0x1;\n  static FRAGMENT: 0x2;\n  static COMPUTE: 0x4;\n}\n\ndeclare interface GPUBufferBindingLayout {\n  type?: GPUBufferBindingType;\n  hasDynamicOffset?: boolean;\n  minBindingSize?: number;\n}\n\ndeclare type GPUBufferBindingType = \"uniform\" | \"storage\" | \"read-only-storage\";\n\ndeclare interface GPUSamplerBindingLayout {\n  type?: GPUSamplerBindingType;\n}\n\ndeclare type GPUSamplerBindingType =\n  | \"filtering\"\n  | \"non-filtering\"\n  | \"comparison\";\n\ndeclare interface GPUTextureBindingLayout {\n  sampleType?: GPUTextureSampleType;\n  viewDimension?: GPUTextureViewDimension;\n  multisampled?: boolean;\n}\n\ndeclare type GPUTextureSampleType =\n  | \"float\"\n  | \"unfilterable-float\"\n  | \"depth\"\n  | \"sint\"\n  | \"uint\";\n\ndeclare interface GPUTextureBindingLayout {\n  sampleType?: GPUTextureSampleType;\n  viewDimension?: GPUTextureViewDimension;\n  multisampled?: boolean;\n}\n\ndeclare type GPUStorageTextureAccess = \"read-only\" | \"write-only\";\n\ndeclare interface GPUStorageTextureBindingLayout {\n  access: GPUStorageTextureAccess;\n  format: GPUTextureFormat;\n  viewDimension?: GPUTextureViewDimension;\n}\n\ndeclare class GPUBindGroup implements GPUObjectBase {\n  label: string | null;\n}\n\ndeclare interface GPUBindGroupDescriptor extends GPUObjectDescriptorBase {\n  layout: GPUBindGroupLayout;\n  entries: GPUBindGroupEntry[];\n}\n\ndeclare type GPUBindingResource =\n  | GPUSampler\n  | GPUTextureView\n  | GPUBufferBinding;\n\ndeclare interface GPUBindGroupEntry {\n  binding: number;\n  resource: GPUBindingResource;\n}\n\ndeclare interface GPUBufferBinding {\n  buffer: GPUBuffer;\n  offset?: number;\n  size?: number;\n}\n\ndeclare class GPUPipelineLayout implements GPUObjectBase {\n  label: string | null;\n}\n\ndeclare interface GPUPipelineLayoutDescriptor extends GPUObjectDescriptorBase {\n  bindGroupLayouts: GPUBindGroupLayout[];\n}\n\ndeclare type GPUCompilationMessageType = \"error\" | \"warning\" | \"info\";\n\ndeclare interface GPUCompilationMessage {\n  readonly message: string;\n  readonly type: GPUCompilationMessageType;\n  readonly lineNum: number;\n  readonly linePos: number;\n}\n\ndeclare interface GPUCompilationInfo {\n  readonly messages: ReadonlyArray<GPUCompilationMessage>;\n}\n\ndeclare class GPUShaderModule implements GPUObjectBase {\n  label: string | null;\n\n  compilationInfo(): Promise<GPUCompilationInfo>;\n}\n\ndeclare interface GPUShaderModuleDescriptor extends GPUObjectDescriptorBase {\n  code: string | Uint32Array;\n  sourceMap?: any;\n}\n\ndeclare interface GPUPipelineDescriptorBase extends GPUObjectDescriptorBase {\n  layout?: GPUPipelineLayout;\n}\n\ndeclare interface GPUPipelineBase {\n  getBindGroupLayout(index: number): GPUBindGroupLayout;\n}\n\ndeclare interface GPUProgrammableStage {\n  module: GPUShaderModule;\n  entryPoint: string;\n}\n\ndeclare class GPUComputePipeline implements GPUObjectBase, GPUPipelineBase {\n  label: string | null;\n\n  getBindGroupLayout(index: number): GPUBindGroupLayout;\n}\n\ndeclare interface GPUComputePipelineDescriptor\n  extends GPUPipelineDescriptorBase {\n  compute: GPUProgrammableStage;\n}\n\ndeclare class GPURenderPipeline implements GPUObjectBase, GPUPipelineBase {\n  label: string | null;\n\n  getBindGroupLayout(index: number): GPUBindGroupLayout;\n}\n\ndeclare interface GPURenderPipelineDescriptor\n  extends GPUPipelineDescriptorBase {\n  vertex: GPUVertexState;\n  primitive?: GPUPrimitiveState;\n  depthStencil?: GPUDepthStencilState;\n  multisample?: GPUMultisampleState;\n  fragment?: GPUFragmentState;\n}\n\ndeclare type GPUPrimitiveTopology =\n  | \"point-list\"\n  | \"line-list\"\n  | \"line-strip\"\n  | \"triangle-list\"\n  | \"triangle-strip\";\n\ndeclare interface GPUPrimitiveState {\n  topology?: GPUPrimitiveTopology;\n  stripIndexFormat?: GPUIndexFormat;\n  frontFace?: GPUFrontFace;\n  cullMode?: GPUCullMode;\n}\n\ndeclare type GPUFrontFace = \"ccw\" | \"cw\";\n\ndeclare type GPUCullMode = \"none\" | \"front\" | \"back\";\n\ndeclare interface GPUMultisampleState {\n  count?: number;\n  mask?: number;\n  alphaToCoverageEnabled?: boolean;\n}\n\ndeclare interface GPUFragmentState extends GPUProgrammableStage {\n  targets: GPUColorTargetState[];\n}\n\ndeclare interface GPUColorTargetState {\n  format: GPUTextureFormat;\n\n  blend?: GPUBlendState;\n  writeMask?: GPUColorWriteFlags;\n}\n\ndeclare interface GPUBlendState {\n  color: GPUBlendComponent;\n  alpha: GPUBlendComponent;\n}\n\ndeclare type GPUColorWriteFlags = number;\ndeclare class GPUColorWrite {\n  static RED: 0x1;\n  static GREEN: 0x2;\n  static BLUE: 0x4;\n  static ALPHA: 0x8;\n  static ALL: 0xF;\n}\n\ndeclare interface GPUBlendComponent {\n  srcFactor: GPUBlendFactor;\n  dstFactor: GPUBlendFactor;\n  operation: GPUBlendOperation;\n}\n\ndeclare type GPUBlendFactor =\n  | \"zero\"\n  | \"one\"\n  | \"src-color\"\n  | \"one-minus-src-color\"\n  | \"src-alpha\"\n  | \"one-minus-src-alpha\"\n  | \"dst-color\"\n  | \"one-minus-dst-color\"\n  | \"dst-alpha\"\n  | \"one-minus-dst-alpha\"\n  | \"src-alpha-saturated\"\n  | \"blend-color\"\n  | \"one-minus-blend-color\";\n\ndeclare type GPUBlendOperation =\n  | \"add\"\n  | \"subtract\"\n  | \"reverse-subtract\"\n  | \"min\"\n  | \"max\";\n\ndeclare interface GPUDepthStencilState {\n  format: GPUTextureFormat;\n\n  depthWriteEnabled?: boolean;\n  depthCompare?: GPUCompareFunction;\n\n  stencilFront?: GPUStencilFaceState;\n  stencilBack?: GPUStencilFaceState;\n\n  stencilReadMask?: number;\n  stencilWriteMask?: number;\n\n  depthBias?: number;\n  depthBiasSlopeScale?: number;\n  depthBiasClamp?: number;\n\n  clampDepth?: boolean;\n}\n\ndeclare interface GPUStencilFaceState {\n  compare?: GPUCompareFunction;\n  failOp?: GPUStencilOperation;\n  depthFailOp?: GPUStencilOperation;\n  passOp?: GPUStencilOperation;\n}\n\ndeclare type GPUStencilOperation =\n  | \"keep\"\n  | \"zero\"\n  | \"replace\"\n  | \"invert\"\n  | \"increment-clamp\"\n  | \"decrement-clamp\"\n  | \"increment-wrap\"\n  | \"decrement-wrap\";\n\ndeclare type GPUIndexFormat = \"uint16\" | \"uint32\";\n\ndeclare type GPUVertexFormat =\n  | \"uchar2\"\n  | \"uchar4\"\n  | \"char2\"\n  | \"char4\"\n  | \"uchar2norm\"\n  | \"uchar4norm\"\n  | \"char2norm\"\n  | \"char4norm\"\n  | \"ushort2\"\n  | \"ushort4\"\n  | \"short2\"\n  | \"short4\"\n  | \"ushort2norm\"\n  | \"ushort4norm\"\n  | \"short2norm\"\n  | \"short4norm\"\n  | \"half2\"\n  | \"half4\"\n  | \"float\"\n  | \"float2\"\n  | \"float3\"\n  | \"float4\"\n  | \"uint\"\n  | \"uint2\"\n  | \"uint3\"\n  | \"uint4\"\n  | \"int\"\n  | \"int2\"\n  | \"int3\"\n  | \"int4\";\n\ndeclare type GPUInputStepMode = \"vertex\" | \"instance\";\n\ndeclare interface GPUVertexState extends GPUProgrammableStage {\n  buffers?: (GPUVertexBufferLayout | null)[];\n}\n\ndeclare interface GPUVertexBufferLayout {\n  arrayStride: number;\n  stepMode?: GPUInputStepMode;\n  attributes: GPUVertexAttribute[];\n}\n\ndeclare interface GPUVertexAttribute {\n  format: GPUVertexFormat;\n  offset: number;\n\n  shaderLocation: number;\n}\n\ndeclare class GPUCommandBuffer implements GPUObjectBase {\n  label: string | null;\n\n  readonly executionTime: Promise<number>;\n}\n\ndeclare interface GPUCommandBufferDescriptor extends GPUObjectDescriptorBase {}\n\ndeclare class GPUCommandEncoder implements GPUObjectBase {\n  label: string | null;\n\n  beginRenderPass(descriptor: GPURenderPassDescriptor): GPURenderPassEncoder;\n  beginComputePass(\n    descriptor?: GPUComputePassDescriptor,\n  ): GPUComputePassEncoder;\n\n  copyBufferToBuffer(\n    source: GPUBuffer,\n    sourceOffset: number,\n    destination: GPUBuffer,\n    destinationOffset: number,\n    size: number,\n  ): undefined;\n\n  copyBufferToTexture(\n    source: GPUImageCopyBuffer,\n    destination: GPUImageCopyTexture,\n    copySize: GPUExtent3D,\n  ): undefined;\n\n  copyTextureToBuffer(\n    source: GPUImageCopyTexture,\n    destination: GPUImageCopyBuffer,\n    copySize: GPUExtent3D,\n  ): undefined;\n\n  copyTextureToTexture(\n    source: GPUImageCopyTexture,\n    destination: GPUImageCopyTexture,\n    copySize: GPUExtent3D,\n  ): undefined;\n\n  pushDebugGroup(groupLabel: string): undefined;\n  popDebugGroup(): undefined;\n  insertDebugMarker(markerLabel: string): undefined;\n\n  writeTimestamp(querySet: GPUQuerySet, queryIndex: number): undefined;\n\n  resolveQuerySet(\n    querySet: GPUQuerySet,\n    firstQuery: number,\n    queryCount: number,\n    destination: GPUBuffer,\n    destinationOffset: number,\n  ): undefined;\n\n  finish(descriptor?: GPUCommandBufferDescriptor): GPUCommandBuffer;\n}\n\ndeclare interface GPUCommandEncoderDescriptor extends GPUObjectDescriptorBase {\n  measureExecutionTime?: boolean;\n}\n\ndeclare interface GPUImageDataLayout {\n  offset?: number;\n  bytesPerRow?: number;\n  rowsPerImage?: number;\n}\n\ndeclare interface GPUImageCopyBuffer extends GPUImageDataLayout {\n  buffer: GPUBuffer;\n}\n\ndeclare interface GPUImageCopyTexture {\n  texture: GPUTexture;\n  mipLevel?: number;\n  origin?: GPUOrigin3D;\n  aspect?: GPUTextureAspect;\n}\n\ninterface GPUProgrammablePassEncoder {\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup,\n    dynamicOffsets?: number[],\n  ): undefined;\n\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup,\n    dynamicOffsetsData: Uint32Array,\n    dynamicOffsetsDataStart: number,\n    dynamicOffsetsDataLength: number,\n  ): undefined;\n\n  pushDebugGroup(groupLabel: string): undefined;\n  popDebugGroup(): undefined;\n  insertDebugMarker(markerLabel: string): undefined;\n}\n\ndeclare class GPUComputePassEncoder\n  implements GPUObjectBase, GPUProgrammablePassEncoder {\n  label: string | null;\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup,\n    dynamicOffsets?: number[],\n  ): undefined;\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup,\n    dynamicOffsetsData: Uint32Array,\n    dynamicOffsetsDataStart: number,\n    dynamicOffsetsDataLength: number,\n  ): undefined;\n  pushDebugGroup(groupLabel: string): undefined;\n  popDebugGroup(): undefined;\n  insertDebugMarker(markerLabel: string): undefined;\n  setPipeline(pipeline: GPUComputePipeline): undefined;\n  dispatch(x: number, y?: number, z?: number): undefined;\n  dispatchIndirect(\n    indirectBuffer: GPUBuffer,\n    indirectOffset: number,\n  ): undefined;\n\n  beginPipelineStatisticsQuery(\n    querySet: GPUQuerySet,\n    queryIndex: number,\n  ): undefined;\n  endPipelineStatisticsQuery(): undefined;\n\n  writeTimestamp(querySet: GPUQuerySet, queryIndex: number): undefined;\n\n  endPass(): undefined;\n}\n\ndeclare interface GPUComputePassDescriptor extends GPUObjectDescriptorBase {}\n\ninterface GPURenderEncoderBase {\n  setPipeline(pipeline: GPURenderPipeline): undefined;\n\n  setIndexBuffer(\n    buffer: GPUBuffer,\n    indexFormat: GPUIndexFormat,\n    offset?: number,\n    size?: number,\n  ): undefined;\n  setVertexBuffer(\n    slot: number,\n    buffer: GPUBuffer,\n    offset?: number,\n    size?: number,\n  ): undefined;\n\n  draw(\n    vertexCount: number,\n    instanceCount?: number,\n    firstVertex?: number,\n    firstInstance?: number,\n  ): undefined;\n  drawIndexed(\n    indexCount: number,\n    instanceCount?: number,\n    firstIndex?: number,\n    baseVertex?: number,\n    firstInstance?: number,\n  ): undefined;\n\n  drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): undefined;\n  drawIndexedIndirect(\n    indirectBuffer: GPUBuffer,\n    indirectOffset: number,\n  ): undefined;\n}\n\ndeclare class GPURenderPassEncoder\n  implements GPUObjectBase, GPUProgrammablePassEncoder, GPURenderEncoderBase {\n  label: string | null;\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup,\n    dynamicOffsets?: number[],\n  ): undefined;\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup,\n    dynamicOffsetsData: Uint32Array,\n    dynamicOffsetsDataStart: number,\n    dynamicOffsetsDataLength: number,\n  ): undefined;\n  pushDebugGroup(groupLabel: string): undefined;\n  popDebugGroup(): undefined;\n  insertDebugMarker(markerLabel: string): undefined;\n  setPipeline(pipeline: GPURenderPipeline): undefined;\n  setIndexBuffer(\n    buffer: GPUBuffer,\n    indexFormat: GPUIndexFormat,\n    offset?: number,\n    size?: number,\n  ): undefined;\n  setVertexBuffer(\n    slot: number,\n    buffer: GPUBuffer,\n    offset?: number,\n    size?: number,\n  ): undefined;\n  draw(\n    vertexCount: number,\n    instanceCount?: number,\n    firstVertex?: number,\n    firstInstance?: number,\n  ): undefined;\n  drawIndexed(\n    indexCount: number,\n    instanceCount?: number,\n    firstIndex?: number,\n    baseVertex?: number,\n    firstInstance?: number,\n  ): undefined;\n  drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): undefined;\n  drawIndexedIndirect(\n    indirectBuffer: GPUBuffer,\n    indirectOffset: number,\n  ): undefined;\n\n  setViewport(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    minDepth: number,\n    maxDepth: number,\n  ): undefined;\n\n  setScissorRect(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n  ): undefined;\n\n  setBlendColor(color: GPUColor): undefined;\n  setStencilReference(reference: number): undefined;\n\n  beginOcclusionQuery(queryIndex: number): undefined;\n  endOcclusionQuery(): undefined;\n\n  beginPipelineStatisticsQuery(\n    querySet: GPUQuerySet,\n    queryIndex: number,\n  ): undefined;\n  endPipelineStatisticsQuery(): undefined;\n\n  writeTimestamp(querySet: GPUQuerySet, queryIndex: number): undefined;\n\n  executeBundles(bundles: GPURenderBundle[]): undefined;\n  endPass(): undefined;\n}\n\ndeclare interface GPURenderPassDescriptor extends GPUObjectDescriptorBase {\n  colorAttachments: GPURenderPassColorAttachment[];\n  depthStencilAttachment?: GPURenderPassDepthStencilAttachment;\n  occlusionQuerySet?: GPUQuerySet;\n}\n\ndeclare interface GPURenderPassColorAttachment {\n  view: GPUTextureView;\n  resolveTarget?: GPUTextureView;\n\n  loadValue: GPULoadOp | GPUColor;\n  storeOp?: GPUStoreOp;\n}\n\ndeclare interface GPURenderPassDepthStencilAttachment {\n  view: GPUTextureView;\n\n  depthLoadValue: GPULoadOp | number;\n  depthStoreOp: GPUStoreOp;\n  depthReadOnly?: boolean;\n\n  stencilLoadValue: GPULoadOp | number;\n  stencilStoreOp: GPUStoreOp;\n  stencilReadOnly?: boolean;\n}\n\ndeclare type GPULoadOp = \"load\";\n\ndeclare type GPUStoreOp = \"store\" | \"clear\";\n\ndeclare class GPURenderBundle implements GPUObjectBase {\n  label: string | null;\n}\n\ndeclare interface GPURenderBundleDescriptor extends GPUObjectDescriptorBase {}\n\ndeclare class GPURenderBundleEncoder\n  implements GPUObjectBase, GPUProgrammablePassEncoder, GPURenderEncoderBase {\n  label: string | null;\n  draw(\n    vertexCount: number,\n    instanceCount?: number,\n    firstVertex?: number,\n    firstInstance?: number,\n  ): undefined;\n  drawIndexed(\n    indexCount: number,\n    instanceCount?: number,\n    firstIndex?: number,\n    baseVertex?: number,\n    firstInstance?: number,\n  ): undefined;\n  drawIndexedIndirect(\n    indirectBuffer: GPUBuffer,\n    indirectOffset: number,\n  ): undefined;\n  drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: number): undefined;\n  insertDebugMarker(markerLabel: string): undefined;\n  popDebugGroup(): undefined;\n  pushDebugGroup(groupLabel: string): undefined;\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup,\n    dynamicOffsets?: number[],\n  ): undefined;\n  setBindGroup(\n    index: number,\n    bindGroup: GPUBindGroup,\n    dynamicOffsetsData: Uint32Array,\n    dynamicOffsetsDataStart: number,\n    dynamicOffsetsDataLength: number,\n  ): undefined;\n  setIndexBuffer(\n    buffer: GPUBuffer,\n    indexFormat: GPUIndexFormat,\n    offset?: number,\n    size?: number,\n  ): undefined;\n  setPipeline(pipeline: GPURenderPipeline): undefined;\n  setVertexBuffer(\n    slot: number,\n    buffer: GPUBuffer,\n    offset?: number,\n    size?: number,\n  ): undefined;\n\n  finish(descriptor?: GPURenderBundleDescriptor): GPURenderBundle;\n}\n\ndeclare interface GPURenderBundleEncoderDescriptor\n  extends GPUObjectDescriptorBase {\n  colorFormats: GPUTextureFormat[];\n  depthStencilFormat?: GPUTextureFormat;\n  sampleCount?: number;\n}\n\ndeclare class GPUQueue implements GPUObjectBase {\n  label: string | null;\n\n  submit(commandBuffers: GPUCommandBuffer[]): undefined;\n\n  onSubmittedWorkDone(): Promise<undefined>;\n\n  writeBuffer(\n    buffer: GPUBuffer,\n    bufferOffset: number,\n    data: BufferSource,\n    dataOffset?: number,\n    size?: number,\n  ): undefined;\n\n  writeTexture(\n    destination: GPUImageCopyTexture,\n    data: BufferSource,\n    dataLayout: GPUImageDataLayout,\n    size: GPUExtent3D,\n  ): undefined;\n}\n\ndeclare class GPUQuerySet implements GPUObjectBase {\n  label: string | null;\n\n  destroy(): undefined;\n}\n\ndeclare interface GPUQuerySetDescriptor extends GPUObjectDescriptorBase {\n  type: GPUQueryType;\n  count: number;\n  pipelineStatistics?: GPUPipelineStatisticName[];\n}\n\ndeclare type GPUQueryType = \"occlusion\" | \"pipeline-statistics\" | \"timestamp\";\n\ndeclare type GPUPipelineStatisticName =\n  | \"vertex-shader-invocations\"\n  | \"clipper-invocations\"\n  | \"clipper-primitives-out\"\n  | \"fragment-shader-invocations\"\n  | \"compute-shader-invocations\";\n\ndeclare type GPUDeviceLostReason = \"destroyed\";\n\ndeclare interface GPUDeviceLostInfo {\n  readonly reason: GPUDeviceLostReason | undefined;\n  readonly message: string;\n}\n\ndeclare type GPUErrorFilter = \"out-of-memory\" | \"validation\";\n\ndeclare class GPUOutOfMemoryError {\n  constructor();\n}\n\ndeclare class GPUValidationError {\n  constructor(message: string);\n  readonly message: string;\n}\n\ndeclare type GPUError = GPUOutOfMemoryError | GPUValidationError;\n\ndeclare class GPUUncapturedErrorEvent extends Event {\n  constructor(\n    type: string,\n    gpuUncapturedErrorEventInitDict: GPUUncapturedErrorEventInit,\n  );\n  readonly error: GPUError;\n}\n\ndeclare interface GPUUncapturedErrorEventInit extends EventInit {\n  error?: GPUError;\n}\n\ndeclare interface GPUColorDict {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n}\n\ndeclare type GPUColor = number[] | GPUColorDict;\n\ndeclare interface GPUOrigin3DDict {\n  x?: number;\n  y?: number;\n  z?: number;\n}\n\ndeclare type GPUOrigin3D = number[] | GPUOrigin3DDict;\n\ndeclare interface GPUExtent3DDict {\n  width?: number;\n  height?: number;\n  depth?: number;\n}\n\ndeclare type GPUExtent3D = number[] | GPUExtent3DDict;\n\n// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.\n\n// deno-lint-ignore-file no-explicit-any\n\n/// <reference no-default-lib=\"true\" />\n/// <reference lib=\"esnext\" />\n\ninterface CloseEventInit extends EventInit {\n  code?: number;\n  reason?: string;\n  wasClean?: boolean;\n}\n\ndeclare class CloseEvent extends Event {\n  constructor(type: string, eventInitDict?: CloseEventInit);\n  /**\n   * Returns the WebSocket connection close code provided by the server.\n   */\n  readonly code: number;\n  /**\n   * Returns the WebSocket connection close reason provided by the server.\n   */\n  readonly reason: string;\n  /**\n   * Returns true if the connection closed cleanly; false otherwise.\n   */\n  readonly wasClean: boolean;\n}\n\ninterface WebSocketEventMap {\n  close: CloseEvent;\n  error: Event;\n  message: MessageEvent;\n  open: Event;\n}\n\n/** Provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection. */\ndeclare class WebSocket extends EventTarget {\n  constructor(url: string, protocols?: string | string[]);\n\n  static readonly CLOSED: number;\n  static readonly CLOSING: number;\n  static readonly CONNECTING: number;\n  static readonly OPEN: number;\n\n  /**\n   * Returns a string that indicates how binary data from the WebSocket object is exposed to scripts:\n   *\n   * Can be set, to change how binary data is returned. The default is \"blob\".\n   */\n  binaryType: BinaryType;\n  /**\n   * Returns the number of bytes of application data (UTF-8 text and binary data) that have been queued using send() but not yet been transmitted to the network.\n   *\n   * If the WebSocket connection is closed, this attribute's value will only increase with each call to the send() method. (The number does not reset to zero once the connection closes.)\n   */\n  readonly bufferedAmount: number;\n  /**\n   * Returns the extensions selected by the server, if any.\n   */\n  readonly extensions: string;\n  onclose: ((this: WebSocket, ev: CloseEvent) => any) | null;\n  onerror: ((this: WebSocket, ev: Event | ErrorEvent) => any) | null;\n  onmessage: ((this: WebSocket, ev: MessageEvent) => any) | null;\n  onopen: ((this: WebSocket, ev: Event) => any) | null;\n  /**\n   * Returns the subprotocol selected by the server, if any. It can be used in conjunction with the array form of the constructor's second argument to perform subprotocol negotiation.\n   */\n  readonly protocol: string;\n  /**\n   * Returns the state of the WebSocket object's connection. It can have the values described below.\n   */\n  readonly readyState: number;\n  /**\n   * Returns the URL that was used to establish the WebSocket connection.\n   */\n  readonly url: string;\n  /**\n   * Closes the WebSocket connection, optionally using code as the the WebSocket connection close code and reason as the the WebSocket connection close reason.\n   */\n  close(code?: number, reason?: string): void;\n  /**\n   * Transmits data using the WebSocket connection. data can be a string, a Blob, an ArrayBuffer, or an ArrayBufferView.\n   */\n  send(data: string | ArrayBufferLike | Blob | ArrayBufferView): void;\n  readonly CLOSED: number;\n  readonly CLOSING: number;\n  readonly CONNECTING: number;\n  readonly OPEN: number;\n  addEventListener<K extends keyof WebSocketEventMap>(\n    type: K,\n    listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  removeEventListener<K extends keyof WebSocketEventMap>(\n    type: K,\n    listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any,\n    options?: boolean | EventListenerOptions,\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void;\n}\n\ntype BinaryType = \"arraybuffer\" | \"blob\";\n\n// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.\n\n// Documentation partially adapted from [MDN](https://developer.mozilla.org/),\n// by Mozilla Contributors, which is licensed under CC-BY-SA 2.5.\n\n/// <reference no-default-lib=\"true\" />\n/// <reference lib=\"esnext\" />\n/// <reference lib=\"deno.web\" />\n/// <reference lib=\"deno.fetch\" />\n/// <reference lib=\"deno.websocket\" />\n/// <reference lib=\"deno.crypto\" />\n\ndeclare namespace WebAssembly {\n  /**\n   * The `WebAssembly.CompileError` object indicates an error during WebAssembly decoding or validation.\n   *\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/CompileError)\n   */\n  export class CompileError extends Error {\n    /** Creates a new `WebAssembly.CompileError` object. */\n    constructor();\n  }\n\n  /**\n   * A `WebAssembly.Global` object represents a global variable instance, accessible from\n   * both JavaScript and importable/exportable across one or more `WebAssembly.Module`\n   * instances. This allows dynamic linking of multiple modules.\n   *\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Global)\n   */\n  export class Global {\n    /** Creates a new `Global` object. */\n    constructor(descriptor: GlobalDescriptor, v?: any);\n\n    /**\n     * The value contained inside the global variable — this can be used to directly set\n     * and get the global's value.\n     */\n    value: any;\n\n    /** Old-style method that returns the value contained inside the global variable. */\n    valueOf(): any;\n  }\n\n  /**\n   * A `WebAssembly.Instance` object is a stateful, executable instance of a `WebAssembly.Module`.\n   * Instance objects contain all the Exported WebAssembly functions that allow calling into\n   * WebAssembly code from JavaScript.\n   *\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Instance)\n   */\n  export class Instance {\n    /** Creates a new Instance object. */\n    constructor(module: Module, importObject?: Imports);\n\n    /**\n     * Returns an object containing as its members all the functions exported from the\n     * WebAssembly module instance, to allow them to be accessed and used by JavaScript.\n     * Read-only.\n     */\n    readonly exports: Exports;\n  }\n\n  /**\n   * The `WebAssembly.LinkError` object indicates an error during module instantiation\n   * (besides traps from the start function).\n   *\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/LinkError)\n   */\n  export class LinkError extends Error {\n    /** Creates a new WebAssembly.LinkError object. */\n    constructor();\n  }\n\n  /**\n   * The `WebAssembly.Memory` object is a resizable `ArrayBuffer` or `SharedArrayBuffer` that\n   * holds the raw bytes of memory accessed by a WebAssembly Instance.\n   *\n   * A memory created by JavaScript or in WebAssembly code will be accessible and mutable\n   * from both JavaScript and WebAssembly.\n   *\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory)\n   */\n  export class Memory {\n    /** Creates a new `Memory` object. */\n    constructor(descriptor: MemoryDescriptor);\n\n    /** An accessor property that returns the buffer contained in the memory. */\n    readonly buffer: ArrayBuffer;\n\n    /**\n     * Increases the size of the memory instance by a specified number of WebAssembly\n     * pages (each one is 64KB in size).\n     */\n    grow(delta: number): number;\n  }\n\n  /**\n   * A `WebAssembly.Module` object contains stateless WebAssembly code that has already been compiled\n   * by the browser — this can be efficiently shared with Workers, and instantiated multiple times.\n   *\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module)\n   */\n  export class Module {\n    /** Creates a new `Module` object. */\n    constructor(bytes: BufferSource);\n\n    /**\n     * Given a `Module` and string, returns a copy of the contents of all custom sections in the\n     * module with the given string name.\n     * */\n    static customSections(\n      moduleObject: Module,\n      sectionName: string,\n    ): ArrayBuffer[];\n\n    /** Given a `Module`, returns an array containing descriptions of all the declared exports. */\n    static exports(moduleObject: Module): ModuleExportDescriptor[];\n\n    /** Given a `Module`, returns an array containing descriptions of all the declared imports. */\n    static imports(moduleObject: Module): ModuleImportDescriptor[];\n  }\n\n  /**\n   * The `WebAssembly.RuntimeError` object is the error type that is thrown whenever WebAssembly\n   * specifies a trap.\n   *\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/RuntimeError)\n   */\n  export class RuntimeError extends Error {\n    /** Creates a new `WebAssembly.RuntimeError` object. */\n    constructor();\n  }\n\n  /**\n   * The `WebAssembly.Table()` object is a JavaScript wrapper object — an array-like structure\n   * representing a WebAssembly Table, which stores function references. A table created by\n   * JavaScript or in WebAssembly code will be accessible and mutable from both JavaScript\n   * and WebAssembly.\n   *\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Table)\n   */\n  export class Table {\n    /** Creates a new `Table` object. */\n    constructor(descriptor: TableDescriptor);\n\n    /** Returns the length of the table, i.e. the number of elements. */\n    readonly length: number;\n\n    /** Accessor function — gets the element stored at a given index. */\n    get(index: number): Function | null;\n\n    /** Increases the size of the `Table` instance by a specified number of elements. */\n    grow(delta: number): number;\n\n    /** Sets an element stored at a given index to a given value. */\n    set(index: number, value: Function | null): void;\n  }\n\n  /** The `GlobalDescriptor` describes the options you can pass to `new WebAssembly.Global()`. */\n  export interface GlobalDescriptor {\n    mutable?: boolean;\n    value: ValueType;\n  }\n\n  /** The `MemoryDescriptor` describes the options you can pass to `new WebAssembly.Memory()`. */\n  export interface MemoryDescriptor {\n    initial: number;\n    maximum?: number;\n  }\n\n  /** A `ModuleExportDescriptor` is the description of a declared export in a `WebAssembly.Module`. */\n  export interface ModuleExportDescriptor {\n    kind: ImportExportKind;\n    name: string;\n  }\n\n  /** A `ModuleImportDescriptor` is the description of a declared import in a `WebAssembly.Module`. */\n  export interface ModuleImportDescriptor {\n    kind: ImportExportKind;\n    module: string;\n    name: string;\n  }\n\n  /** The `TableDescriptor` describes the options you can pass to `new WebAssembly.Table()`. */\n  export interface TableDescriptor {\n    element: TableKind;\n    initial: number;\n    maximum?: number;\n  }\n\n  /** The value returned from `WebAssembly.instantiate` and `WebAssembly.instantiateStreaming`. */\n  export interface WebAssemblyInstantiatedSource {\n    /* A `WebAssembly.Instance` object that contains all the exported WebAssembly functions. */\n    instance: Instance;\n\n    /**\n     * A `WebAssembly.Module` object representing the compiled WebAssembly module.\n     * This `Module` can be instantiated again, or shared via postMessage().\n     */\n    module: Module;\n  }\n\n  export type ImportExportKind = \"function\" | \"global\" | \"memory\" | \"table\";\n  export type TableKind = \"anyfunc\";\n  export type ValueType = \"f32\" | \"f64\" | \"i32\" | \"i64\";\n  export type ExportValue = Function | Global | Memory | Table;\n  export type Exports = Record<string, ExportValue>;\n  export type ImportValue = ExportValue | number;\n  export type ModuleImports = Record<string, ImportValue>;\n  export type Imports = Record<string, ModuleImports>;\n\n  /**\n   * The `WebAssembly.compile()` function compiles WebAssembly binary code into a\n   * `WebAssembly.Module` object. This function is useful if it is necessary to compile\n   * a module before it can be instantiated (otherwise, the `WebAssembly.instantiate()`\n   * function should be used).\n   *\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compile)\n   */\n  export function compile(bytes: BufferSource): Promise<Module>;\n\n  /**\n   * The `WebAssembly.compileStreaming()` function compiles a `WebAssembly.Module`\n   * directly from a streamed underlying source.  This function is useful if it\n   * is necessary to a compile a module before it can be instantiated (otherwise,\n   * the `WebAssembly.instantiateStreaming()` function should be used).\n   *\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compileStreaming)\n   */\n  export function compileStreaming(\n    source: Response | Promise<Response>,\n  ): Promise<Module>;\n\n  /**\n   * The WebAssembly.instantiate() function allows you to compile and instantiate\n   * WebAssembly code.\n   *\n   * This overload takes the WebAssembly binary code, in the form of a typed\n   * array or ArrayBuffer, and performs both compilation and instantiation in one step.\n   * The returned Promise resolves to both a compiled WebAssembly.Module and its first\n   * WebAssembly.Instance.\n   *\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate)\n   */\n  export function instantiate(\n    bytes: BufferSource,\n    importObject?: Imports,\n  ): Promise<WebAssemblyInstantiatedSource>;\n\n  /**\n   * The WebAssembly.instantiate() function allows you to compile and instantiate\n   * WebAssembly code.\n   *\n   * This overload takes an already-compiled WebAssembly.Module and returns\n   * a Promise that resolves to an Instance of that Module. This overload is useful\n   * if the Module has already been compiled.\n   *\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate)\n   */\n  export function instantiate(\n    moduleObject: Module,\n    importObject?: Imports,\n  ): Promise<Instance>;\n\n  /**\n   * The `WebAssembly.instantiateStreaming()` function compiles and instantiates a\n   * WebAssembly module directly from a streamed underlying source. This is the most\n   * efficient, optimized way to load WebAssembly code.\n   *\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming)\n   */\n  export function instantiateStreaming(\n    response: Response | PromiseLike<Response>,\n    importObject?: Imports,\n  ): Promise<WebAssemblyInstantiatedSource>;\n\n  /**\n   * The `WebAssembly.validate()` function validates a given typed array of\n   * WebAssembly binary code, returning whether the bytes form a valid wasm\n   * module (`true`) or not (`false`).\n   *\n   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/validate)\n   */\n  export function validate(bytes: BufferSource): boolean;\n}\n\n/** Sets a timer which executes a function once after the timer expires. Returns\n * an id which may be used to cancel the timeout.\n *\n *     setTimeout(() => { console.log('hello'); }, 500);\n */\ndeclare function setTimeout(\n  /** callback function to execute when timer expires */\n  cb: (...args: any[]) => void,\n  /** delay in ms */\n  delay?: number,\n  /** arguments passed to callback function */\n  ...args: any[]\n): number;\n\n/** Repeatedly calls a function , with a fixed time delay between each call.\n *\n *     // Outputs 'hello' to the console every 500ms\n *     setInterval(() => { console.log('hello'); }, 500);\n */\ndeclare function setInterval(\n  /** callback function to execute when timer expires */\n  cb: (...args: any[]) => void,\n  /** delay in ms */\n  delay?: number,\n  /** arguments passed to callback function */\n  ...args: any[]\n): number;\n\n/** Cancels a timed, repeating action which was previously started by a call\n * to `setInterval()`\n *\n *     const id = setInterval(() => {console.log('hello');}, 500);\n *     ...\n *     clearInterval(id);\n */\ndeclare function clearInterval(id?: number): void;\n\n/** Cancels a scheduled action initiated by `setTimeout()`\n *\n *     const id = setTimeout(() => {console.log('hello');}, 500);\n *     ...\n *     clearTimeout(id);\n */\ndeclare function clearTimeout(id?: number): void;\n\ninterface VoidFunction {\n  (): void;\n}\n\n/** A microtask is a short function which is executed after the function or\n * module which created it exits and only if the JavaScript execution stack is\n * empty, but before returning control to the event loop being used to drive the\n * script's execution environment. This event loop may be either the main event\n * loop or the event loop driving a web worker.\n *\n *     queueMicrotask(() => { console.log('This event loop stack is complete'); });\n */\ndeclare function queueMicrotask(func: VoidFunction): void;\n\n/** Registers an event listener in the global scope, which will be called\n * synchronously whenever the event `type` is dispatched.\n *\n *     addEventListener('unload', () => { console.log('All finished!'); });\n *     ...\n *     dispatchEvent(new Event('unload'));\n */\ndeclare function addEventListener(\n  type: string,\n  callback: EventListenerOrEventListenerObject | null,\n  options?: boolean | AddEventListenerOptions | undefined,\n): void;\n\n/** Dispatches an event in the global scope, synchronously invoking any\n * registered event listeners for this event in the appropriate order. Returns\n * false if event is cancelable and at least one of the event handlers which\n * handled this event called Event.preventDefault(). Otherwise it returns true.\n *\n *     dispatchEvent(new Event('unload'));\n */\ndeclare function dispatchEvent(event: Event): boolean;\n\n/** Remove a previously registered event listener from the global scope\n *\n *     const lstnr = () => { console.log('hello'); };\n *     addEventListener('load', lstnr);\n *     removeEventListener('load', lstnr);\n */\ndeclare function removeEventListener(\n  type: string,\n  callback: EventListenerOrEventListenerObject | null,\n  options?: boolean | EventListenerOptions | undefined,\n): void;\n\ninterface DOMStringList {\n  /** Returns the number of strings in strings. */\n  readonly length: number;\n  /** Returns true if strings contains string, and false otherwise. */\n  contains(string: string): boolean;\n  /** Returns the string with index index from strings. */\n  item(index: number): string | null;\n  [index: number]: string;\n}\n\ntype BufferSource = ArrayBufferView | ArrayBuffer;\n\ndeclare interface Console {\n  assert(condition?: boolean, ...data: any[]): void;\n  clear(): void;\n  count(label?: string): void;\n  countReset(label?: string): void;\n  debug(...data: any[]): void;\n  dir(item?: any, options?: any): void;\n  dirxml(...data: any[]): void;\n  error(...data: any[]): void;\n  group(...data: any[]): void;\n  groupCollapsed(...data: any[]): void;\n  groupEnd(): void;\n  info(...data: any[]): void;\n  log(...data: any[]): void;\n  table(tabularData?: any, properties?: string[]): void;\n  time(label?: string): void;\n  timeEnd(label?: string): void;\n  timeLog(label?: string, ...data: any[]): void;\n  timeStamp(label?: string): void;\n  trace(...data: any[]): void;\n  warn(...data: any[]): void;\n}\n\ndeclare var console: Console;\n\ninterface MessageEventInit<T = any> extends EventInit {\n  data?: T;\n  origin?: string;\n  lastEventId?: string;\n}\n\ndeclare class MessageEvent<T = any> extends Event {\n  /**\n   * Returns the data of the message.\n   */\n  readonly data: T;\n  /**\n   * Returns the last event ID string, for server-sent events.\n   */\n  readonly lastEventId: string;\n  constructor(type: string, eventInitDict?: MessageEventInit);\n}\n\ninterface ErrorEventInit extends EventInit {\n  message?: string;\n  filename?: string;\n  lineno?: number;\n  colno?: number;\n  error?: any;\n}\n\ndeclare class ErrorEvent extends Event {\n  readonly message: string;\n  readonly filename: string;\n  readonly lineno: number;\n  readonly colno: number;\n  readonly error: any;\n  constructor(type: string, eventInitDict?: ErrorEventInit);\n}\n\ninterface PostMessageOptions {\n  transfer?: any[];\n}\n\ninterface AbstractWorkerEventMap {\n  \"error\": ErrorEvent;\n}\n\ninterface WorkerEventMap extends AbstractWorkerEventMap {\n  \"message\": MessageEvent;\n  \"messageerror\": MessageEvent;\n}\n\ninterface WorkerOptions {\n  type?: \"classic\" | \"module\";\n  name?: string;\n}\n\ndeclare class Worker extends EventTarget {\n  onerror?: (e: ErrorEvent) => void;\n  onmessage?: (e: MessageEvent) => void;\n  onmessageerror?: (e: MessageEvent) => void;\n  constructor(\n    specifier: string,\n    options?: WorkerOptions,\n  );\n  postMessage(message: any, transfer: ArrayBuffer[]): void;\n  postMessage(message: any, options?: PostMessageOptions): void;\n  addEventListener<K extends keyof WorkerEventMap>(\n    type: K,\n    listener: (this: Worker, ev: WorkerEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  removeEventListener<K extends keyof WorkerEventMap>(\n    type: K,\n    listener: (this: Worker, ev: WorkerEventMap[K]) => any,\n    options?: boolean | EventListenerOptions,\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void;\n  terminate(): void;\n}\n\ndeclare type PerformanceEntryList = PerformanceEntry[];\n\ndeclare class Performance {\n  constructor();\n\n  /** Removes the stored timestamp with the associated name. */\n  clearMarks(markName?: string): void;\n\n  /** Removes stored timestamp with the associated name. */\n  clearMeasures(measureName?: string): void;\n\n  getEntries(): PerformanceEntryList;\n  getEntriesByName(name: string, type?: string): PerformanceEntryList;\n  getEntriesByType(type: string): PerformanceEntryList;\n\n  /** Stores a timestamp with the associated name (a \"mark\"). */\n  mark(markName: string, options?: PerformanceMarkOptions): PerformanceMark;\n\n  /** Stores the `DOMHighResTimeStamp` duration between two marks along with the\n   * associated name (a \"measure\"). */\n  measure(\n    measureName: string,\n    options?: PerformanceMeasureOptions,\n  ): PerformanceMeasure;\n  /** Stores the `DOMHighResTimeStamp` duration between two marks along with the\n   * associated name (a \"measure\"). */\n  measure(\n    measureName: string,\n    startMark?: string,\n    endMark?: string,\n  ): PerformanceMeasure;\n\n  /** Returns a current time from Deno's start in milliseconds.\n   *\n   * Use the permission flag `--allow-hrtime` return a precise value.\n   *\n   * ```ts\n   * const t = performance.now();\n   * console.log(`${t} ms since start!`);\n   * ```\n   */\n  now(): number;\n}\n\ndeclare var performance: Performance;\n\ndeclare interface PerformanceMarkOptions {\n  /** Metadata to be included in the mark. */\n  detail?: any;\n\n  /** Timestamp to be used as the mark time. */\n  startTime?: number;\n}\n\ndeclare interface PerformanceMeasureOptions {\n  /** Metadata to be included in the measure. */\n  detail?: any;\n\n  /** Timestamp to be used as the start time or string to be used as start\n   * mark.*/\n  start?: string | number;\n\n  /** Duration between the start and end times. */\n  duration?: number;\n\n  /** Timestamp to be used as the end time or string to be used as end mark. */\n  end?: string | number;\n}\n\n/** Encapsulates a single performance metric that is part of the performance\n * timeline. A performance entry can be directly created by making a performance\n * mark or measure (for example by calling the `.mark()` method) at an explicit\n * point in an application. */\ndeclare class PerformanceEntry {\n  readonly duration: number;\n  readonly entryType: string;\n  readonly name: string;\n  readonly startTime: number;\n  toJSON(): any;\n}\n\n/** `PerformanceMark` is an abstract interface for `PerformanceEntry` objects\n * with an entryType of `\"mark\"`. Entries of this type are created by calling\n * `performance.mark()` to add a named `DOMHighResTimeStamp` (the mark) to the\n * performance timeline. */\ndeclare class PerformanceMark extends PerformanceEntry {\n  readonly detail: any;\n  readonly entryType: \"mark\";\n  constructor(name: string, options?: PerformanceMarkOptions);\n}\n\n/** `PerformanceMeasure` is an abstract interface for `PerformanceEntry` objects\n * with an entryType of `\"measure\"`. Entries of this type are created by calling\n * `performance.measure()` to add a named `DOMHighResTimeStamp` (the measure)\n * between two marks to the performance timeline. */\ndeclare class PerformanceMeasure extends PerformanceEntry {\n  readonly detail: any;\n  readonly entryType: \"measure\";\n}\n\ndeclare interface CustomEventInit<T = any> extends EventInit {\n  detail?: T;\n}\n\ndeclare class CustomEvent<T = any> extends Event {\n  constructor(typeArg: string, eventInitDict?: CustomEventInit<T>);\n  /** Returns any custom data event was created with. Typically used for\n   * synthetic events. */\n  readonly detail: T;\n}\n\ninterface ErrorConstructor {\n  /** See https://v8.dev/docs/stack-trace-api#stack-trace-collection-for-custom-exceptions. */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  captureStackTrace(error: Object, constructor?: Function): void;\n  // TODO(nayeemrmn): Support `Error.prepareStackTrace()`. We currently use this\n  // internally in a way that makes it unavailable for users.\n}\n\n// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.\n\n/// <reference no-default-lib=\"true\" />\n/// <reference lib=\"deno.ns\" />\n/// <reference lib=\"deno.shared_globals\" />\n/// <reference lib=\"deno.webgpu\" />\n/// <reference lib=\"esnext\" />\n\ndeclare class Window extends EventTarget {\n  new(): Window;\n  readonly window: Window & typeof globalThis;\n  readonly self: Window & typeof globalThis;\n  onload: ((this: Window, ev: Event) => any) | null;\n  onunload: ((this: Window, ev: Event) => any) | null;\n  close: () => void;\n  readonly closed: boolean;\n  alert: (message?: string) => void;\n  confirm: (message?: string) => boolean;\n  prompt: (message?: string, defaultValue?: string) => string | null;\n  Deno: typeof Deno;\n  Navigator: typeof Navigator;\n  navigator: Navigator;\n  Location: typeof Location;\n  location: Location;\n}\n\ndeclare var window: Window & typeof globalThis;\ndeclare var self: Window & typeof globalThis;\ndeclare var onload: ((this: Window, ev: Event) => any) | null;\ndeclare var onunload: ((this: Window, ev: Event) => any) | null;\n\ndeclare class Navigator {\n  constructor();\n  readonly gpu: GPU;\n}\n\ndeclare var navigator: Navigator;\n\n/**\n * Shows the given message and waits for the enter key pressed.\n * If the stdin is not interactive, it does nothing.\n * @param message\n */\ndeclare function alert(message?: string): void;\n\n/**\n * Shows the given message and waits for the answer. Returns the user's answer as boolean.\n * Only `y` and `Y` are considered as true.\n * If the stdin is not interactive, it returns false.\n * @param message\n */\ndeclare function confirm(message?: string): boolean;\n\n/**\n * Shows the given message and waits for the user's input. Returns the user's input as string.\n * If the default value is given and the user inputs the empty string, then it returns the given\n * default value.\n * If the default value is not given and the user inputs the empty string, it returns null.\n * If the stdin is not interactive, it returns null.\n * @param message\n * @param defaultValue\n */\ndeclare function prompt(message?: string, defaultValue?: string): string | null;\n\n// TODO(nayeemrmn): Move this to `op_crates/web` where its implementation is.\n// The types there must first be split into window, worker and global types.\n/** The location (URL) of the object it is linked to. Changes done on it are\n * reflected on the object it relates to. Accessible via\n * `globalThis.location`. */\ndeclare class Location {\n  constructor();\n  /** Returns a DOMStringList object listing the origins of the ancestor\n   * browsing contexts, from the parent browsing context to the top-level\n   * browsing context.\n   *\n   * Always empty in Deno. */\n  readonly ancestorOrigins: DOMStringList;\n  /** Returns the Location object's URL's fragment (includes leading \"#\" if\n   * non-empty).\n   *\n   * Cannot be set in Deno. */\n  hash: string;\n  /** Returns the Location object's URL's host and port (if different from the\n   * default port for the scheme).\n   *\n   * Cannot be set in Deno. */\n  host: string;\n  /** Returns the Location object's URL's host.\n   *\n   * Cannot be set in Deno. */\n  hostname: string;\n  /** Returns the Location object's URL.\n   *\n   * Cannot be set in Deno. */\n  href: string;\n  toString(): string;\n  /** Returns the Location object's URL's origin. */\n  readonly origin: string;\n  /** Returns the Location object's URL's path.\n   *\n   * Cannot be set in Deno. */\n  pathname: string;\n  /** Returns the Location object's URL's port.\n   *\n   * Cannot be set in Deno. */\n  port: string;\n  /** Returns the Location object's URL's scheme.\n   *\n   * Cannot be set in Deno. */\n  protocol: string;\n  /** Returns the Location object's URL's query (includes leading \"?\" if\n   * non-empty).\n   *\n   * Cannot be set in Deno. */\n  search: string;\n  /** Navigates to the given URL.\n   *\n   * Cannot be set in Deno. */\n  assign(url: string): void;\n  /** Reloads the current page.\n   *\n   * Disabled in Deno. */\n  reload(): void;\n  /** @deprecated */\n  reload(forcedReload: boolean): void;\n  /** Removes the current page from the session history and navigates to the\n   * given URL.\n   *\n   * Disabled in Deno. */\n  replace(url: string): void;\n}\n\n// TODO(nayeemrmn): Move this to `op_crates/web` where its implementation is.\n// The types there must first be split into window, worker and global types.\ndeclare var location: Location;\n",
			"file": "lib.deno.d.ts",
			"file_size": 177891,
			"file_write_time": 132601020139175741,
			"settings":
			{
				"buffer_size": 177593,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "deno_src/docs/examples/subprocess.md",
			"settings":
			{
				"buffer_size": 2362,
				"line_ending": "Unix"
			}
		},
		{
			"file": "deno_doc/src/class.rs",
			"settings":
			{
				"buffer_size": 10284,
				"line_ending": "Unix"
			}
		},
		{
			"file": ".gitignore",
			"settings":
			{
				"buffer_size": 187,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "Packages/User/Node.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/Flow/Flow.sublime-build",
					""
				],
				[
					"Packages/TypeScript/TypeScript.sublime-build",
					""
				],
				[
					"Packages/User/Node.sublime-build",
					""
				],
				[
					"Packages/User/Node.sublime-build",
					"Node ESM(.mjs)"
				],
				[
					"Packages/User/Node.sublime-build",
					"TypeScript Deno"
				],
				[
					"Packages/User/Node.sublime-build",
					"TypeScript ts-node"
				],
				[
					"Packages/User/Node.sublime-build",
					"TypeScript Watch"
				],
				[
					"Packages/User/Node.sublime-build",
					"TypeScript => ES3"
				],
				[
					"Packages/User/Node.sublime-build",
					"TypeScript => ES5"
				],
				[
					"Packages/User/Node.sublime-build",
					"TypeScript => ES6"
				],
				[
					"Packages/User/Node.sublime-build",
					"ES6(ECMAScript 2015)"
				],
				[
					"Packages/User/Node.sublime-build",
					"ES5(ECMAScript 2009)"
				]
			],
			[
				"Packages/User/Node.sublime-build",
				"TypeScript Deno"
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"preview",
				"Markdown Preview: Preview in Browser"
			],
			[
				"save pro",
				"Project: Save As"
			],
			[
				"enable",
				"Table Editor: Enable for current view"
			],
			[
				"Enable vie",
				"Table Editor: Enable for current view"
			],
			[
				"previ",
				"Markdown Preview: Preview in Browser"
			],
			[
				"rena",
				"Rename File"
			],
			[
				"re",
				"Rename File"
			],
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"push",
				"Git: Push Current Branch"
			],
			[
				"com",
				"Git: Commit"
			],
			[
				"add",
				"Git: Add All"
			],
			[
				"live",
				"MarkdownLivePreview: Open Preview"
			],
			[
				"emmet",
				"Emmet: Evaluate Math Expression"
			],
			[
				"ex",
				"Emmet: Expand Abbreviation"
			],
			[
				"Package Control: up",
				"Package Control: List Unmanaged Packages"
			],
			[
				"ins",
				"Package Control: Install Package"
			],
			[
				"dis",
				"Package Control: Disable Package"
			],
			[
				"enablep",
				"Package Control: Enable Package"
			],
			[
				"comm",
				"Git: Commit"
			],
			[
				"status",
				"Git: Status"
			],
			[
				"pus",
				"Git: Push Current Branch"
			],
			[
				"git add",
				"Git: Add All"
			],
			[
				"up",
				"Package Control: Upgrade Package"
			],
			[
				"math",
				"Emmet: Evaluate Math Expression"
			],
			[
				"enab",
				"Package Control: Enable Package"
			],
			[
				"in",
				"Package Control: Install Package"
			],
			[
				"mat",
				"Emmet: Evaluate Math Expression"
			],
			[
				"matth",
				"Emmet: Evaluate Math Expression"
			],
			[
				"en",
				"Package Control: Enable Package"
			],
			[
				"commit",
				"Git: Commit"
			],
			[
				"inc",
				"Emmet: Increment Number by 1"
			],
			[
				"ma",
				"Emmet: Evaluate Math Expression"
			],
			[
				"emmet ",
				"Emmet: Balance Inward"
			],
			[
				"emmet in",
				"Emmet: Capture Abbreviation"
			],
			[
				"remo",
				"Package Control: Remove Package"
			],
			[
				"endable ",
				"Table Editor: Enable for current syntax"
			],
			[
				" Math  ",
				"HTMLPrettify: Set `node` Path"
			],
			[
				"add rep",
				"Package Control: Add Repository"
			],
			[
				"enable p",
				"Package Control: Enable Package"
			],
			[
				"emm",
				"Preferences: Emmet Key Bindings"
			],
			[
				"git:lo",
				"Git: Log All"
			],
			[
				"edit",
				"Project: Edit Project"
			],
			[
				"mark",
				"Set Syntax: Markdown"
			],
			[
				"rename",
				"Rename File"
			],
			[
				"theme",
				"UI: Select Color Scheme"
			],
			[
				"co",
				"Git: Commit"
			],
			[
				"disable\t",
				"Package Control: Disable Package"
			],
			[
				"disable",
				"Package Control: Disable Package"
			],
			[
				"pu",
				"Git: Push Current Branch"
			],
			[
				"git",
				"Git: Add All"
			],
			[
				"key",
				"Preferences: Key Bindings"
			],
			[
				"selection",
				"Rot13 Selection"
			],
			[
				"ren",
				"Rename File"
			],
			[
				"uniq",
				"Permute Lines: Unique"
			],
			[
				"instal",
				"Package Control: Install Package"
			],
			[
				"reane",
				"Rename File"
			],
			[
				"gitadd",
				"Git: Add All"
			],
			[
				"emmet:",
				"Emmet: Expand Abbreviation"
			],
			[
				"disable ",
				"Package Control: Disable Package"
			],
			[
				"ena",
				"Package Control: Enable Package"
			],
			[
				"disab",
				"Package Control: Disable Package"
			],
			[
				"disabl",
				"Package Control: Disable Package"
			],
			[
				"enable cur",
				"Table Editor: Enable for current view"
			],
			[
				"pushc",
				"Git: Push Current Branch"
			],
			[
				"stat",
				"Git: Status"
			],
			[
				"table edit",
				"Table Editor: Enable for current view"
			],
			[
				"table",
				"Table Editor: Show demo film in new scratch view"
			],
			[
				"previe",
				"Markdown Preview: Preview in Browser"
			],
			[
				"markown",
				"Markdown Preview: Preview in Browser"
			],
			[
				"pack",
				"Package Control: Install Package"
			],
			[
				"endable",
				"Package Control: Disable Package"
			],
			[
				"enabl",
				"Package Control: Enable Package"
			],
			[
				"la",
				"LaTeXTools: Clear cache"
			],
			[
				"html",
				"HTMLPrettify"
			],
			[
				"erlang",
				"Set Syntax: Erlang"
			],
			[
				"diff",
				"Set Syntax: Diff"
			],
			[
				"inst",
				"Package Control: Install Package"
			],
			[
				"disa",
				"Package Control: Disable Package"
			],
			[
				"package",
				"Package Control: Install Package"
			],
			[
				"utf",
				"ConvertToUTF8: Reload with Encoding"
			],
			[
				"TypesCript",
				"TypeScript: Signature Info"
			],
			[
				"markdown",
				"Set Syntax: MultiMarkdown"
			],
			[
				"debug",
				"SublimeCodeIntel: Enable Debug Mode"
			],
			[
				"Package Control: ",
				"Package Control: Install Package"
			],
			[
				"them",
				"UI: Select Theme"
			],
			[
				"new pro",
				"Project Manager: Add New Project"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 237.0,
		"history":
		[
			"r = os.system(\"cmd /k echo >>c:/coding/md/log.txt\")",
			"r = os.system(\"cmd /k \\\"echo c:/coding/md/log.txt mkdir c:\\mkdir\\\"\")",
			"r = os.system(\"cmd /k echo \\\"c:/coding/md/log.txt mkdir c:\\mkdir\\\"\")",
			"r = os.system(\"cmd /k echo c:/coding/md/log.txt mkdir c:\\mkdir'\")",
			"r = os.system(\"cmd /k 'echo c:/coding/md/log.txt mkdir c:\\mkdir'\")",
			"r = os.system(\"cmd -k echo c:/coding/md/log.txt mkdir c:\\mkdir\")",
			"r = os.system(\"echo c:/coding/md/log.txt mkdir c:\\mkdir\")",
			"r = os.system(\"echo c:/log.txt mkdir c:\\mkdir\")",
			"r = os.system(\"echo c:\\\\log.txt mkdir c:\\mkdir\")",
			"r = os.system(\"mkdir c:\\mkdir\")",
			"r = os.system(\"cwd .\")",
			"print(r)",
			"r = os.system(\"dir .\")",
			"print(r)",
			"pring(r)",
			"r = os.system(\"dir\")",
			"os.system(\"dir\")",
			"subprocess.run(\"ls\")",
			"subprocess.run()",
			"import subprocess",
			"subprocess.run()",
			"import commands",
			"for i in val.readlines()",
			"for i in val.readlines(): &  print(i)",
			"for i in val.readlines()  print(i)",
			"for i in val.readlines(): print(i)",
			"for i in val.readlines():",
			"val = os.popen('ls -al')",
			"val = os.ppopen('ls -al')",
			"val = os.Ppopen('ls -al')",
			"import os",
			"val = os.Ppopen('ls -al')",
			"cwd"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/coding/md-code/deno",
		"/C/coding/md-code/deno/deno_src",
		"/C/coding/md-code/deno/deno_src/cli",
		"/C/coding/md-code/deno/deno_src/cli/dts",
		"/C/coding/md-code/deno/deno_src/third_party",
		"/C/coding/md-code/deno/doc_website"
	],
	"file_history":
	[
		"/C/coding/md-code/deno/deno_src/op_crates/crypto/01_crypto.js",
		"/C/Users/OCEAN/AppData/Roaming/Sublime Text 3/Packages/User/Node.sublime-build",
		"/C/coding/md-code/node-v12.18.3/deps/v8/tools/profview/index.html",
		"/C/coding/md-code/node-v12.18.3/doc/changelogs/CHANGELOG_V12.md",
		"/C/coding/md-code/node-v12.18.3/doc/changelogs/CHANGELOG_V012.md",
		"/C/coding/md-code/node-v12.18.3/benchmark/async_hooks/http-server.js",
		"/C/coding/md/go/golang.md",
		"/C/Users/OCEAN/AppData/Roaming/Sublime Text 3/Packages/User/GoLang.sublime-build",
		"/C/coding/md/webpack/deno.md",
		"/C/coding/md-code/coding/worker.js",
		"/C/coding/md-code/coding/deno.js",
		"/C/coding/md/c-daystep/readme_vue.md",
		"/C/coding/md/webpack/nestjs.md",
		"/C/coding/md/diagram.md",
		"/C/coding/md/writing/VirtualNes/the_force_Forth.md",
		"/C/coding/md/writing/cb/define_initialization_2.html",
		"/C/coding/md/c-daystep/readme.md",
		"/C/coding/md/java.md",
		"/C/coding/md/http/http_fiddler.md",
		"/C/coding/md/socket.io/go-my-websocket.md",
		"/C/coding/md/webpack/readme_css.md",
		"/C/coding/md/webpack/readme_es6.md",
		"/C/coding/md/readme_php.md",
		"/C/coding/md/webpack/nextjs.md",
		"/C/coding/md/SpringBoot.md",
		"//wsl$/Ubuntu/home/jeango/arcblock/abt-blocklet-demo/src/Loading.js",
		"/C/coding/md/rsa/readme_rsa.md",
		"/C/coding/md-code/bitcoin-master/Makefile.am",
		"/C/coding/md-code/blockchain-tutorial/README.md",
		"/C/coding/md/webpack/graphql.md",
		"//wsl$/Ubuntu/home/jeango/arcblock/abt-blocklet-demo/public/blockraw/150000.json",
		"//wsl$/Ubuntu/home/jeango/arcblock/abt-blocklet-demo/public/blockraw/2.json",
		"//wsl$/Ubuntu/home/jeango/arcblock/abt-blocklet-demo/public/blockraw/4.json",
		"//wsl$/Ubuntu/home/jeango/arcblock/abt-blocklet-demo/public/blockraw/3.json",
		"//wsl$/Ubuntu/home/jeango/arcblock/abt-blocklet-demo/public/blockraw/100000.json",
		"//wsl$/Ubuntu/home/jeango/arcblock/abt-blocklet-demo/public/blockraw/1.json",
		"/C/Users/OCEAN/AppData/Roaming/Sublime Text 3/Packages/HTML-CSS-JS Prettify/HTMLPrettify.sublime-settings",
		"/C/coding/md/readme_git.md",
		"/C/coding/md/readme_curl.md",
		"/C/coding/md/readme_linux.md",
		"//wsl$/Ubuntu/home/jeango/arcblock/abt-blocklet-demo/.blocklet/release/blocklet.json",
		"/C/download/blocklet (1).json",
		"/C/coding/md/Readme2012/readme.js",
		"/C/Users/OCEAN/.ssh/id_rsa.pub",
		"/C/Users/OCEAN/AppData/Local/Yarn/Data/global/node_modules/@abtnode/cli/bin/abtnode.js",
		"/C/download/blocklet.json",
		"/C/coding/md-code/arcblock/react-demo-main/blocklet.yml",
		"/C/Users/OCEAN/AppData/Local/Temp/Rar$DIa12156.41727/打开获取资源的【解压密码】.txt",
		"/C/coding/md-code/arcblock/react-demo-0.1.4/node_modules/blockchain-manager/package.json",
		"/C/download/package/build/service-worker.js",
		"/C/download/package/package.json",
		"/C/download/package/api/libs/hooks/pre-stop.js",
		"/C/Users/OCEAN/AppData/Local/Temp/Rar$DIa19652.42251/README.md",
		"//wsl$/ubuntu/home/jeango/.nvm/versions/node/v15.9.0/bin/abtnode",
		"/C/coding/md/OpenGL/Makefile.md",
		"/C/coding/md/OpenGL/ccpp.md",
		"/C/coding/md/db/mysql.md",
		"/C/coding/md/readme_win.md",
		"/C/coding/md-code/nest-demo/dist/main.js",
		"/C/coding/md/webpack/readme_ng.md",
		"/C/Users/OCEAN/AppData/Local/Temp/Rar$DIa15816.5701/README.md",
		"/C/iceWorks/react-motion-master/demos/demo0-simple-transition/Demo.jsx",
		"/C/coding/md-code/coding/demo.html",
		"/C/coding/md-code/coding/deno.ts",
		"/C/coding/md/webpack/readme_ts.md",
		"/C/Users/OCEAN/AppData/Local/Temp/Rar$DIa12904.15079/Readme.txt",
		"/C/Users/OCEAN/AppData/Local/Temp/Rar$DIa12904.18111/Readme.txt",
		"/C/coding/md/webpack/node.md",
		"/C/coding/md/OpenToonz/Blender.md",
		"/C/coding/md/Erlang.md",
		"/C/coding/md/opengl/svg.md",
		"/C/coding/md/accme.md",
		"/C/pictures/a/Izumi Sakai (4).jpeg",
		"/C/coding/md-code/webgl-demos/src/WebGLInstanced.tsx",
		"/C/coding/md-code/webgl-demos/src/logo.svg",
		"/C/coding/md-code/webgl-demos/build/static/js/3.177c5e33.chunk.js.LICENSE.txt",
		"/C/coding/md-code/webgl-demos/build/static/js/3.177c5e33.chunk.js",
		"/C/download/web/Chinese.xml",
		"/C/coding/md-code/webgl-demos/README.md",
		"/C/coding/md-code/webgl-demos/react-demo/package.json",
		"/C/coding/md-code/webgl-demos/tsconfig.json",
		"/C/vcpkg/installed/x64-mingw/include/GL/glfw3.h",
		"/C/vcpkg/installed/x64-mingw/include/GL/glfw3native.h",
		"/C/download/programming/cg/glslcookbook-master/chapter01/Makefile",
		"/C/download/programming/cg/glslcookbook-master/Makefile",
		"/C/download/programming/cg/glslcookbook-master/chapter01/README",
		"/C/download/programming/cg/glslcookbook-master/README.md",
		"/C/download/programming/cg/glm-master/Src/CMakeLists.txt",
		"/C/coding/md-code/three.js/examples/textures/3d/Readme.txt",
		"/C/coding/md-code/wxgame-typescript-starter/project.config.json",
		"/C/coding/宝宝需要/xiubaobao/xiubaobao/project.config.json",
		"/C/Users/OCEAN/AppData/Local/Temp/Rar$DIa7096.8363/使用说明.txt",
		"/C/Users/OCEAN/AppData/Local/Temp/Rar$DIa7096.28619/使用说明.txt",
		"/C/Users/OCEAN/AppData/Local/Temp/Rar$DIa7096.3730/使用说明.txt",
		"/C/coding/md/forex.md",
		"/C/coding/md/Elixir.md",
		"/C/coding/md/csharp.md",
		"/C/coding/md/Xamarin.md",
		"/C/coding/md/OpenGL/OpenCV.md",
		"/C/coding/md/philosophy.md",
		"/C/coding/md/ccpp.md",
		"/C/download/OpenCV/smallpt/Makefile",
		"/C/download/OpenCV/smallpt/README",
		"/C/download/OpenCV/smallpt/smallpt.cpp",
		"/C/coding/md/webpack/electron.md",
		"/C/coding/md/OpenGL/LinearAlgebra.md",
		"/C/pictures/draw/多边形 1.svg",
		"/C/pictures/draw/组 12.svg",
		"/C/pictures/draw/apple.svg",
		"/C/pictures/draw/多边形 2.svg",
		"/C/pictures/draw/矩形 3.svg",
		"/C/pictures/draw/路径 3.svg",
		"/C/pictures/draw/联合 1.svg",
		"/C/pictures/draw/排除 6.svg",
		"/C/pictures/draw/矩形 4.svg",
		"/C/download/batik-1.14/samples/mathMetal.svg",
		"/C/coding/md/readme_sublime.md",
		"/C/coding/md/etest.html",
		"/C/coding/md/writing/unicode/coding.html",
		"/C/coding/Yeen/raw/index.html",
		"/C/coding/minis/vu/README.md",
		"/C/coding/minis/readme.rst",
		"/C/coding/md/dart-flutter/dart-flutter.md",
		"/C/coding/md/readme_android.md",
		"/C/flutter/examples/README.md",
		"/C/flutter/examples-new/flutter_gallery.readme",
		"/C/flutter/examples/flutter_gallery.readme",
		"/C/Users/OCEAN/AppData/Roaming/Sublime Text 3/Packages/User/Dart 2.2.sublime-build"
	],
	"find":
	{
		"height": 22.0
	},
	"find_in_files":
	{
		"height": 451.0,
		"where_history":
		[
			"C:\\coding\\md-code\\deno\\deno_src"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"export class Process<T extends RunOptions = RunOptions> ",
			"Deno.run",
			"int ",
			"console"
		],
		"highlight": false,
		"in_selection": false,
		"preserve_case": true,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 3,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "tsconfig.json",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6184,
						"regions":
						{
						},
						"selection":
						[
							[
								703,
								703
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"is_init_dirty_state": false,
							"origin_encoding": "ASCII",
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/JavaScript/JSON.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"typescript_plugin_format_options":
							{
								"convertTabsToSpaces": true,
								"indentSize": 4,
								"tabSize": 4
							}
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "demo/gpu.ts",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1209,
						"regions":
						{
						},
						"selection":
						[
							[
								435,
								435
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"is_init_dirty_state": false,
							"origin_encoding": "UTF-8",
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/TypeScript/TypeScript.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true,
							"use_tab_stops": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "deno_src/cli/dts/lib.deno.ns.d.ts",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 81394,
						"regions":
						{
						},
						"selection":
						[
							[
								1238,
								1238
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/TypeScript/TypeScript.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true,
							"typescript_plugin_format_options":
							{
								"convertTabsToSpaces": true,
								"indentSize": 2,
								"tabSize": 2
							},
							"use_tab_stops": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "deno_src/cli/dts/lib.dom.d.ts",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 842607,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/TypeScript/TypeScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"typescript_plugin_format_options":
							{
								"convertTabsToSpaces": true,
								"indentSize": 4,
								"tabSize": 4
							},
							"use_tab_stops": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "lib.deno.d.ts",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 177593,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/TypeScript/TypeScript.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true,
							"use_tab_stops": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "deno_src/docs/examples/subprocess.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2362,
						"regions":
						{
						},
						"selection":
						[
							[
								1125,
								1125
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"origin_encoding": "ASCII",
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/Markdown/Markdown.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 375.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "deno_doc/src/class.rs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10284,
						"regions":
						{
						},
						"selection":
						[
							[
								6928,
								6928
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"origin_encoding": "ASCII",
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/Rust Enhanced/RustEnhanced.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2950.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": ".gitignore",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 187,
						"regions":
						{
						},
						"selection":
						[
							[
								97,
								97
							]
						],
						"settings":
						{
							"incomplete_sync": null,
							"origin_encoding": "ASCII",
							"remote_loading": false,
							"synced": false,
							"syntax": "Packages/Git Formats/Git Ignore.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 22.0
	},
	"input":
	{
		"height": 153.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.SFTP":
	{
		"height": 0.0
	},
	"output.doc":
	{
		"height": 0.0
	},
	"output.exec":
	{
		"height": 350.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "deno.sublime-project",
	"replace":
	{
		"height": 40.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"lib.dom.d.ts",
				"deno_src\\cli\\dts\\lib.dom.d.ts"
			],
			[
				"lib",
				"lib.deno.d.ts"
			],
			[
				"subprocess",
				"deno_src\\docs\\examples\\subprocess.md"
			],
			[
				"profview",
				"deps\\v8\\tools\\profview\\index.html"
			],
			[
				"_http_server",
				"lib\\_http_server.js"
			],
			[
				"http",
				"lib\\http.js"
			],
			[
				"cluster child",
				"lib\\internal\\cluster\\child.js"
			],
			[
				"clus",
				"lib\\cluster.js"
			],
			[
				"golang",
				"md\\go\\golang.md"
			],
			[
				"node",
				"md\\webpack\\node.md"
			],
			[
				"vue",
				"md\\c-daystep\\readme_vue.md"
			],
			[
				"di",
				"md\\diagram.md"
			],
			[
				"ccpp",
				"md\\OpenGL\\ccpp.md"
			],
			[
				"erlan",
				"md\\Erlang.md"
			],
			[
				"css",
				"md\\webpack\\readme_css.md"
			],
			[
				"readme.js",
				"md\\Readme2012\\readme.js"
			],
			[
				"es",
				"md\\webpack\\readme_es6.md"
			],
			[
				"goweb",
				"md\\socket.io\\go-my-websocket.md"
			],
			[
				"spring",
				"md\\SpringBoot.md"
			],
			[
				"ras",
				"md\\rsa\\readme_rsa.md"
			],
			[
				"next",
				"md\\webpack\\nextjs.md"
			],
			[
				"cur",
				"md\\readme_curl.md"
			],
			[
				"linux",
				"md\\readme_linux.md"
			],
			[
				"rsa",
				"md\\rsa\\readme_rsa.md"
			],
			[
				"git",
				"md\\readme_git.md"
			],
			[
				"blo",
				"md\\blockchain.md"
			],
			[
				"make",
				"md\\OpenGL\\Makefile.md"
			],
			[
				"win",
				"md\\readme_win.md"
			],
			[
				"mysql",
				"md\\db\\mysql.md"
			],
			[
				"ng.md",
				"md\\webpack\\readme_ng.md"
			],
			[
				"erlang",
				"md\\Erlang.md"
			],
			[
				"acc",
				"md\\accme.md"
			],
			[
				"linxu",
				"md\\readme_linux.md"
			],
			[
				"blender",
				"md\\OpenToonz\\Blender.md"
			],
			[
				"linea",
				"md\\OpenGL\\LinearAlgebra.md"
			],
			[
				"cpp.",
				"md\\ccpp.md"
			],
			[
				"alg",
				"md\\OpenGL\\LinearAlgebra.md"
			],
			[
				"sublime",
				"md\\readme_sublime.md"
			],
			[
				"html",
				"md\\etest.html"
			],
			[
				"coding.html",
				"md\\writing\\unicode\\coding.html"
			],
			[
				"node.",
				"md\\webpack\\node.md"
			],
			[
				"android",
				"md\\readme_android.md"
			],
			[
				"dart",
				"md\\dart-flutter\\dart-flutter.md"
			],
			[
				"es6",
				"md\\webpack\\readme_es6.md"
			],
			[
				"my",
				"md\\db\\mysql.md"
			],
			[
				"coding.js",
				"coding\\coding.js"
			],
			[
				"coding.ts",
				"coding\\coding.ts"
			],
			[
				"ts",
				"md\\webpack\\readme_ts.md"
			],
			[
				"rea",
				"md\\readme.md"
			],
			[
				"sub",
				"md\\readme_sublime.md"
			],
			[
				"react",
				"md\\webpack\\readme_react.md"
			],
			[
				"php",
				"md\\readme_php.md"
			],
			[
				"curl",
				"md\\readme_curl.md"
			],
			[
				"api",
				"md\\minis\\wxappApi3Action.class.php"
			],
			[
				"webpack",
				"md\\webpack\\readme_webpack.md"
			],
			[
				"sublime.",
				"md\\readme_sublime.md"
			],
			[
				"cod",
				"coding\\coding.py"
			],
			[
				"win.",
				"md\\readme_win.md"
			],
			[
				"webpac",
				"md\\webpack\\readme_webpack.md"
			],
			[
				"forex.html",
				"md\\forex.html"
			],
			[
				"webp",
				"md\\webpack\\readme_webpack.md"
			],
			[
				"codingphp",
				"coding\\coding.php"
			],
			[
				"test.h",
				"md\\writing\\random-test\\rand_test.html"
			],
			[
				"go",
				"md\\go\\golang.md"
			],
			[
				"action.",
				"md\\minis\\wxappApi3Action.class.php"
			],
			[
				"index.html",
				"md\\c-daystep\\index.html"
			],
			[
				"cpp.md",
				"md\\ccpp.md"
			],
			[
				"stm",
				"md\\STM\\STM32_Nucleo.md"
			],
			[
				"lua",
				"coding\\coding.lua"
			],
			[
				"coding.l",
				"coding\\coding.lisp"
			],
			[
				"coding",
				"coding\\coding.py"
			],
			[
				"git.",
				"md\\readme_git.md"
			],
			[
				"spa",
				"md\\c-daystep\\spa.html"
			],
			[
				"ts.",
				"md\\webpack\\readme_ts.md"
			],
			[
				".ts",
				"coding\\coding.ts"
			],
			[
				"readme.",
				"md\\readme.md"
			],
			[
				"index",
				"md\\c-daystep\\index.html"
			],
			[
				"java.md",
				"md\\readme_java.md"
			],
			[
				"bl",
				"md\\OpenToonz\\Blender.md"
			],
			[
				"mt",
				"md\\mtd\\mtd.py"
			],
			[
				"ff",
				"md\\OpenToonz\\ffmpeg.md"
			],
			[
				"re",
				"md\\readme.md"
			],
			[
				"redis",
				"md\\db\\redis.md"
			],
			[
				"opencv",
				"md\\OpenGL\\OpenCV.md"
			],
			[
				"cv",
				"md\\cv.md"
			],
			[
				"accme",
				"md\\accme.md"
			],
			[
				"read",
				"md\\readme.md"
			],
			[
				"ddos",
				"md\\DDOS.md"
			],
			[
				"echarts",
				"md\\echart\\readme_echarts.md"
			],
			[
				"gopl",
				"md\\go\\readme_gopl.md"
			],
			[
				"liN",
				"md\\OpenGL\\LinearAlgebra.md"
			],
			[
				"mongo",
				"md\\db\\readme.MongoDB.md"
			],
			[
				"mfc",
				"md\\writing\\mfc\\mfc.html"
			],
			[
				"dia",
				"md\\diagram.md"
			],
			[
				"ffme",
				"md\\OpenToonz\\ffmpeg.md"
			],
			[
				"readme",
				"md\\readme.md"
			],
			[
				"csharp",
				"md\\csharp.md"
			],
			[
				"bootsrap",
				"md\\readme_bootstrap.md"
			],
			[
				"net.md",
				"md\\readme_net.md"
			],
			[
				"hugo",
				"md\\writing\\hugo.md"
			],
			[
				"vim",
				"md\\vim\\readme_vim.md"
			],
			[
				"open",
				"md\\OpenGL\\OpenGL.md"
			],
			[
				"socket",
				"md\\socket.io\\go-my-websocket.md"
			],
			[
				"java",
				"User\\java.sublime-build"
			],
			[
				"",
				"md\\readme_git.md"
			],
			[
				"m",
				"md\\writing\\mfc\\mfc.md"
			],
			[
				"rpc",
				"md\\socket.io\\gRPC_protobuf.md"
			],
			[
				"python",
				"md\\readme_python.md"
			],
			[
				"linu",
				"md\\readme_linux.md"
			],
			[
				"proto",
				"md\\socket.io\\Protocol Buffer.md"
			],
			[
				"go-",
				"md\\socket.io\\go-my-websocket.md"
			],
			[
				"block",
				"md\\blockchain.md"
			],
			[
				"Concurrency",
				"CPP-Concurrency-In-Action-2ed-2019-master\\README.md"
			],
			[
				"c",
				"md\\csharp.md"
			],
			[
				"gop",
				"md\\go\\readme_gopl.md"
			],
			[
				"ffm",
				"md\\OpenToonz\\ffmpeg.md"
			],
			[
				"ffmpg",
				"md\\OpenToonz\\ffmpeg.md"
			],
			[
				"coding.cpp",
				"coding\\coding.cpp"
			],
			[
				"css.md",
				"md\\webpack\\readme_css.md"
			],
			[
				"gol",
				"md\\go\\readme_golang.md"
			],
			[
				"golan",
				"md\\go\\readme_golang.md"
			],
			[
				".go",
				"coding\\main.go"
			],
			[
				"awslib",
				"sublime_diagram_plugin\\samples\\awslib.wsd"
			],
			[
				"listspr",
				"sublime_diagram_plugin\\samples\\listsprite.wsd"
			],
			[
				"cv.md",
				"md\\cv.md"
			],
			[
				"mark",
				"md\\Markdown Cheatsheet.md"
			],
			[
				"markdown",
				"md\\readme_markdown.md"
			],
			[
				"ref.wsd",
				"sublime_diagram_plugin\\samples\\ref.wsd"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"boo",
				"C:\\coding\\md-code\\bootstrap-5.0\\bootstrap.sublime-project"
			],
			[
				"",
				"C:\\coding\\md-code\\csdemo\\cs.sublime-project"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 392.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"_listen2",
				"server._listen2(address, port, addressType, backlog, fd, flags)"
			],
			[
				"createTrackbar",
				"createTrackbar"
			],
			[
				"addWeighted",
				"addWeighted"
			],
			[
				"resize",
				"resize"
			],
			[
				"ApplicationViewer",
				"QmlApplicationViewer"
			],
			[
				"cuda_GpuMat",
				"cuda_GpuMat"
			],
			[
				"Function: element",
				"Function: element"
			],
			[
				"element",
				"Function: element"
			],
			[
				"spawn",
				"Function: spawn"
			],
			[
				"start_timer",
				"Function: start_timer"
			],
			[
				"ethr_atomic_read",
				"ethr_atomic_read"
			],
			[
				"erts_atomic64_read_nob",
				"erts_atomic64_read_nob"
			],
			[
				"now_",
				"now_0"
			],
			[
				"erl_start",
				"erl_start"
			],
			[
				"process_main",
				"process_main"
			],
			[
				"bs_init2",
				"Function: do_bs_init_2"
			],
			[
				"ErlSub",
				"ErlSubBin"
			],
			[
				"ProcBin",
				"ProcBin"
			],
			[
				"SMALL",
				"small"
			],
			[
				"Process",
				"Process"
			],
			[
				"TAG_PRIMARY_LIST",
				"TAG_PRIMARY_LIST"
			],
			[
				"ErlDrvEntry",
				"ErlDrvEntry"
			],
			[
				"driver_entry",
				"add_driver_entry"
			],
			[
				"driver_select",
				"driver_select"
			],
			[
				"ready_output",
				"ready_output"
			],
			[
				"main",
				"main"
			],
			[
				"AddSingleTon",
				"TryAddSingleton"
			]
		],
		"width": 596.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 246.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
